/// This section of code leverages <a hrfe="https://codemirror.net">CodeMirror</a>
/// Replicating respective codemirror license as follows:
/// <hr/>
/// MIT License
/// Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a copy
/// of this software and associated documentation files (the "Software"), to deal
/// in the Software without restriction, including without limitation the rights
/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
/// copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice shall be included in
/// all copies or substantial portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
/// THE SOFTWARE.
/// 
/// <hr/>
Class ompare.Report.SourceViewBase
{

/// Location and Revision of this file in Perforce (Auto-updating)
Parameter SrcVer = "$Id$";

ClassMethod ScriptDiffMatchPatch()
{
	;W !,"<script>"
	W "(function(){function diff_match_patch(){this.Diff_Timeout=1;this.Diff_EditCost=4;this.Match_Threshold=0.5;this.Match_Distance=1E3;this.Patch_DeleteThreshold=0.5;this.Patch_Margin=4;this.Match_MaxBits=32}"
	W !,"diff_match_patch.prototype.diff_main=function(a,b,c,d){""undefined""==typeof d&&(d=0>=this.Diff_Timeout?Number.MAX_VALUE:(new Date).getTime()+1E3*this.Diff_Timeout);if(null==a||null==b)throw Error(""Null input. (diff_main)"");if(a==b)return a?[[0,a]]:[];""undefined""==typeof c&&(c=!0);var e=c,f=this.diff_commonPrefix(a,b);c=a.substring(0,f);a=a.substring(f);b=b.substring(f);var f=this.diff_commonSuffix(a,b),g=a.substring(a.length-f);a=a.substring(0,a.length-f);b=b.substring(0,b.length-f);a=this.diff_compute_(a,"
	W !,"b,e,d);c&&a.unshift([0,c]);g&&a.push([0,g]);this.diff_cleanupMerge(a);return a};"
	W !,"diff_match_patch.prototype.diff_compute_=function(a,b,c,d){if(!a)return[[1,b]];if(!b)return[[-1,a]];var e=a.length>b.length?a:b,f=a.length>b.length?b:a,g=e.indexOf(f);return-1!=g?(c=[[1,e.substring(0,g)],[0,f],[1,e.substring(g+f.length)]],a.length>b.length&&(c[0][0]=c[2][0]=-1),c):1==f.length?[[-1,a],[1,b]]:(e=this.diff_halfMatch_(a,b))?(f=e[0],a=e[1],g=e[2],b=e[3],e=e[4],f=this.diff_main(f,g,c,d),c=this.diff_main(a,b,c,d),f.concat([[0,e]],c)):c&&100<a.length&&100<b.length?this.diff_lineMode_(a,b,"
	W !,"d):this.diff_bisect_(a,b,d)};"
	W !,"diff_match_patch.prototype.diff_lineMode_=function(a,b,c){var d=this.diff_linesToChars_(a,b);a=d.chars1;b=d.chars2;d=d.lineArray;a=this.diff_main(a,b,!1,c);this.diff_charsToLines_(a,d);this.diff_cleanupSemantic(a);a.push([0,""""]);for(var e=d=b=0,f="""",g="""";b<a.length;){switch(a[b][0]){case 1:e++;g+=a[b][1];break;case -1:d++;f+=a[b][1];break;case 0:if(1<=d&&1<=e){a.splice(b-d-e,d+e);b=b-d-e;d=this.diff_main(f,g,!1,c);for(e=d.length-1;0<=e;e--)a.splice(b,0,d[e]);b+=d.length}d=e=0;g=f=""""}b++}a.pop();return a};"
	W !,"diff_match_patch.prototype.diff_bisect_=function(a,b,c){for(var d=a.length,e=b.length,f=Math.ceil((d+e)/2),g=f,h=2*f,j=Array(h),i=Array(h),k=0;k<h;k++)j[k]=-1,i[k]=-1;j[g+1]=0;i[g+1]=0;for(var k=d-e,q=0!=k%2,r=0,t=0,p=0,w=0,v=0;v<f&&!((new Date).getTime()>c);v++){for(var n=-v+r;n<=v-t;n+=2){var l=g+n,m;m=n==-v||n!=v&&j[l-1]<j[l+1]?j[l+1]:j[l-1]+1;for(var s=m-n;m<d&&s<e&&a.charAt(m)==b.charAt(s);)m++,s++;j[l]=m;if(m>d)t+=2;else if(s>e)r+=2;else if(q&&(l=g+k-n,0<=l&&l<h&&-1!=i[l])){var u=d-i[l];if(m>="
	W !,"u)return this.diff_bisectSplit_(a,b,m,s,c)}}for(n=-v+p;n<=v-w;n+=2){l=g+n;u=n==-v||n!=v&&i[l-1]<i[l+1]?i[l+1]:i[l-1]+1;for(m=u-n;u<d&&m<e&&a.charAt(d-u-1)==b.charAt(e-m-1);)u++,m++;i[l]=u;if(u>d)w+=2;else if(m>e)p+=2;else if(!q&&(l=g+k-n,0<=l&&(l<h&&-1!=j[l])&&(m=j[l],s=g+m-l,u=d-u,m>=u)))return this.diff_bisectSplit_(a,b,m,s,c)}}return[[-1,a],[1,b]]};"
	W !,"diff_match_patch.prototype.diff_bisectSplit_=function(a,b,c,d,e){var f=a.substring(0,c),g=b.substring(0,d);a=a.substring(c);b=b.substring(d);f=this.diff_main(f,g,!1,e);e=this.diff_main(a,b,!1,e);return f.concat(e)};"
	W !,"diff_match_patch.prototype.diff_linesToChars_=function(a,b){function c(a){for(var b="""",c=0,f=-1,g=d.length;f<a.length-1;){f=a.indexOf(""\n"",c);-1==f&&(f=a.length-1);var r=a.substring(c,f+1),c=f+1;(e.hasOwnProperty?e.hasOwnProperty(r):void 0!==e[r])?b+=String.fromCharCode(e[r]):(b+=String.fromCharCode(g),e[r]=g,d[g++]=r)}return b}var d=[],e={};d[0]="""";var f=c(a),g=c(b);return{chars1:f,chars2:g,lineArray:d}};"
	W !,"diff_match_patch.prototype.diff_charsToLines_=function(a,b){for(var c=0;c<a.length;c++){for(var d=a[c][1],e=[],f=0;f<d.length;f++)e[f]=b[d.charCodeAt(f)];a[c][1]=e.join("""")}};diff_match_patch.prototype.diff_commonPrefix=function(a,b){if(!a||!b||a.charAt(0)!=b.charAt(0))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(f,e)==b.substring(f,e)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};"
	W !,"diff_match_patch.prototype.diff_commonSuffix=function(a,b){if(!a||!b||a.charAt(a.length-1)!=b.charAt(b.length-1))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(a.length-e,a.length-f)==b.substring(b.length-e,b.length-f)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};"
	W !,"diff_match_patch.prototype.diff_commonOverlap_=function(a,b){var c=a.length,d=b.length;if(0==c||0==d)return 0;c>d?a=a.substring(c-d):c<d&&(b=b.substring(0,c));c=Math.min(c,d);if(a==b)return c;for(var d=0,e=1;;){var f=a.substring(c-e),f=b.indexOf(f);if(-1==f)return d;e+=f;if(0==f||a.substring(c-e)==b.substring(0,e))d=e,e++}};"
	W !,"diff_match_patch.prototype.diff_halfMatch_=function(a,b){function c(a,b,c){for(var d=a.substring(c,c+Math.floor(a.length/4)),e=-1,g="""",h,j,n,l;-1!=(e=b.indexOf(d,e+1));){var m=f.diff_commonPrefix(a.substring(c),b.substring(e)),s=f.diff_commonSuffix(a.substring(0,c),b.substring(0,e));g.length<s+m&&(g=b.substring(e-s,e)+b.substring(e,e+m),h=a.substring(0,c-s),j=a.substring(c+m),n=b.substring(0,e-s),l=b.substring(e+m))}return 2*g.length>=a.length?[h,j,n,l,g]:null}if(0>=this.Diff_Timeout)return null;"
	W !,"var d=a.length>b.length?a:b,e=a.length>b.length?b:a;if(4>d.length||2*e.length<d.length)return null;var f=this,g=c(d,e,Math.ceil(d.length/4)),d=c(d,e,Math.ceil(d.length/2)),h;if(!g&&!d)return null;h=d?g?g[4].length>d[4].length?g:d:d:g;var j;a.length>b.length?(g=h[0],d=h[1],e=h[2],j=h[3]):(e=h[0],j=h[1],g=h[2],d=h[3]);h=h[4];return[g,d,e,j,h]};"
	W !,"diff_match_patch.prototype.diff_cleanupSemantic=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=0,h=0,j=0,i=0;f<a.length;)0==a[f][0]?(c[d++]=f,g=j,h=i,i=j=0,e=a[f][1]):(1==a[f][0]?j+=a[f][1].length:i+=a[f][1].length,e&&(e.length<=Math.max(g,h)&&e.length<=Math.max(j,i))&&(a.splice(c[d-1],0,[-1,e]),a[c[d-1]+1][0]=1,d--,d--,f=0<d?c[d-1]:-1,i=j=h=g=0,e=null,b=!0)),f++;b&&this.diff_cleanupMerge(a);this.diff_cleanupSemanticLossless(a);for(f=1;f<a.length;){if(-1==a[f-1][0]&&1==a[f][0]){b=a[f-1][1];c=a[f][1];"
	W !,"d=this.diff_commonOverlap_(b,c);e=this.diff_commonOverlap_(c,b);if(d>=e){if(d>=b.length/2||d>=c.length/2)a.splice(f,0,[0,c.substring(0,d)]),a[f-1][1]=b.substring(0,b.length-d),a[f+1][1]=c.substring(d),f++}else if(e>=b.length/2||e>=c.length/2)a.splice(f,0,[0,b.substring(0,e)]),a[f-1][0]=1,a[f-1][1]=c.substring(0,c.length-e),a[f+1][0]=-1,a[f+1][1]=b.substring(e),f++;f++}f++}};"
	W !,"diff_match_patch.prototype.diff_cleanupSemanticLossless=function(a){function b(a,b){if(!a||!b)return 6;var c=a.charAt(a.length-1),d=b.charAt(0),e=c.match(diff_match_patch.nonAlphaNumericRegex_),f=d.match(diff_match_patch.nonAlphaNumericRegex_),g=e&&c.match(diff_match_patch.whitespaceRegex_),h=f&&d.match(diff_match_patch.whitespaceRegex_),c=g&&c.match(diff_match_patch.linebreakRegex_),d=h&&d.match(diff_match_patch.linebreakRegex_),i=c&&a.match(diff_match_patch.blanklineEndRegex_),j=d&&b.match(diff_match_patch.blanklineStartRegex_);"
	W !,"return i||j?5:c||d?4:e&&!g&&h?3:g||h?2:e||f?1:0}for(var c=1;c<a.length-1;){if(0==a[c-1][0]&&0==a[c+1][0]){var d=a[c-1][1],e=a[c][1],f=a[c+1][1],g=this.diff_commonSuffix(d,e);if(g)var h=e.substring(e.length-g),d=d.substring(0,d.length-g),e=h+e.substring(0,e.length-g),f=h+f;for(var g=d,h=e,j=f,i=b(d,e)+b(e,f);e.charAt(0)===f.charAt(0);){var d=d+e.charAt(0),e=e.substring(1)+f.charAt(0),f=f.substring(1),k=b(d,e)+b(e,f);k>=i&&(i=k,g=d,h=e,j=f)}a[c-1][1]!=g&&(g?a[c-1][1]=g:(a.splice(c-1,1),c--),a[c][1]="
	W !,"h,j?a[c+1][1]=j:(a.splice(c+1,1),c--))}c++}};diff_match_patch.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/;diff_match_patch.whitespaceRegex_=/\s/;diff_match_patch.linebreakRegex_=/[\r\n]/;diff_match_patch.blanklineEndRegex_=/\n\r?\n$/;diff_match_patch.blanklineStartRegex_=/^\r?\n\r?\n/;"
	W !,"diff_match_patch.prototype.diff_cleanupEfficiency=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=!1,h=!1,j=!1,i=!1;f<a.length;){if(0==a[f][0])a[f][1].length<this.Diff_EditCost&&(j||i)?(c[d++]=f,g=j,h=i,e=a[f][1]):(d=0,e=null),j=i=!1;else if(-1==a[f][0]?i=!0:j=!0,e&&(g&&h&&j&&i||e.length<this.Diff_EditCost/2&&3==g+h+j+i))a.splice(c[d-1],0,[-1,e]),a[c[d-1]+1][0]=1,d--,e=null,g&&h?(j=i=!0,d=0):(d--,f=0<d?c[d-1]:-1,j=i=!1),b=!0;f++}b&&this.diff_cleanupMerge(a)};"
	W !,"diff_match_patch.prototype.diff_cleanupMerge=function(a){a.push([0,""""]);for(var b=0,c=0,d=0,e="""",f="""",g;b<a.length;)switch(a[b][0]){case 1:d++;f+=a[b][1];b++;break;case -1:c++;e+=a[b][1];b++;break;case 0:1<c+d?(0!==c&&0!==d&&(g=this.diff_commonPrefix(f,e),0!==g&&(0<b-c-d&&0==a[b-c-d-1][0]?a[b-c-d-1][1]+=f.substring(0,g):(a.splice(0,0,[0,f.substring(0,g)]),b++),f=f.substring(g),e=e.substring(g)),g=this.diff_commonSuffix(f,e),0!==g&&(a[b][1]=f.substring(f.length-g)+a[b][1],f=f.substring(0,f.length-"
	W !,"g),e=e.substring(0,e.length-g))),0===c?a.splice(b-d,c+d,[1,f]):0===d?a.splice(b-c,c+d,[-1,e]):a.splice(b-c-d,c+d,[-1,e],[1,f]),b=b-c-d+(c?1:0)+(d?1:0)+1):0!==b&&0==a[b-1][0]?(a[b-1][1]+=a[b][1],a.splice(b,1)):b++,c=d=0,f=e=""""}""""===a[a.length-1][1]&&a.pop();c=!1;for(b=1;b<a.length-1;)0==a[b-1][0]&&0==a[b+1][0]&&(a[b][1].substring(a[b][1].length-a[b-1][1].length)==a[b-1][1]?(a[b][1]=a[b-1][1]+a[b][1].substring(0,a[b][1].length-a[b-1][1].length),a[b+1][1]=a[b-1][1]+a[b+1][1],a.splice(b-1,1),c=!0):a[b][1].substring(0,"
	W !,"a[b+1][1].length)==a[b+1][1]&&(a[b-1][1]+=a[b+1][1],a[b][1]=a[b][1].substring(a[b+1][1].length)+a[b+1][1],a.splice(b+1,1),c=!0)),b++;c&&this.diff_cleanupMerge(a)};diff_match_patch.prototype.diff_xIndex=function(a,b){var c=0,d=0,e=0,f=0,g;for(g=0;g<a.length;g++){1!==a[g][0]&&(c+=a[g][1].length);-1!==a[g][0]&&(d+=a[g][1].length);if(c>b)break;e=c;f=d}return a.length!=g&&-1===a[g][0]?f:f+(b-e)};"
	W !,"diff_match_patch.prototype.diff_prettyHtml=function(a){for(var b=[],c=/&/g,d=/</g,e=/>/g,f=/\n/g,g=0;g<a.length;g++){var h=a[g][0],j=a[g][1],j=j.replace(c,""&amp;"").replace(d,""&lt;"").replace(e,""&gt;"").replace(f,""&para;<br>"");switch(h){case 1:b[g]='<ins style=""background:#e6ffe6;"">'+j+""</ins>"";break;case -1:b[g]='<del style=""background:#ffe6e6;"">'+j+""</del>"";break;case 0:b[g]=""<span>""+j+""</span>""}}return b.join("""")};"
	W !,"diff_match_patch.prototype.diff_text1=function(a){for(var b=[],c=0;c<a.length;c++)1!==a[c][0]&&(b[c]=a[c][1]);return b.join("""")};diff_match_patch.prototype.diff_text2=function(a){for(var b=[],c=0;c<a.length;c++)-1!==a[c][0]&&(b[c]=a[c][1]);return b.join("""")};diff_match_patch.prototype.diff_levenshtein=function(a){for(var b=0,c=0,d=0,e=0;e<a.length;e++){var f=a[e][0],g=a[e][1];switch(f){case 1:c+=g.length;break;case -1:d+=g.length;break;case 0:b+=Math.max(c,d),d=c=0}}return b+=Math.max(c,d)};"
	W !,"diff_match_patch.prototype.diff_toDelta=function(a){for(var b=[],c=0;c<a.length;c++)switch(a[c][0]){case 1:b[c]=""+""+encodeURI(a[c][1]);break;case -1:b[c]=""-""+a[c][1].length;break;case 0:b[c]=""=""+a[c][1].length}return b.join(""\t"").replace(/%20/g,"" "")};"
	W !,"diff_match_patch.prototype.diff_fromDelta=function(a,b){for(var c=[],d=0,e=0,f=b.split(/\t/g),g=0;g<f.length;g++){var h=f[g].substring(1);switch(f[g].charAt(0)){case ""+"":try{c[d++]=[1,decodeURI(h)]}catch(j){throw Error(""Illegal escape in diff_fromDelta: ""+h);}break;case ""-"":case ""="":var i=parseInt(h,10);if(isNaN(i)||0>i)throw Error(""Invalid number in diff_fromDelta: ""+h);h=a.substring(e,e+=i);""=""==f[g].charAt(0)?c[d++]=[0,h]:c[d++]=[-1,h];break;default:if(f[g])throw Error(""Invalid diff operation in diff_fromDelta: ""+"
	W !,"f[g]);}}if(e!=a.length)throw Error(""Delta length (""+e+"") does not equal source text length (""+a.length+"")."");return c};diff_match_patch.prototype.match_main=function(a,b,c){if(null==a||null==b||null==c)throw Error(""Null input. (match_main)"");c=Math.max(0,Math.min(c,a.length));return a==b?0:a.length?a.substring(c,c+b.length)==b?c:this.match_bitap_(a,b,c):-1};"
	W !,"diff_match_patch.prototype.match_bitap_=function(a,b,c){function d(a,d){var e=a/b.length,g=Math.abs(c-d);return!f.Match_Distance?g?1:e:e+g/f.Match_Distance}if(b.length>this.Match_MaxBits)throw Error(""Pattern too long for this browser."");var e=this.match_alphabet_(b),f=this,g=this.Match_Threshold,h=a.indexOf(b,c);-1!=h&&(g=Math.min(d(0,h),g),h=a.lastIndexOf(b,c+b.length),-1!=h&&(g=Math.min(d(0,h),g)));for(var j=1<<b.length-1,h=-1,i,k,q=b.length+a.length,r,t=0;t<b.length;t++){i=0;for(k=q;i<k;)d(t,c+"
	W !,"k)<=g?i=k:q=k,k=Math.floor((q-i)/2+i);q=k;i=Math.max(1,c-k+1);var p=Math.min(c+k,a.length)+b.length;k=Array(p+2);for(k[p+1]=(1<<t)-1;p>=i;p--){var w=e[a.charAt(p-1)];k[p]=0===t?(k[p+1]<<1|1)&w:(k[p+1]<<1|1)&w|((r[p+1]|r[p])<<1|1)|r[p+1];if(k[p]&j&&(w=d(t,p-1),w<=g))if(g=w,h=p-1,h>c)i=Math.max(1,2*c-h);else break}if(d(t+1,c)>g)break;r=k}return h};"
	W !,"diff_match_patch.prototype.match_alphabet_=function(a){for(var b={},c=0;c<a.length;c++)b[a.charAt(c)]=0;for(c=0;c<a.length;c++)b[a.charAt(c)]|=1<<a.length-c-1;return b};"
	W !,"diff_match_patch.prototype.patch_addContext_=function(a,b){if(0!=b.length){for(var c=b.substring(a.start2,a.start2+a.length1),d=0;b.indexOf(c)!=b.lastIndexOf(c)&&c.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)d+=this.Patch_Margin,c=b.substring(a.start2-d,a.start2+a.length1+d);d+=this.Patch_Margin;(c=b.substring(a.start2-d,a.start2))&&a.diffs.unshift([0,c]);(d=b.substring(a.start2+a.length1,a.start2+a.length1+d))&&a.diffs.push([0,d]);a.start1-=c.length;a.start2-=c.length;a.length1+="
	W !,"c.length+d.length;a.length2+=c.length+d.length}};"
	W !,"diff_match_patch.prototype.patch_make=function(a,b,c){var d;if(""string""==typeof a&&""string""==typeof b&&""undefined""==typeof c)d=a,b=this.diff_main(d,b,!0),2<b.length&&(this.diff_cleanupSemantic(b),this.diff_cleanupEfficiency(b));else if(a&&""object""==typeof a&&""undefined""==typeof b&&""undefined""==typeof c)b=a,d=this.diff_text1(b);else if(""string""==typeof a&&b&&""object""==typeof b&&""undefined""==typeof c)d=a;else if(""string""==typeof a&&""string""==typeof b&&c&&""object""==typeof c)d=a,b=c;else throw Error(""Unknown call format to patch_make."");"
	W !,"if(0===b.length)return[];c=[];a=new diff_match_patch.patch_obj;for(var e=0,f=0,g=0,h=d,j=0;j<b.length;j++){var i=b[j][0],k=b[j][1];!e&&0!==i&&(a.start1=f,a.start2=g);switch(i){case 1:a.diffs[e++]=b[j];a.length2+=k.length;d=d.substring(0,g)+k+d.substring(g);break;case -1:a.length1+=k.length;a.diffs[e++]=b[j];d=d.substring(0,g)+d.substring(g+k.length);break;case 0:k.length<=2*this.Patch_Margin&&e&&b.length!=j+1?(a.diffs[e++]=b[j],a.length1+=k.length,a.length2+=k.length):k.length>=2*this.Patch_Margin&&"
	W !,"e&&(this.patch_addContext_(a,h),c.push(a),a=new diff_match_patch.patch_obj,e=0,h=d,f=g)}1!==i&&(f+=k.length);-1!==i&&(g+=k.length)}e&&(this.patch_addContext_(a,h),c.push(a));return c};diff_match_patch.prototype.patch_deepCopy=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=new diff_match_patch.patch_obj;e.diffs=[];for(var f=0;f<d.diffs.length;f++)e.diffs[f]=d.diffs[f].slice();e.start1=d.start1;e.start2=d.start2;e.length1=d.length1;e.length2=d.length2;b[c]=e}return b};"
	W !,"diff_match_patch.prototype.patch_apply=function(a,b){if(0==a.length)return[b,[]];a=this.patch_deepCopy(a);var c=this.patch_addPadding(a);b=c+b+c;this.patch_splitMax(a);for(var d=0,e=[],f=0;f<a.length;f++){var g=a[f].start2+d,h=this.diff_text1(a[f].diffs),j,i=-1;if(h.length>this.Match_MaxBits){if(j=this.match_main(b,h.substring(0,this.Match_MaxBits),g),-1!=j&&(i=this.match_main(b,h.substring(h.length-this.Match_MaxBits),g+h.length-this.Match_MaxBits),-1==i||j>=i))j=-1}else j=this.match_main(b,h,g);"
	W !,"if(-1==j)e[f]=!1,d-=a[f].length2-a[f].length1;else if(e[f]=!0,d=j-g,g=-1==i?b.substring(j,j+h.length):b.substring(j,i+this.Match_MaxBits),h==g)b=b.substring(0,j)+this.diff_text2(a[f].diffs)+b.substring(j+h.length);else if(g=this.diff_main(h,g,!1),h.length>this.Match_MaxBits&&this.diff_levenshtein(g)/h.length>this.Patch_DeleteThreshold)e[f]=!1;else{this.diff_cleanupSemanticLossless(g);for(var h=0,k,i=0;i<a[f].diffs.length;i++){var q=a[f].diffs[i];0!==q[0]&&(k=this.diff_xIndex(g,h));1===q[0]?b=b.substring(0,"
	W !,"j+k)+q[1]+b.substring(j+k):-1===q[0]&&(b=b.substring(0,j+k)+b.substring(j+this.diff_xIndex(g,h+q[1].length)));-1!==q[0]&&(h+=q[1].length)}}}b=b.substring(c.length,b.length-c.length);return[b,e]};"
	W !,"diff_match_patch.prototype.patch_addPadding=function(a){for(var b=this.Patch_Margin,c="""",d=1;d<=b;d++)c+=String.fromCharCode(d);for(d=0;d<a.length;d++)a[d].start1+=b,a[d].start2+=b;var d=a[0],e=d.diffs;if(0==e.length||0!=e[0][0])e.unshift([0,c]),d.start1-=b,d.start2-=b,d.length1+=b,d.length2+=b;else if(b>e[0][1].length){var f=b-e[0][1].length;e[0][1]=c.substring(e[0][1].length)+e[0][1];d.start1-=f;d.start2-=f;d.length1+=f;d.length2+=f}d=a[a.length-1];e=d.diffs;0==e.length||0!=e[e.length-1][0]?(e.push([0,"
	W !,"c]),d.length1+=b,d.length2+=b):b>e[e.length-1][1].length&&(f=b-e[e.length-1][1].length,e[e.length-1][1]+=c.substring(0,f),d.length1+=f,d.length2+=f);return c};"
	W !,"diff_match_patch.prototype.patch_splitMax=function(a){for(var b=this.Match_MaxBits,c=0;c<a.length;c++)if(!(a[c].length1<=b)){var d=a[c];a.splice(c--,1);for(var e=d.start1,f=d.start2,g="""";0!==d.diffs.length;){var h=new diff_match_patch.patch_obj,j=!0;h.start1=e-g.length;h.start2=f-g.length;""""!==g&&(h.length1=h.length2=g.length,h.diffs.push([0,g]));for(;0!==d.diffs.length&&h.length1<b-this.Patch_Margin;){var g=d.diffs[0][0],i=d.diffs[0][1];1===g?(h.length2+=i.length,f+=i.length,h.diffs.push(d.diffs.shift()),"
	W !,"j=!1):-1===g&&1==h.diffs.length&&0==h.diffs[0][0]&&i.length>2*b?(h.length1+=i.length,e+=i.length,j=!1,h.diffs.push([g,i]),d.diffs.shift()):(i=i.substring(0,b-h.length1-this.Patch_Margin),h.length1+=i.length,e+=i.length,0===g?(h.length2+=i.length,f+=i.length):j=!1,h.diffs.push([g,i]),i==d.diffs[0][1]?d.diffs.shift():d.diffs[0][1]=d.diffs[0][1].substring(i.length))}g=this.diff_text2(h.diffs);g=g.substring(g.length-this.Patch_Margin);i=this.diff_text1(d.diffs).substring(0,this.Patch_Margin);""""!==i&&"
	W !,"(h.length1+=i.length,h.length2+=i.length,0!==h.diffs.length&&0===h.diffs[h.diffs.length-1][0]?h.diffs[h.diffs.length-1][1]+=i:h.diffs.push([0,i]));j||a.splice(++c,0,h)}}};diff_match_patch.prototype.patch_toText=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=a[c];return b.join("""")};"
	W !,"diff_match_patch.prototype.patch_fromText=function(a){var b=[];if(!a)return b;a=a.split(""\n"");for(var c=0,d=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;c<a.length;){var e=a[c].match(d);if(!e)throw Error(""Invalid patch string: ""+a[c]);var f=new diff_match_patch.patch_obj;b.push(f);f.start1=parseInt(e[1],10);""""===e[2]?(f.start1--,f.length1=1):""0""==e[2]?f.length1=0:(f.start1--,f.length1=parseInt(e[2],10));f.start2=parseInt(e[3],10);""""===e[4]?(f.start2--,f.length2=1):""0""==e[4]?f.length2=0:(f.start2--,f.length2="
	W !,"parseInt(e[4],10));for(c++;c<a.length;){e=a[c].charAt(0);try{var g=decodeURI(a[c].substring(1))}catch(h){throw Error(""Illegal escape in patch_fromText: ""+g);}if(""-""==e)f.diffs.push([-1,g]);else if(""+""==e)f.diffs.push([1,g]);else if("" ""==e)f.diffs.push([0,g]);else if(""@""==e)break;else if(""""!==e)throw Error('Invalid patch mode ""'+e+'"" in: '+g);c++}}return b};diff_match_patch.patch_obj=function(){this.diffs=[];this.start2=this.start1=null;this.length2=this.length1=0};"
	W !,"diff_match_patch.patch_obj.prototype.toString=function(){var a,b;a=0===this.length1?this.start1+"",0"":1==this.length1?this.start1+1:this.start1+1+"",""+this.length1;b=0===this.length2?this.start2+"",0"":1==this.length2?this.start2+1:this.start2+1+"",""+this.length2;a=[""@@ -""+a+"" +""+b+"" @@\n""];var c;for(b=0;b<this.diffs.length;b++){switch(this.diffs[b][0]){case 1:c=""+"";break;case -1:c=""-"";break;case 0:c="" ""}a[b+1]=c+encodeURI(this.diffs[b][1])+""\n""}return a.join("""").replace(/%20/g,"" "")};"
	W !,"this.diff_match_patch=diff_match_patch;this.DIFF_DELETE=-1;this.DIFF_INSERT=1;this.DIFF_EQUAL=0;})()",!
	;W !,"</script>"
}

ClassMethod ScriptLibCodemirror()
{
	Do ..ScriptLibCodemirror1()	
	Do ..ScriptLibCodemirror2()
	Do ..ScriptLibCodemirror3()
	Do ..ScriptLibCodemirror4()
	Do ..ScriptLibCodemirror5()
	Do ..ScriptLibCodemirror6()
	Do ..ScriptLibCodemirror7()
	Do ..ScriptLibCodemirror8()
	Do ..ScriptLibCodemirror9()
	Do ..ScriptLibCodemirror10()
	Do ..ScriptLibCodemirror11()
	Do ..ScriptLibCodemirror12()
	Do ..ScriptLibCodemirror13()
	Do ..ScriptLibCodemirror14()
}

ClassMethod ScriptLibCodemirror1()
{
 W !,"// CodeMirror, copyright (c) by Marijn Haverbeke and others"
 W !,"// Distributed under an MIT license: http://codemirror.net/LICENSE",!
 W !,"// This is CodeMirror (http://codemirror.net), a code editor"
 W !,"// implemented in JavaScript on top of the browser's DOM."
 W !,"//"
 W !,"// You can find some technical background for some of the code below"
 W !,"// at http://marijnhaverbeke.nl/blog/#cm-internals .",!
 W !,"(function(mod) {"
 //W !,"  if (typeof exports == ""object"" && typeof module == ""object"") // CommonJS"
 //W !,"    module.exports = mod();"
 //W !,"/  else if (typeof define == ""function"" && define.amd) // AMD"
 //W !,"    return define([], mod);"
 //W !,"  else // Plain browser env"
 W !,"    (this || window).CodeMirror = mod();"
 W !,"})(function() {"
 W !,"  ""use strict"";",!
 W !,"  // BROWSER SNIFFING",!
 W !,"  // Kludges for bugs and behavior differences that can't be feature"
 W !,"  // detected are enabled based on userAgent etc sniffing."
 W !,"  var userAgent = navigator.userAgent;"
 W !,"  var platform = navigator.platform;",!
 W !,"  var gecko = /gecko\/\d/i.test(userAgent);"
 W !,"  var ie_upto10 = /MSIE \d/.test(userAgent);"
 W !,"  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);"
 W !,"  var ie = ie_upto10 || ie_11up;"
 W !,"  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);"
 W !,"  var webkit = /WebKit\//.test(userAgent);"
 W !,"  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);"
 W !,"  var chrome = /Chrome\//.test(userAgent);"
 W !,"  var presto = /Opera\//.test(userAgent);"
 W !,"  var safari = /Apple Computer/.test(navigator.vendor);"
 W !,"  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);"
 W !,"  var phantom = /PhantomJS/.test(userAgent);",!
 W !,"  var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);"
 W !,"  // This is woefully incomplete. Suggestions for alternative methods welcome."
 W !,"  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);"
 W !,"  var mac = ios || /Mac/.test(platform);"
 W !,"  var chromeOS = /\bCrOS\b/.test(userAgent);"
 W !,"  var windows = /win/i.test(platform);",!
 W !,"  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);"
 W !,"  if (presto_version) presto_version = Number(presto_version[1]);"
 W !,"  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }"
 W !,"  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X"
 W !,"  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));"
 W !,"  var captureRightClick = gecko || (ie && ie_version >= 9);",!
 W !,"  // Optimize some code when these features are not used."
 W !,"  var sawReadOnlySpans = false, sawCollapsedSpans = false;",!
 W !,"  // EDITOR CONSTRUCTOR",!
 W !,"  // A CodeMirror instance represents an editor. This is the object"
 W !,"  // that user code is usually dealing with.",!
 W !,"  function CodeMirror(place, options) {"
 W !,"    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);",!
 W !,"    this.options = options = options ? copyObj(options) : {};"
 W !,"    // Determine effective options based on given values and defaults."
 W !,"    copyObj(defaults, options, false);"
 W !,"    setGuttersForLineNumbers(options);",!
 W !,"    var doc = options.value;"
 W !,"    if (typeof doc == ""string"") doc = new Doc(doc, options.mode, null, options.lineSeparator);"
 W !,"    this.doc = doc;",!
 W !,"    var input = new CodeMirror.inputStyles[options.inputStyle](this);"
 W !,"    var display = this.display = new Display(place, doc, input);"
 W !,"    display.wrapper.CodeMirror = this;"
 W !,"    updateGutters(this);"
 W !,"    themeChanged(this);"
 W !,"    if (options.lineWrapping)"
 W !,"      this.display.wrapper.className += "" CodeMirror-wrap"";"
 W !,"    if (options.autofocus && !mobile) display.input.focus();"
 W !,"    initScrollbars(this);",!
 W !,"    this.state = {"
 W !,"      keyMaps: [],  // stores maps added by addKeyMap"
 W !,"      overlays: [], // highlighting overlays, as added by addOverlay"
 W !,"      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info"
 W !,"      overwrite: false,"
 W !,"      delayingBlurEvent: false,"
 W !,"      focused: false,"
 W !,"      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode"
 W !,"      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll"
 W !,"      selectingText: false,"
 W !,"      draggingText: false,"
 W !,"      highlight: new Delayed(), // stores highlight worker timeout"
 W !,"      keySeq: null,  // Unfinished key sequence"
 W !,"      specialChars: null"
 W !,"    };",!
 W !,"    var cm = this;",!
 W !,"    // Override magic textarea content restore that IE sometimes does"
 W !,"    // on our hidden textarea on reload"
 W !,"    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);",!
 W !,"    registerEventHandlers(this);"
 W !,"    ensureGlobalHandlers();",!
 W !,"    startOperation(this);"
 W !,"    this.curOp.forceUpdate = true;"
 W !,"    attachDoc(this, doc);",!
 W !,"    if ((options.autofocus && !mobile) || cm.hasFocus())"
 W !,"      setTimeout(bind(onFocus, this), 20);"
 W !,"    else"
 W !,"      onBlur(this);",!
 W !,"    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))"
 W !,"      optionHandlers[opt](this, options[opt], Init);"
 W !,"    maybeUpdateLineNumberWidth(this);"
 W !,"    if (options.finishInit) options.finishInit(this);"
 W !,"    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);"
 W !,"    endOperation(this);"
 W !,"    // Suppress optimizelegibility in Webkit, since it breaks text"
 W !,"    // measuring on line wrapping boundaries."
 W !,"    if (webkit && options.lineWrapping &&"
 W !,"        getComputedStyle(display.lineDiv).textRendering == ""optimizelegibility"")"
 W !,"      display.lineDiv.style.textRendering = ""auto"";"
 W !,"  }",!
 W !,"  // DISPLAY CONSTRUCTOR",!
 W !,"  // The display handles the DOM integration, both for input reading"
 W !,"  // and content drawing. It holds references to DOM nodes and"
 W !,"  // display-related state.",!
 W !,"  function Display(place, doc, input) {"
 W !,"    var d = this;"
 W !,"    this.input = input;",!
 W !,"    // Covers bottom-right square when both scrollbars are present."
 W !,"    d.scrollbarFiller = elt(""div"", null, ""CodeMirror-scrollbar-filler"");"
 W !,"    d.scrollbarFiller.setAttribute(""cm-not-content"", ""true"");"
 W !,"    // Covers bottom of gutter when coverGutterNextToScrollbar is on"
 W !,"    // and h scrollbar is present."
 W !,"    d.gutterFiller = elt(""div"", null, ""CodeMirror-gutter-filler"");"
 W !,"    d.gutterFiller.setAttribute(""cm-not-content"", ""true"");"
 W !,"    // Will contain the actual code, positioned to cover the viewport."
 W !,"    d.lineDiv = elt(""div"", null, ""CodeMirror-code"");"
 W !,"    // Elements are added to these to represent selection and cursors."
 W !,"    d.selectionDiv = elt(""div"", null, null, ""position: relative; z-index: 1"");"
 W !,"    d.cursorDiv = elt(""div"", null, ""CodeMirror-cursors"");"
 W !,"    // A visibility: hidden element used to find the size of things."
 W !,"    d.measure = elt(""div"", null, ""CodeMirror-measure"");"
 W !,"    // When lines outside of the viewport are measured, they are drawn in this."
 W !,"    d.lineMeasure = elt(""div"", null, ""CodeMirror-measure"");"
 W !,"    // Wraps everything that needs to exist inside the vertically-padded coordinate system"
 W !,"    d.lineSpace = elt(""div"", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],"
 W !,"                      null, ""position: relative; outline: none"");"
 W !,"    // Moved around its parent to cover visible view."
 W !,"    d.mover = elt(""div"", [elt(""div"", [d.lineSpace], ""CodeMirror-lines"")], null, ""position: relative"");"
 W !,"    // Set to the height of the document, allowing scrolling."
 W !,"    d.sizer = elt(""div"", [d.mover], ""CodeMirror-sizer"");"
 W !,"    d.sizerWidth = null;"
 W !,"    // Behavior of elts with overflow: auto and padding is"
 W !,"    // inconsistent across browsers. This is used to ensure the"
 W !,"    // scrollable area is big enough."
 W !,"    d.heightForcer = elt(""div"", null, null, ""position: absolute; height: "" + scrollerGap + ""px; width: 1px;"");"
 W !,"    // Will contain the gutters, if any."
 W !,"    d.gutters = elt(""div"", null, ""CodeMirror-gutters"");"
 W !,"    d.lineGutter = null;"
 W !,"    // Actual scrollable element."
 W !,"    d.scroller = elt(""div"", [d.sizer, d.heightForcer, d.gutters], ""CodeMirror-scroll"");"
 W !,"    d.scroller.setAttribute(""tabIndex"", ""-1"");"
 W !,"    // The element in which the editor lives."
 W !,"    d.wrapper = elt(""div"", [d.scrollbarFiller, d.gutterFiller, d.scroller], ""CodeMirror"");",!
 W !,"    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)"
 W !,"    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }"
 W !,"    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;",!
 W !,"    if (place) {"
 W !,"      if (place.appendChild) place.appendChild(d.wrapper);"
 W !,"      else place(d.wrapper);"
 W !,"    }",!
 W !,"    // Current rendered range (may be bigger than the view window)."
 W !,"    d.viewFrom = d.viewTo = doc.first;"
 W !,"    d.reportedViewFrom = d.reportedViewTo = doc.first;"
 W !,"    // Information about the rendered lines."
 W !,"    d.view = [];"
 W !,"    d.renderedView = null;"
 W !,"    // Holds info about a single rendered line when it was rendered"
 W !,"    // for measurement, while not in view."
 W !,"    d.externalMeasured = null;"
 W !,"    // Empty space (in pixels) above the view"
 W !,"    d.viewOffset = 0;"
 W !,"    d.lastWrapHeight = d.lastWrapWidth = 0;"
 W !,"    d.updateLineNumbers = null;",!
 W !,"    d.nativeBarWidth = d.barHeight = d.barWidth = 0;"
 W !,"    d.scrollbarsClipped = false;",!
 W !,"    // Used to only resize the line number gutter when necessary (when"
 W !,"    // the amount of lines crosses a boundary that makes its width change)"
 W !,"    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;"
 W !,"    // Set to true when a non-horizontal-scrolling line widget is"
 W !,"    // added. As an optimization, line widget aligning is skipped when"
 W !,"    // this is false."
 W !,"    d.alignWidgets = false;",!
 W !,"    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;",!
 W !,"    // Tracks the maximum line length so that the horizontal scrollbar"
 W !,"    // can be kept static when scrolling."
 W !,"    d.maxLine = null;"
 W !,"    d.maxLineLength = 0;"
 W !,"    d.maxLineChanged = false;",!
 W !,"    // Used for measuring wheel scrolling granularity"
 W !,"    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;",!
 W !,"    // True when shift is held down."
 W !,"    d.shift = false;",!
 W !,"    // Used to track whether anything happened since the context menu"
 W !,"    // was opened."
 W !,"    d.selForContextMenu = null;",!
 W !,"    d.activeTouch = null;",!
 W !,"    input.init(d);"
 W !,"  }",!
 W !,"  // STATE UPDATES",!
 W !,"  // Used to get the editor into a consistent state again when options change.",!
 W !,"  function loadMode(cm) {"
 W !,"    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);"
 W !,"    resetModeState(cm);"
 W !,"  }",!
 W !,"  function resetModeState(cm) {"
 W !,"    cm.doc.iter(function(line) {"
 W !,"      if (line.stateAfter) line.stateAfter = null;"
 W !,"      if (line.styles) line.styles = null;"
 W !,"    });"
 W !,"    cm.doc.frontier = cm.doc.first;"
 W !,"    startWorker(cm, 100);"
 W !,"    cm.state.modeGen++;"
 W !,"    if (cm.curOp) regChange(cm);"
 W !,"  }",!
 W !,"  function wrappingChanged(cm) {"
 W !,"    if (cm.options.lineWrapping) {"
 W !,"      addClass(cm.display.wrapper, ""CodeMirror-wrap"");"
 W !,"      cm.display.sizer.style.minWidth = """";"
 W !,"      cm.display.sizerWidth = null;"
 W !,"    } else {"
 W !,"      rmClass(cm.display.wrapper, ""CodeMirror-wrap"");"
 W !,"      findMaxLine(cm);"
 W !,"    }"
 W !,"    estimateLineHeights(cm);"
 W !,"    regChange(cm);"
 W !,"    clearCaches(cm);"
 W !,"    setTimeout(function(){updateScrollbars(cm);}, 100);"
 W !,"  }",!
 W !,"  // Returns a function that estimates the height of a line, to use as"
 W !,"  // first approximation until the line becomes visible (and is thus"
 W !,"  // properly measurable)."
 W !,"  function estimateHeight(cm) {"
 W !,"    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;"
 W !,"    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);"
 W !,"    return function(line) {"
 W !,"      if (lineIsHidden(cm.doc, line)) return 0;",!
 W !,"      var widgetsHeight = 0;"
 W !,"      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {"
 W !,"        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;"
 W !,"      }",!
 W !,"      if (wrapping)"
 W !,"        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;"
 W !,"      else"
 W !,"        return widgetsHeight + th;"
 W !,"    };"
 W !,"  }",!
 W !,"  function estimateLineHeights(cm) {"
 W !,"    var doc = cm.doc, est = estimateHeight(cm);"
 W !,"    doc.iter(function(line) {"
 W !,"      var estHeight = est(line);"
 W !,"      if (estHeight != line.height) updateLineHeight(line, estHeight);"
 W !,"    });"
 W !,"  }",!
 W !,"  function themeChanged(cm) {"
 W !,"    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, """") +"
 W !,"      cm.options.theme.replace(/(^|\s)\s*/g, "" cm-s-"");"
 W !,"    clearCaches(cm);"
 W !,"  }",!
 W !,"  function guttersChanged(cm) {"
 W !,"    updateGutters(cm);"
 W !,"    regChange(cm);"
 W !,"    setTimeout(function(){alignHorizontally(cm);}, 20);"
 W !,"  }",!
 W !,"  // Rebuild the gutter elements, ensure the margin to the left of the"
 W !,"  // code matches their width."
 W !,"  function updateGutters(cm) {"
 W !,"    var gutters = cm.display.gutters, specs = cm.options.gutters;"
 W !,"    removeChildren(gutters);"
 W !,"    for (var i = 0; i < specs.length; ++i) {"
 W !,"      var gutterClass = specs[i];"
 W !,"      var gElt = gutters.appendChild(elt(""div"", null, ""CodeMirror-gutter "" + gutterClass));"
 W !,"      if (gutterClass == ""CodeMirror-linenumbers"") {"
 W !,"        cm.display.lineGutter = gElt;"
 W !,"        gElt.style.width = (cm.display.lineNumWidth || 1) + ""px"";"
 W !,"      }"
 W !,"    }"
 W !,"    gutters.style.display = i ? """" : ""none"";"
 W !,"    updateGutterSpace(cm);"
 W !,"  }",!
 W !,"  function updateGutterSpace(cm) {"
 W !,"    var width = cm.display.gutters.offsetWidth;"
 W !,"    cm.display.sizer.style.marginLeft = width + ""px"";"
 W !,"  }",!
 W !,"  // Compute the character length of a line, taking into account"
 W !,"  // collapsed ranges (see markText) that might hide parts, and join"
 W !,"  // other lines onto it."
 W !,"  function lineLength(line) {"
 W !,"    if (line.height == 0) return 0;"
 W !,"    var len = line.text.length, merged, cur = line;"
 W !,"    while (merged = collapsedSpanAtStart(cur)) {"
 W !,"      var found = merged.find(0, true);"
 W !,"      cur = found.from.line;"
 W !,"      len += found.from.ch - found.to.ch;"
 W !,"    }"
 W !,"    cur = line;"
 W !,"    while (merged = collapsedSpanAtEnd(cur)) {"
 W !,"      var found = merged.find(0, true);"
 W !,"      len -= cur.text.length - found.from.ch;"
 W !,"      cur = found.to.line;"
 W !,"      len += cur.text.length - found.to.ch;"
 W !,"    }"
 W !,"    return len;"
 W !,"  }",!
 W !,"  // Find the longest line in the document."
 W !,"  function findMaxLine(cm) {"
 W !,"    var d = cm.display, doc = cm.doc;"
 W !,"    d.maxLine = getLine(doc, doc.first);"
 W !,"    d.maxLineLength = lineLength(d.maxLine);"
 W !,"    d.maxLineChanged = true;"
 W !,"    doc.iter(function(line) {"
 W !,"      var len = lineLength(line);"
 W !,"      if (len > d.maxLineLength) {"
 W !,"        d.maxLineLength = len;"
 W !,"        d.maxLine = line;"
 W !,"      }"
 W !,"    });"
 W !,"  }",!
 W !,"  // Make sure the gutters options contains the element"
 W !,"  // ""CodeMirror-linenumbers"" when the lineNumbers option is true."
 W !,"  function setGuttersForLineNumbers(options) {"
 W !,"    var found = indexOf(options.gutters, ""CodeMirror-linenumbers"");"
 W !,"    if (found == -1 && options.lineNumbers) {"
 W !,"      options.gutters = options.gutters.concat([""CodeMirror-linenumbers""]);"
 W !,"    } else if (found > -1 && !options.lineNumbers) {"
 W !,"      options.gutters = options.gutters.slice(0);"
 W !,"      options.gutters.splice(found, 1);"
 W !,"    }"
 W !,"  }",!
 W !,"  // SCROLLBARS",!
 W !,"  // Prepare DOM reads needed to update the scrollbars. Done in one"
 W !,"  // shot to minimize update/measure roundtrips."
 W !,"  function measureForScrollbars(cm) {"
 W !,"    var d = cm.display, gutterW = d.gutters.offsetWidth;"
 W !,"    var docH = Math.round(cm.doc.height + paddingVert(cm.display));"
 W !,"    return {"
 W !,"      clientHeight: d.scroller.clientHeight,"
 W !,"      viewHeight: d.wrapper.clientHeight,"
 W !,"      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,"
 W !,"      viewWidth: d.wrapper.clientWidth,"
 W !,"      barLeft: cm.options.fixedGutter ? gutterW : 0,"
 W !,"      docHeight: docH,"
 W !,"      scrollHeight: docH + scrollGap(cm) + d.barHeight,"
 W !,"      nativeBarWidth: d.nativeBarWidth,"
 W !,"      gutterWidth: gutterW"
 W !,"    };"
 W !,"  }",!
 W !,"  function NativeScrollbars(place, scroll, cm) {"
 W !,"    this.cm = cm;"
 W !,"    var vert = this.vert = elt(""div"", [elt(""div"", null, null, ""min-width: 1px"")], ""CodeMirror-vscrollbar"");"
 W !,"    var horiz = this.horiz = elt(""div"", [elt(""div"", null, null, ""height: 100%; min-height: 1px"")], ""CodeMirror-hscrollbar"");"
 W !,"    place(vert); place(horiz);",!
 W !,"    on(vert, ""scroll"", function() {"
 W !,"      if (vert.clientHeight) scroll(vert.scrollTop, ""vertical"");"
 W !,"    });"
 W !,"    on(horiz, ""scroll"", function() {"
 W !,"      if (horiz.clientWidth) scroll(horiz.scrollLeft, ""horizontal"");"
 W !,"    });",!
 W !,"    this.checkedZeroWidth = false;"
 W !,"    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8)."
 W !,"    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = ""18px"";"
 W !,"  }",!
 W !,"  NativeScrollbars.prototype = copyObj({"
 W !,"    update: function(measure) {"
 W !,"      var needsH = measure.scrollWidth > measure.clientWidth + 1;"
 W !,"      var needsV = measure.scrollHeight > measure.clientHeight + 1;"
 W !,"      var sWidth = measure.nativeBarWidth;",!
 W !,"      if (needsV) {"
 W !,"        this.vert.style.display = ""block"";"
 W !,"        this.vert.style.bottom = needsH ? sWidth + ""px"" : ""0"";"
 W !,"        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);"
 W !,"        // A bug in IE8 can cause this value to be negative, so guard it."
 W !,"        this.vert.firstChild.style.height ="
 W !,"          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + ""px"";"
 W !,"      } else {"
 W !,"        this.vert.style.display = """";"
 W !,"        this.vert.firstChild.style.height = ""0"";"
 W !,"      }",!
 W !,"      if (needsH) {"
 W !,"        this.horiz.style.display = ""block"";"
 W !,"        this.horiz.style.right = needsV ? sWidth + ""px"" : ""0"";"
 W !,"        this.horiz.style.left = measure.barLeft + ""px"";"
 W !,"        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);"
 W !,"        this.horiz.firstChild.style.width ="
 W !,"          (measure.scrollWidth - measure.clientWidth + totalWidth) + ""px"";"
 W !,"      } else {"
 W !,"        this.horiz.style.display = """";"
 W !,"        this.horiz.firstChild.style.width = ""0"";"
 W !,"      }",!
 W !,"      if (!this.checkedZeroWidth && measure.clientHeight > 0) {"
 W !,"        if (sWidth == 0) this.zeroWidthHack();"
 W !,"        this.checkedZeroWidth = true;"
 W !,"      }",!
 W !,"      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};"
 W !,"    },"
 W !,"    setScrollLeft: function(pos) {"
 W !,"      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;"
 W !,"      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);"
 W !,"    },"
 W !,"    setScrollTop: function(pos) {"
 W !,"      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;"
 W !,"      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);"
 W !,"    },"
 W !,"    zeroWidthHack: function() {"
 W !,"      var w = mac && !mac_geMountainLion ? ""12px"" : ""18px"";"
 W !,"      this.horiz.style.height = this.vert.style.width = w;"
 W !,"      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = ""none"";"
 W !,"      this.disableHoriz = new Delayed;"
 W !,"      this.disableVert = new Delayed;"
 W !,"    },"
 W !,"    enableZeroWidthBar: function(bar, delay) {"
 W !,"      bar.style.pointerEvents = ""auto"";"
 W !,"      function maybeDisable() {"
 W !,"        // To find out whether the scrollbar is still visible, we"
 W !,"        // check whether the element under the pixel in the bottom"
 W !,"        // left corner of the scrollbar box is the scrollbar box"
 W !,"        // itself (when the bar is still visible) or its filler child"
 W !,"        // (when the bar is hidden). If it is still visible, we keep"
 W !,"        // it enabled, if it's hidden, we disable pointer events."
 W !,"        var box = bar.getBoundingClientRect();"
 W !,"        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);"
 W !,"        if (elt != bar) bar.style.pointerEvents = ""none"";"
 W !,"        else delay.set(1000, maybeDisable);"
 W !,"      }"
 W !,"      delay.set(1000, maybeDisable);"
 W !,"    },"
 W !,"    clear: function() {"
 W !,"      var parent = this.horiz.parentNode;"
 W !,"      parent.removeChild(this.horiz);"
 W !,"      parent.removeChild(this.vert);"
 W !,"    }"
 W !,"  }, NativeScrollbars.prototype);",!
 W !,"  function NullScrollbars() {}",!
 W !,"  NullScrollbars.prototype = copyObj({"
 W !,"    update: function() { return {bottom: 0, right: 0}; },"
 W !,"    setScrollLeft: function() {},"
 W !,"    setScrollTop: function() {},"
 W !,"    clear: function() {}"
 W !,"  }, NullScrollbars.prototype);",!
 W !,"  CodeMirror.scrollbarModel = {""native"": NativeScrollbars, ""null"": NullScrollbars};",!
 W !,"  function initScrollbars(cm) {"
 W !,"    if (cm.display.scrollbars) {"
 W !,"      cm.display.scrollbars.clear();"
 W !,"      if (cm.display.scrollbars.addClass)"
 W !,"        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);"
 W !,"    }",!
 W !,"    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {"
 W !,"      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);"
 W !,"      // Prevent clicks in the scrollbars from killing focus"
 W !,"      on(node, ""mousedown"", function() {"
 W !,"        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);"
 W !,"      });"
 W !,"      node.setAttribute(""cm-not-content"", ""true"");"
 W !,"    }, function(pos, axis) {"
 W !,"      if (axis == ""horizontal"") setScrollLeft(cm, pos);"
 W !,"      else setScrollTop(cm, pos);"
 W !,"    }, cm);"
 W !,"    if (cm.display.scrollbars.addClass)"
 W !,"      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);"
 W !,"  }",!
 W !,"  function updateScrollbars(cm, measure) {"
 W !,"    if (!measure) measure = measureForScrollbars(cm);"
 W !,"    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;"
 W !,"    updateScrollbarsInner(cm, measure);"
 W !,"    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {"
 W !,"      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)"
 W !,"        updateHeightsInViewport(cm);"
 W !,"      updateScrollbarsInner(cm, measureForScrollbars(cm));"
 W !,"      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;"
 W !,"    }"
 W !,"  }",!
 W !,"  // Re-synchronize the fake scrollbars with the actual size of the"
 W !,"  // content."
 W !,"  function updateScrollbarsInner(cm, measure) {"
 W !,"    var d = cm.display;"
 W !,"    var sizes = d.scrollbars.update(measure);",!
 W !,"    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + ""px"";"
 W !,"    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + ""px"";"
 W !,"    d.heightForcer.style.borderBottom = sizes.bottom + ""px solid transparent""",!
 W !,"    if (sizes.right && sizes.bottom) {"
 W !,"      d.scrollbarFiller.style.display = ""block"";"
 W !,"      d.scrollbarFiller.style.height = sizes.bottom + ""px"";"
 W !,"      d.scrollbarFiller.style.width = sizes.right + ""px"";"
 W !,"    } else d.scrollbarFiller.style.display = """";"
 W !,"    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {"
 W !,"      d.gutterFiller.style.display = ""block"";"
 W !,"      d.gutterFiller.style.height = sizes.bottom + ""px"";"
 W !,"      d.gutterFiller.style.width = measure.gutterWidth + ""px"";"
 W !,"    } else d.gutterFiller.style.display = """";"
 W !,"  }",!
 W !,"  // Compute the lines that are visible in a given viewport (defaults"
 W !,"  // the the current scroll position). viewport may contain top,"
 W !,"  // height, and ensure (see op.scrollToPos) properties."
 W !,"  function visibleLines(display, doc, viewport) {"
 W !,"    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;"
 W !,"    top = Math.floor(top - paddingTop(display));"
 W !,"    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;",!
 W !,"    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);"
 W !,"    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and"
 W !,"    // forces those lines into the viewport (if possible)."
 W !,"    if (viewport && viewport.ensure) {"
 W !,"      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;"
 W !,"      if (ensureFrom < from) {"
 W !,"        from = ensureFrom;"
 W !,"        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);"
 W !,"      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {"
 W !,"        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);"
 W !,"        to = ensureTo;"
 W !,"      }"
 W !,"    }"
 W !,"    return {from: from, to: Math.max(to, from + 1)};"
 W !,"  }",!
 W !,"  // LINE NUMBERS",!
 W !,"  // Re-align line numbers and gutter marks to compensate for"
 W !,"  // horizontal scrolling."
 W !,"  function alignHorizontally(cm) {"
 W !,"    var display = cm.display, view = display.view;"
 W !,"    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;"
 W !,"    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;"
 W !,"    var gutterW = display.gutters.offsetWidth, left = comp + ""px"";"
 W !,"    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {"
 W !,"      if (cm.options.fixedGutter && view[i].gutter)"
 W !,"        view[i].gutter.style.left = left;"
 W !,"      var align = view[i].alignable;"
 W !,"      if (align) for (var j = 0; j < align.length; j++)"
 W !,"        align[j].style.left = left;"
 W !,"    }"
 W !,"    if (cm.options.fixedGutter)"
 W !,"      display.gutters.style.left = (comp + gutterW) + ""px"";"
 W !,"  }",!
 W !,"  // Used to ensure that the line number gutter is still the right"
 W !,"  // size for the current document size. Returns true when an update"
 W !,"  // is needed."
 W !,"  function maybeUpdateLineNumberWidth(cm) {"
 W !,"    if (!cm.options.lineNumbers) return false;"
 W !,"    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;"
 W !,"    if (last.length != display.lineNumChars) {"
 W !,"      var test = display.measure.appendChild(elt(""div"", [elt(""div"", last)],"
 W !,"                                                 ""CodeMirror-linenumber CodeMirror-gutter-elt""));"
 W !,"      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;"
 W !,"      display.lineGutter.style.width = """";"
 W !,"      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;"
 W !,"      display.lineNumWidth = display.lineNumInnerWidth + padding;"
 W !,"      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;"
 W !,"      display.lineGutter.style.width = display.lineNumWidth + ""px"";"
 W !,"      updateGutterSpace(cm);"
 W !,"      return true;"
 W !,"    }"
 W !,"    return false;"
 W !,"  }",!
 W !,"  function lineNumberFor(options, i) {"
 W !,"    return String(options.lineNumberFormatter(i + options.firstLineNumber));"
 W !,"  }",!
 W !,"  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,"
 W !,"  // but using getBoundingClientRect to get a sub-pixel-accurate"
 W !,"  // result."
 W !,"  function compensateForHScroll(display) {"
 W !,"    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;"
 W !,"  }",!
 W !,"  // DISPLAY DRAWING",!
 W !,"  function DisplayUpdate(cm, viewport, force) {"
 W !,"    var display = cm.display;",!
 W !,"    this.viewport = viewport;"
 W !,"    // Store some values that we'll need later (but don't want to force a relayout for)"
 W !,"    this.visible = visibleLines(display, cm.doc, viewport);"
 W !,"    this.editorIsHidden = !display.wrapper.offsetWidth;"
 W !,"    this.wrapperHeight = display.wrapper.clientHeight;"
 W !,"    this.wrapperWidth = display.wrapper.clientWidth;"
 W !,"    this.oldDisplayWidth = displayWidth(cm);"
 W !,"    this.force = force;"
 W !,"    this.dims = getDimensions(cm);"
 W !,"    this.events = [];"
 W !,"  }",!
 W !,"  DisplayUpdate.prototype.signal = function(emitter, type) {"
 W !,"    if (hasHandler(emitter, type))"
 W !,"      this.events.push(arguments);"
 W !,"  };"
 W !,"  DisplayUpdate.prototype.finish = function() {"
 W !,"    for (var i = 0; i < this.events.length; i++)"
 W !,"      signal.apply(null, this.events[i]);"
 W !,"  };",!
}

ClassMethod ScriptLibCodemirror2()
{
 W !,"  function maybeClipScrollbars(cm) {"
 W !,"    var display = cm.display;"
 W !,"    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {"
 W !,"      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;"
 W !,"      display.heightForcer.style.height = scrollGap(cm) + ""px"";"
 W !,"      display.sizer.style.marginBottom = -display.nativeBarWidth + ""px"";"
 W !,"      display.sizer.style.borderRightWidth = scrollGap(cm) + ""px"";"
 W !,"      display.scrollbarsClipped = true;"
 W !,"    }"
 W !,"  }",!
 W !,"  // Does the actual updating of the line display. Bails out"
 W !,"  // (returning false) when there is nothing to be done and forced is"
 W !,"  // false."
 W !,"  function updateDisplayIfNeeded(cm, update) {"
 W !,"    var display = cm.display, doc = cm.doc;",!
 W !,"    if (update.editorIsHidden) {"
 W !,"      resetView(cm);"
 W !,"      return false;"
 W !,"    }",!
 W !,"    // Bail out if the visible area is already rendered and nothing changed."
 W !,"    if (!update.force &&"
 W !,"        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&"
 W !,"        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&"
 W !,"        display.renderedView == display.view && countDirtyView(cm) == 0)"
 W !,"      return false;",!
 W !,"    if (maybeUpdateLineNumberWidth(cm)) {"
 W !,"      resetView(cm);"
 W !,"      update.dims = getDimensions(cm);"
 W !,"    }",!
 W !,"    // Compute a suitable new viewport (from & to)"
 W !,"    var end = doc.first + doc.size;"
 W !,"    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);"
 W !,"    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);"
 W !,"    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);"
 W !,"    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);"
 W !,"    if (sawCollapsedSpans) {"
 W !,"      from = visualLineNo(cm.doc, from);"
 W !,"      to = visualLineEndNo(cm.doc, to);"
 W !,"    }",!
 W !,"    var different = from != display.viewFrom || to != display.viewTo ||"
 W !,"      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;"
 W !,"    adjustView(cm, from, to);",!
 W !,"    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));"
 W !,"    // Position the mover div to align with the current scroll position"
 W !,"    cm.display.mover.style.top = display.viewOffset + ""px"";",!
 W !,"    var toUpdate = countDirtyView(cm);"
 W !,"    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&"
 W !,"        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))"
 W !,"      return false;",!
 W !,"    // For big changes, we hide the enclosing element during the"
 W !,"    // update, since that speeds up the operations on most browsers."
 W !,"    var focused = activeElt();"
 W !,"    if (toUpdate > 4) display.lineDiv.style.display = ""none"";"
 W !,"    patchDisplay(cm, display.updateLineNumbers, update.dims);"
 W !,"    if (toUpdate > 4) display.lineDiv.style.display = """";"
 W !,"    display.renderedView = display.view;"
 W !,"    // There might have been a widget with a focused element that got"
 W !,"    // hidden or updated, if so re-focus it."
 W !,"    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();",!
 W !,"    // Prevent selection and cursors from interfering with the scroll"
 W !,"    // width and height."
 W !,"    removeChildren(display.cursorDiv);"
 W !,"    removeChildren(display.selectionDiv);"
 W !,"    display.gutters.style.height = display.sizer.style.minHeight = 0;",!
 W !,"    if (different) {"
 W !,"      display.lastWrapHeight = update.wrapperHeight;"
 W !,"      display.lastWrapWidth = update.wrapperWidth;"
 W !,"      startWorker(cm, 400);"
 W !,"    }",!
 W !,"    display.updateLineNumbers = null;",!
 W !,"    return true;"
 W !,"  }",!
 W !,"  function postUpdateDisplay(cm, update) {"
 W !,"    var viewport = update.viewport;",!
 W !,"    for (var first = true;; first = false) {"
 W !,"      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {"
 W !,"        // Clip forced viewport to actual scrollable area."
 W !,"        if (viewport && viewport.top != null)"
 W !,"          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};"
 W !,"        // Updated line heights might result in the drawn area not"
 W !,"        // actually covering the viewport. Keep looping until it does."
 W !,"        update.visible = visibleLines(cm.display, cm.doc, viewport);"
 W !,"        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)"
 W !,"          break;"
 W !,"      }"
 W !,"      if (!updateDisplayIfNeeded(cm, update)) break;"
 W !,"      updateHeightsInViewport(cm);"
 W !,"      var barMeasure = measureForScrollbars(cm);"
 W !,"      updateSelection(cm);"
 W !,"      updateScrollbars(cm, barMeasure);"
 W !,"      setDocumentHeight(cm, barMeasure);"
 W !,"    }",!
 W !,"    update.signal(cm, ""update"", cm);"
 W !,"    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {"
 W !,"      update.signal(cm, ""viewportChange"", cm, cm.display.viewFrom, cm.display.viewTo);"
 W !,"      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;"
 W !,"    }"
 W !,"  }",!
 W !,"  function updateDisplaySimple(cm, viewport) {"
 W !,"    var update = new DisplayUpdate(cm, viewport);"
 W !,"    if (updateDisplayIfNeeded(cm, update)) {"
 W !,"      updateHeightsInViewport(cm);"
 W !,"      postUpdateDisplay(cm, update);"
 W !,"      var barMeasure = measureForScrollbars(cm);"
 W !,"      updateSelection(cm);"
 W !,"      updateScrollbars(cm, barMeasure);"
 W !,"      setDocumentHeight(cm, barMeasure);"
 W !,"      update.finish();"
 W !,"    }"
 W !,"  }",!
 W !,"  function setDocumentHeight(cm, measure) {"
 W !,"    cm.display.sizer.style.minHeight = measure.docHeight + ""px"";"
 W !,"    cm.display.heightForcer.style.top = measure.docHeight + ""px"";"
 W !,"    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + ""px"";"
 W !,"  }",!
 W !,"  // Read the actual heights of the rendered lines, and update their"
 W !,"  // stored heights to match."
 W !,"  function updateHeightsInViewport(cm) {"
 W !,"    var display = cm.display;"
 W !,"    var prevBottom = display.lineDiv.offsetTop;"
 W !,"    for (var i = 0; i < display.view.length; i++) {"
 W !,"      var cur = display.view[i], height;"
 W !,"      if (cur.hidden) continue;"
 W !,"      if (ie && ie_version < 8) {"
 W !,"        var bot = cur.node.offsetTop + cur.node.offsetHeight;"
 W !,"        height = bot - prevBottom;"
 W !,"        prevBottom = bot;"
 W !,"      } else {"
 W !,"        var box = cur.node.getBoundingClientRect();"
 W !,"        height = box.bottom - box.top;"
 W !,"      }"
 W !,"      var diff = cur.line.height - height;"
 W !,"      if (height < 2) height = textHeight(display);"
 W !,"      if (diff > .001 || diff < -.001) {"
 W !,"        updateLineHeight(cur.line, height);"
 W !,"        updateWidgetHeight(cur.line);"
 W !,"        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)"
 W !,"          updateWidgetHeight(cur.rest[j]);"
 W !,"      }"
 W !,"    }"
 W !,"  }",!
 W !,"  // Read and store the height of line widgets associated with the"
 W !,"  // given line."
 W !,"  function updateWidgetHeight(line) {"
 W !,"    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)"
 W !,"      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;"
 W !,"  }",!
 W !,"  // Do a bulk-read of the DOM positions and sizes needed to draw the"
 W !,"  // view, so that we don't interleave reading and writing to the DOM."
 W !,"  function getDimensions(cm) {"
 W !,"    var d = cm.display, left = {}, width = {};"
 W !,"    var gutterLeft = d.gutters.clientLeft;"
 W !,"    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {"
 W !,"      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;"
 W !,"      width[cm.options.gutters[i]] = n.clientWidth;"
 W !,"    }"
 W !,"    return {fixedPos: compensateForHScroll(d),"
 W !,"            gutterTotalWidth: d.gutters.offsetWidth,"
 W !,"            gutterLeft: left,"
 W !,"            gutterWidth: width,"
 W !,"            wrapperWidth: d.wrapper.clientWidth};"
 W !,"  }",!
 W !,"  // Sync the actual display DOM structure with display.view, removing"
 W !,"  // nodes for lines that are no longer in view, and creating the ones"
 W !,"  // that are not there yet, and updating the ones that are out of"
 W !,"  // date."
 W !,"  function patchDisplay(cm, updateNumbersFrom, dims) {"
 W !,"    var display = cm.display, lineNumbers = cm.options.lineNumbers;"
 W !,"    var container = display.lineDiv, cur = container.firstChild;",!
 W !,"    function rm(node) {"
 W !,"      var next = node.nextSibling;"
 W !,"      // Works around a throw-scroll bug in OS X Webkit"
 W !,"      if (webkit && mac && cm.display.currentWheelTarget == node)"
 W !,"        node.style.display = ""none"";"
 W !,"      else"
 W !,"        node.parentNode.removeChild(node);"
 W !,"      return next;"
 W !,"    }",!
 W !,"    var view = display.view, lineN = display.viewFrom;"
 W !,"    // Loop over the elements in the view, syncing cur (the DOM nodes"
 W !,"    // in display.lineDiv) with the view as we go."
 W !,"    for (var i = 0; i < view.length; i++) {"
 W !,"      var lineView = view[i];"
 W !,"      if (lineView.hidden) {"
 W !,"      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet"
 W !,"        var node = buildLineElement(cm, lineView, lineN, dims);"
 W !,"        container.insertBefore(node, cur);"
 W !,"      } else { // Already drawn"
 W !,"        while (cur != lineView.node) cur = rm(cur);"
 W !,"        var updateNumber = lineNumbers && updateNumbersFrom != null &&"
 W !,"          updateNumbersFrom <= lineN && lineView.lineNumber;"
 W !,"        if (lineView.changes) {"
 W !,"          if (indexOf(lineView.changes, ""gutter"") > -1) updateNumber = false;"
 W !,"          updateLineForChanges(cm, lineView, lineN, dims);"
 W !,"        }"
 W !,"        if (updateNumber) {"
 W !,"          removeChildren(lineView.lineNumber);"
 W !,"          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));"
 W !,"        }"
 W !,"        cur = lineView.node.nextSibling;"
 W !,"      }"
 W !,"      lineN += lineView.size;"
 W !,"    }"
 W !,"    while (cur) cur = rm(cur);"
 W !,"  }",!
 W !,"  // When an aspect of a line changes, a string is added to"
 W !,"  // lineView.changes. This updates the relevant part of the line's"
 W !,"  // DOM structure."
 W !,"  function updateLineForChanges(cm, lineView, lineN, dims) {"
 W !,"    for (var j = 0; j < lineView.changes.length; j++) {"
 W !,"      var type = lineView.changes[j];"
 W !,"      if (type == ""text"") updateLineText(cm, lineView);"
 W !,"      else if (type == ""gutter"") updateLineGutter(cm, lineView, lineN, dims);"
 W !,"      else if (type == ""class"") updateLineClasses(lineView);"
 W !,"      else if (type == ""widget"") updateLineWidgets(cm, lineView, dims);"
 W !,"    }"
 W !,"    lineView.changes = null;"
 W !,"  }",!
 W !,"  // Lines with gutter elements, widgets or a background class need to"
 W !,"  // be wrapped, and have the extra elements added to the wrapper div"
 W !,"  function ensureLineWrapped(lineView) {"
 W !,"    if (lineView.node == lineView.text) {"
 W !,"      lineView.node = elt(""div"", null, null, ""position: relative"");"
 W !,"      if (lineView.text.parentNode)"
 W !,"        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);"
 W !,"      lineView.node.appendChild(lineView.text);"
 W !,"      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;"
 W !,"    }"
 W !,"    return lineView.node;"
 W !,"  }",!
 W !,"  function updateLineBackground(lineView) {"
 W !,"    var cls = lineView.bgClass ? lineView.bgClass + "" "" + (lineView.line.bgClass || """") : lineView.line.bgClass;"
 W !,"    if (cls) cls += "" CodeMirror-linebackground"";"
 W !,"    if (lineView.background) {"
 W !,"      if (cls) lineView.background.className = cls;"
 W !,"      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }"
 W !,"    } else if (cls) {"
 W !,"      var wrap = ensureLineWrapped(lineView);"
 W !,"      lineView.background = wrap.insertBefore(elt(""div"", null, cls), wrap.firstChild);"
 W !,"    }"
 W !,"  }",!
 W !,"  // Wrapper around buildLineContent which will reuse the structure"
 W !,"  // in display.externalMeasured when possible."
 W !,"  function getLineContent(cm, lineView) {"
 W !,"    var ext = cm.display.externalMeasured;"
 W !,"    if (ext && ext.line == lineView.line) {"
 W !,"      cm.display.externalMeasured = null;"
 W !,"      lineView.measure = ext.measure;"
 W !,"      return ext.built;"
 W !,"    }"
 W !,"    return buildLineContent(cm, lineView);"
 W !,"  }",!
 W !,"  // Redraw the line's text. Interacts with the background and text"
 W !,"  // classes because the mode may output tokens that influence these"
 W !,"  // classes."
 W !,"  function updateLineText(cm, lineView) {"
 W !,"    var cls = lineView.text.className;"
 W !,"    var built = getLineContent(cm, lineView);"
 W !,"    if (lineView.text == lineView.node) lineView.node = built.pre;"
 W !,"    lineView.text.parentNode.replaceChild(built.pre, lineView.text);"
 W !,"    lineView.text = built.pre;"
 W !,"    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {"
 W !,"      lineView.bgClass = built.bgClass;"
 W !,"      lineView.textClass = built.textClass;"
 W !,"      updateLineClasses(lineView);"
 W !,"    } else if (cls) {"
 W !,"      lineView.text.className = cls;"
 W !,"    }"
 W !,"  }",!
 W !,"  function updateLineClasses(lineView) {"
 W !,"    updateLineBackground(lineView);"
 W !,"    if (lineView.line.wrapClass)"
 W !,"      ensureLineWrapped(lineView).className = lineView.line.wrapClass;"
 W !,"    else if (lineView.node != lineView.text)"
 W !,"      lineView.node.className = """";"
 W !,"    var textClass = lineView.textClass ? lineView.textClass + "" "" + (lineView.line.textClass || """") : lineView.line.textClass;"
 W !,"    lineView.text.className = textClass || """";"
 W !,"  }",!
 W !,"  function updateLineGutter(cm, lineView, lineN, dims) {"
 W !,"    if (lineView.gutter) {"
 W !,"      lineView.node.removeChild(lineView.gutter);"
 W !,"      lineView.gutter = null;"
 W !,"    }"
 W !,"    if (lineView.gutterBackground) {"
 W !,"      lineView.node.removeChild(lineView.gutterBackground);"
 W !,"      lineView.gutterBackground = null;"
 W !,"    }"
 W !,"    if (lineView.line.gutterClass) {"
 W !,"      var wrap = ensureLineWrapped(lineView);"
 W !,"      lineView.gutterBackground = elt(""div"", null, ""CodeMirror-gutter-background "" + lineView.line.gutterClass,"
 W !,"                                      ""left: "" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +"
 W !,"                                      ""px; width: "" + dims.gutterTotalWidth + ""px"");"
 W !,"      wrap.insertBefore(lineView.gutterBackground, lineView.text);"
 W !,"    }"
 W !,"    var markers = lineView.line.gutterMarkers;"
 W !,"    if (cm.options.lineNumbers || markers) {"
 W !,"      var wrap = ensureLineWrapped(lineView);"
 W !,"      var gutterWrap = lineView.gutter = elt(""div"", null, ""CodeMirror-gutter-wrapper"", ""left: "" +"
 W !,"                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + ""px"");"
 W !,"      cm.display.input.setUneditable(gutterWrap);"
 W !,"      wrap.insertBefore(gutterWrap, lineView.text);"
 W !,"      if (lineView.line.gutterClass)"
 W !,"        gutterWrap.className += "" "" + lineView.line.gutterClass;"
 W !,"      if (cm.options.lineNumbers && (!markers || !markers[""CodeMirror-linenumbers""]))"
 W !,"        lineView.lineNumber = gutterWrap.appendChild("
 W !,"          elt(""div"", lineNumberFor(cm.options, lineN),"
 W !,"              ""CodeMirror-linenumber CodeMirror-gutter-elt"","
 W !,"              ""left: "" + dims.gutterLeft[""CodeMirror-linenumbers""] + ""px; width: """
 W !,"              + cm.display.lineNumInnerWidth + ""px""));"
 W !,"      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {"
 W !,"        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];"
 W !,"        if (found)"
 W !,"          gutterWrap.appendChild(elt(""div"", [found], ""CodeMirror-gutter-elt"", ""left: "" +"
 W !,"                                     dims.gutterLeft[id] + ""px; width: "" + dims.gutterWidth[id] + ""px""));"
 W !,"      }"
 W !,"    }"
 W !,"  }",!
 W !,"  function updateLineWidgets(cm, lineView, dims) {"
 W !,"    if (lineView.alignable) lineView.alignable = null;"
 W !,"    for (var node = lineView.node.firstChild, next; node; node = next) {"
 W !,"      var next = node.nextSibling;"
 W !,"      if (node.className == ""CodeMirror-linewidget"")"
 W !,"        lineView.node.removeChild(node);"
 W !,"    }"
 W !,"    insertLineWidgets(cm, lineView, dims);"
 W !,"  }",!
 W !,"  // Build a line's DOM representation from scratch"
 W !,"  function buildLineElement(cm, lineView, lineN, dims) {"
 W !,"    var built = getLineContent(cm, lineView);"
 W !,"    lineView.text = lineView.node = built.pre;"
 W !,"    if (built.bgClass) lineView.bgClass = built.bgClass;"
 W !,"    if (built.textClass) lineView.textClass = built.textClass;",!
 W !,"    updateLineClasses(lineView);"
 W !,"    updateLineGutter(cm, lineView, lineN, dims);"
 W !,"    insertLineWidgets(cm, lineView, dims);"
 W !,"    return lineView.node;"
 W !,"  }",!
 W !,"  // A lineView may contain multiple logical lines (when merged by"
 W !,"  // collapsed spans). The widgets for all of them need to be drawn."
 W !,"  function insertLineWidgets(cm, lineView, dims) {"
 W !,"    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);"
 W !,"    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)"
 W !,"      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);"
 W !,"  }",!
 W !,"  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {"
 W !,"    if (!line.widgets) return;"
 W !,"    var wrap = ensureLineWrapped(lineView);"
 W !,"    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {"
 W !,"      var widget = ws[i], node = elt(""div"", [widget.node], ""CodeMirror-linewidget"");"
 W !,"      if (!widget.handleMouseEvents) node.setAttribute(""cm-ignore-events"", ""true"");"
 W !,"      positionLineWidget(widget, node, lineView, dims);"
 W !,"      cm.display.input.setUneditable(node);"
 W !,"      if (allowAbove && widget.above)"
 W !,"        wrap.insertBefore(node, lineView.gutter || lineView.text);"
 W !,"      else"
 W !,"        wrap.appendChild(node);"
 W !,"      signalLater(widget, ""redraw"");"
 W !,"    }"
 W !,"  }",!
 W !,"  function positionLineWidget(widget, node, lineView, dims) {"
 W !,"    if (widget.noHScroll) {"
 W !,"      (lineView.alignable || (lineView.alignable = [])).push(node);"
 W !,"      var width = dims.wrapperWidth;"
 W !,"      node.style.left = dims.fixedPos + ""px"";"
 W !,"      if (!widget.coverGutter) {"
 W !,"        width -= dims.gutterTotalWidth;"
 W !,"        node.style.paddingLeft = dims.gutterTotalWidth + ""px"";"
 W !,"      }"
 W !,"      node.style.width = width + ""px"";"
 W !,"    }"
 W !,"    if (widget.coverGutter) {"
 W !,"      node.style.zIndex = 5;"
 W !,"      node.style.position = ""relative"";"
 W !,"      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + ""px"";"
 W !,"    }"
 W !,"  }",!
 W !,"  // POSITION OBJECT",!
 W !,"  // A Pos instance represents a position within the text."
 W !,"  var Pos = CodeMirror.Pos = function(line, ch) {"
 W !,"    if (!(this instanceof Pos)) return new Pos(line, ch);"
 W !,"    this.line = line; this.ch = ch;"
 W !,"  };",!
 W !,"  // Compare two positions, return 0 if they are the same, a negative"
 W !,"  // number when a is less, and a positive number otherwise."
 W !,"  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };",!
 W !,"  function copyPos(x) {return Pos(x.line, x.ch);}"
 W !,"  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }"
 W !,"  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }",!
 W !,"  // INPUT HANDLING",!
 W !,"  function ensureFocus(cm) {"
 W !,"    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }"
 W !,"  }",!
 W !,"  // This will be set to an array of strings when copying, so that,"
 W !,"  // when pasting, we know what kind of selections the copied text"
 W !,"  // was made out of."
 W !,"  var lastCopied = null;",!
 W !,"  function applyTextInput(cm, inserted, deleted, sel, origin) {"
 W !,"    var doc = cm.doc;"
 W !,"    cm.display.shift = false;"
 W !,"    if (!sel) sel = doc.sel;",!
 W !,"    var paste = cm.state.pasteIncoming || origin == ""paste"";"
 W !,"    var textLines = doc.splitLines(inserted), multiPaste = null;"
 W !,"    // When pasing N lines into N selections, insert one line per selection"
 W !,"    if (paste && sel.ranges.length > 1) {"
 W !,"      if (lastCopied && lastCopied.join(""\n"") == inserted) {"
 W !,"        if (sel.ranges.length % lastCopied.length == 0) {"
 W !,"          multiPaste = [];"
 W !,"          for (var i = 0; i < lastCopied.length; i++)"
 W !,"            multiPaste.push(doc.splitLines(lastCopied[i]));"
 W !,"        }"
 W !,"      } else if (textLines.length == sel.ranges.length) {"
 W !,"        multiPaste = map(textLines, function(l) { return [l]; });"
 W !,"      }"
 W !,"    }",!
 W !,"    // Normal behavior is to insert the new text into every selection"
 W !,"    for (var i = sel.ranges.length - 1; i >= 0; i--) {"
 W !,"      var range = sel.ranges[i];"
 W !,"      var from = range.from(), to = range.to();"
 W !,"      if (range.empty()) {"
 W !,"        if (deleted && deleted > 0) // Handle deletion"
 W !,"          from = Pos(from.line, from.ch - deleted);"
 W !,"        else if (cm.state.overwrite && !paste) // Handle overwrite"
 W !,"          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));"
 W !,"      }"
 W !,"      var updateInput = cm.curOp.updateInput;"
 W !,"      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,"
 W !,"                         origin: origin || (paste ? ""paste"" : cm.state.cutIncoming ? ""cut"" : ""+input"")};"
 W !,"      makeChange(cm.doc, changeEvent);"
 W !,"      signalLater(cm, ""inputRead"", cm, changeEvent);"
 W !,"    }"
 W !,"    if (inserted && !paste)"
 W !,"      triggerElectric(cm, inserted);",!
 W !,"    ensureCursorVisible(cm);"
 W !,"    cm.curOp.updateInput = updateInput;"
 W !,"    cm.curOp.typing = true;"
 W !,"    cm.state.pasteIncoming = cm.state.cutIncoming = false;"
 W !,"  }",!
 W !,"  function handlePaste(e, cm) {"
 W !,"    var pasted = e.clipboardData && e.clipboardData.getData(""text/plain"");"
 W !,"    if (pasted) {"
 W !,"      e.preventDefault();"
 W !,"      if (!cm.isReadOnly() && !cm.options.disableInput)"
 W !,"        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, ""paste""); });"
 W !,"      return true;"
 W !,"    }"
 W !,"  }",!
 W !,"  function triggerElectric(cm, inserted) {"
 W !,"    // When an 'electric' character is inserted, immediately trigger a reindent"
 W !,"    if (!cm.options.electricChars || !cm.options.smartIndent) return;"
 W !,"    var sel = cm.doc.sel;",!
 W !,"    for (var i = sel.ranges.length - 1; i >= 0; i--) {"
 W !,"      var range = sel.ranges[i];"
 W !,"      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;"
 W !,"      var mode = cm.getModeAt(range.head);"
 W !,"      var indented = false;"
 W !,"      if (mode.electricChars) {"
 W !,"        for (var j = 0; j < mode.electricChars.length; j++)"
 W !,"          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {"
 W !,"            indented = indentLine(cm, range.head.line, ""smart"");"
 W !,"            break;"
 W !,"          }"
 W !,"      } else if (mode.electricInput) {"
 W !,"        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))"
 W !,"          indented = indentLine(cm, range.head.line, ""smart"");"
 W !,"      }"
 W !,"      if (indented) signalLater(cm, ""electricInput"", cm, range.head.line);"
 W !,"    }"
 W !,"  }",!
 W !,"  function copyableRanges(cm) {"
 W !,"    var text = [], ranges = [];"
 W !,"    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {"
 W !,"      var line = cm.doc.sel.ranges[i].head.line;"
 W !,"      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};"
 W !,"      ranges.push(lineRange);"
 W !,"      text.push(cm.getRange(lineRange.anchor, lineRange.head));"
 W !,"    }"
 W !,"    return {text: text, ranges: ranges};"
 W !,"  }",!
 W !,"  function disableBrowserMagic(field) {"
 W !,"    field.setAttribute(""autocorrect"", ""off"");"
 W !,"    field.setAttribute(""autocapitalize"", ""off"");"
 W !,"    field.setAttribute(""spellcheck"", ""false"");"
 W !,"  }",!
 W !,"  // TEXTAREA INPUT STYLE",!
 W !,"  function TextareaInput(cm) {"
 W !,"    this.cm = cm;"
 W !,"    // See input.poll and input.reset"
 W !,"    this.prevInput = """";",!
 W !,"    // Flag that indicates whether we expect input to appear real soon"
 W !,"    // now (after some event like 'keypress' or 'input') and are"
 W !,"    // polling intensively."
 W !,"    this.pollingFast = false;"
 W !,"    // Self-resetting timeout for the poller"
 W !,"    this.polling = new Delayed();"
 W !,"    // Tracks when input.reset has punted to just putting a short"
 W !,"    // string into the textarea instead of the full selection."
 W !,"    this.inaccurateSelection = false;"
 W !,"    // Used to work around IE issue with selection being forgotten when focus moves away from textarea"
 W !,"    this.hasSelection = false;"
 W !,"    this.composing = null;"
 W !,"  };",!
 W !,"  function hiddenTextarea() {"
 W !,"    var te = elt(""textarea"", null, null, ""position: absolute; padding: 0; width: 1px; height: 1em; outline: none"");"
 W !,"    var div = elt(""div"", [te], null, ""overflow: hidden; position: relative; width: 3px; height: 0px;"");"
 W !,"    // The textarea is kept positioned near the cursor to prevent the"
 W !,"    // fact that it'll be scrolled into view on input from scrolling"
 W !,"    // our fake cursor out of view. On webkit, when wrap=off, paste is"
 W !,"    // very slow. So make the area wide instead."
 W !,"    if (webkit) te.style.width = ""1000px"";"
 W !,"    else te.setAttribute(""wrap"", ""off"");"
 W !,"    // If border: 0; -- iOS fails to open keyboard (issue #1287)"
 W !,"    if (ios) te.style.border = ""1px solid black"";"
 W !,"    disableBrowserMagic(te);"
 W !,"    return div;"
 W !,"  }",!
 W !,"  TextareaInput.prototype = copyObj({"
 W !,"    init: function(display) {"
 W !,"      var input = this, cm = this.cm;",!
 W !,"      // Wraps and hides input textarea"
 W !,"      var div = this.wrapper = hiddenTextarea();"
 W !,"      // The semihidden textarea that is focused when the editor is"
 W !,"      // focused, and receives input."
 W !,"      var te = this.textarea = div.firstChild;"
 W !,"      display.wrapper.insertBefore(div, display.wrapper.firstChild);",!
 W !,"      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)"
 W !,"      if (ios) te.style.width = ""0px"";",!
 W !,"      on(te, ""input"", function() {"
 W !,"        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;"
 W !,"        input.poll();"
 W !,"      });",!
 W !,"      on(te, ""paste"", function(e) {"
 W !,"        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return"

 W !,"        cm.state.pasteIncoming = true;"
 W !,"        input.fastPoll();"
 W !,"      });"

 W !,"      function prepareCopyCut(e) {"
 W !,"        if (signalDOMEvent(cm, e)) return"
 W !,"        if (cm.somethingSelected()) {"
 W !,"          lastCopied = cm.getSelections();"
 W !,"          if (input.inaccurateSelection) {"
 W !,"            input.prevInput = """";"
 W !,"            input.inaccurateSelection = false;"
 W !,"            te.value = lastCopied.join(""\n"");"
 W !,"            selectInput(te);"
 W !,"          }"
 W !,"        } else if (!cm.options.lineWiseCopyCut) {"
 W !,"          return;"
 W !,"        } else {"
 W !,"          var ranges = copyableRanges(cm);"
 W !,"          lastCopied = ranges.text;"
 W !,"          if (e.type == ""cut"") {"
 W !,"            cm.setSelections(ranges.ranges, null, sel_dontScroll);"
 W !,"          } else {"
 W !,"            input.prevInput = """";"
 W !,"            te.value = ranges.text.join(""\n"");"
 W !,"            selectInput(te);"
 W !,"          }"
 W !,"        }"
 W !,"        if (e.type == ""cut"") cm.state.cutIncoming = true;"
 W !,"      }"
 W !,"      on(te, ""cut"", prepareCopyCut);"
 W !,"      on(te, ""copy"", prepareCopyCut);"

 W !,"      on(display.scroller, ""paste"", function(e) {"
 W !,"        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;"
 W !,"        cm.state.pasteIncoming = true;"
 W !,"        input.focus();"
 W !,"      });"

 W !,"      // Prevent normal selection in the editor (we handle our own)"
 W !,"      on(display.lineSpace, ""selectstart"", function(e) {"
 W !,"        if (!eventInWidget(display, e)) e_preventDefault(e);"
 W !,"      });"

 W !,"      on(te, ""compositionstart"", function() {"
 W !,"        var start = cm.getCursor(""from"");"
 W !,"        if (input.composing) input.composing.range.clear()"
 W !,"        input.composing = {"
 W !,"          start: start,"
 W !,"          range: cm.markText(start, cm.getCursor(""to""), {className: ""CodeMirror-composing""})"
 W !,"        };"
 W !,"      });"
 W !,"      on(te, ""compositionend"", function() {"
 W !,"        if (input.composing) {"
 W !,"          input.poll();"
 W !,"          input.composing.range.clear();"
 W !,"          input.composing = null;"
 W !,"        }"
 W !,"      });"
 W !,"    },"
}

ClassMethod ScriptLibCodemirror3()
{
 W !,"    prepareSelection: function() {"
 W !,"      // Redraw the selection and/or cursor"
 W !,"      var cm = this.cm, display = cm.display, doc = cm.doc;"
 W !,"      var result = prepareSelection(cm);"

 W !,"      // Move the hidden textarea near the cursor to prevent scrolling artifacts"
 W !,"      if (cm.options.moveInputWithCursor) {"
 W !,"        var headPos = cursorCoords(cm, doc.sel.primary().head, ""div"");"
 W !,"        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();"
 W !,"        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,"
 W !,"                                            headPos.top + lineOff.top - wrapOff.top));"
 W !,"        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,"
 W !,"                                             headPos.left + lineOff.left - wrapOff.left));"
 W !,"      }"

 W !,"      return result;"
 W !,"    },"

 W !,"    showSelection: function(drawn) {"
 W !,"      var cm = this.cm, display = cm.display;"
 W !,"      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);"
 W !,"      removeChildrenAndAdd(display.selectionDiv, drawn.selection);"
 W !,"      if (drawn.teTop != null) {"
 W !,"        this.wrapper.style.top = drawn.teTop + ""px"";"
 W !,"        this.wrapper.style.left = drawn.teLeft + ""px"";"
 W !,"      }"
 W !,"    },"

 W !,"    // Reset the input to correspond to the selection (or to be empty,"
 W !,"    // when not typing and nothing is selected)"
 W !,"    reset: function(typing) {"
 W !,"      if (this.contextMenuPending) return;"
 W !,"      var minimal, selected, cm = this.cm, doc = cm.doc;"
 W !,"      if (cm.somethingSelected()) {"
 W !,"        this.prevInput = """";"
 W !,"        var range = doc.sel.primary();"
 W !,"        minimal = hasCopyEvent &&"
 W !,"          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);"
 W !,"        var content = minimal ? ""-"" : selected || cm.getSelection();"
 W !,"        this.textarea.value = content;"
 W !,"        if (cm.state.focused) selectInput(this.textarea);"
 W !,"        if (ie && ie_version >= 9) this.hasSelection = content;"
 W !,"      } else if (!typing) {"
 W !,"        this.prevInput = this.textarea.value = """";"
 W !,"        if (ie && ie_version >= 9) this.hasSelection = null;"
 W !,"      }"
 W !,"      this.inaccurateSelection = minimal;"
 W !,"    },"

 W !,"    getField: function() { return this.textarea; },"

 W !,"    supportsTouch: function() { return false; },"

 W !,"    focus: function() {"
 W !,"      if (this.cm.options.readOnly != ""nocursor"" && (!mobile || activeElt() != this.textarea)) {"
 W !,"        try { this.textarea.focus(); }"
 W !,"        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM"
 W !,"      }"
 W !,"    },"

 W !,"    blur: function() { this.textarea.blur(); },"

 W !,"    resetPosition: function() {"
 W !,"      this.wrapper.style.top = this.wrapper.style.left = 0;"
 W !,"    },"

 W !,"    receivedFocus: function() { this.slowPoll(); },"

 W !,"    // Poll for input changes, using the normal rate of polling. This"
 W !,"    // runs as long as the editor is focused."
 W !,"    slowPoll: function() {"
 W !,"      var input = this;"
 W !,"      if (input.pollingFast) return;"
 W !,"      input.polling.set(this.cm.options.pollInterval, function() {"
 W !,"        input.poll();"
 W !,"        if (input.cm.state.focused) input.slowPoll();"
 W !,"      });"
 W !,"    },"

 W !,"    // When an event has just come in that is likely to add or change"
 W !,"    // something in the input textarea, we poll faster, to ensure that"
 W !,"    // the change appears on the screen quickly."
 W !,"    fastPoll: function() {"
 W !,"      var missed = false, input = this;"
 W !,"      input.pollingFast = true;"
 W !,"      function p() {"
 W !,"        var changed = input.poll();"
 W !,"        if (!changed && !missed) {missed = true; input.polling.set(60, p);}"
 W !,"        else {input.pollingFast = false; input.slowPoll();}"
 W !,"      }"
 W !,"      input.polling.set(20, p);"
 W !,"    },"

 W !,"    // Read input from the textarea, and update the document to match."
 W !,"    // When something is selected, it is present in the textarea, and"
 W !,"    // selected (unless it is huge, in which case a placeholder is"
 W !,"    // used). When nothing is selected, the cursor sits after previously"
 W !,"    // seen text (can be empty), which is stored in prevInput (we must"
 W !,"    // not reset the textarea when typing, because that breaks IME)."
 W !,"    poll: function() {"
 W !,"      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;"
 W !,"      // Since this is called a *lot*, try to bail out as cheaply as"
 W !,"      // possible when it is clear that nothing happened. hasSelection"
 W !,"      // will be the case when there is a lot of text in the textarea,"
 W !,"      // in which case reading its value would be expensive."
 W !,"      if (this.contextMenuPending || !cm.state.focused ||"
 W !,"          (hasSelection(input) && !prevInput && !this.composing) ||"
 W !,"          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)"
 W !,"        return false;"

 W !,"      var text = input.value;"
 W !,"      // If nothing changed, bail."
 W !,"      if (text == prevInput && !cm.somethingSelected()) return false;"
 W !,"      // Work around nonsensical selection resetting in IE9/10, and"
 W !,"      // inexplicable appearance of private area unicode characters on"
 W !,"      // some key combos in Mac (#2689)."
 W !,"      if (ie && ie_version >= 9 && this.hasSelection === text ||"
 W !,"          mac && /[\uf700-\uf7ff]/.test(text)) {"
 W !,"        cm.display.input.reset();"
 W !,"        return false;"
 W !,"      }"

 W !,"      if (cm.doc.sel == cm.display.selForContextMenu) {"
 W !,"        var first = text.charCodeAt(0);"
 W !,"        if (first == 0x200b && !prevInput) prevInput = ""\u200b"";"
 W !,"        if (first == 0x21da) { this.reset(); return this.cm.execCommand(""undo""); }"
 W !,"      }"
 W !,"      // Find the part of the input that is actually new"
 W !,"      var same = 0, l = Math.min(prevInput.length, text.length);"
 W !,"      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;"

 W !,"      var self = this;"
 W !,"      runInOp(cm, function() {"
 W !,"        applyTextInput(cm, text.slice(same), prevInput.length - same,"
 W !,"                       null, self.composing ? ""*compose"" : null);"

 W !,"        // Don't leave long text in the textarea, since it makes further polling slow"
 W !,"        if (text.length > 1000 || text.indexOf(""\n"") > -1) input.value = self.prevInput = """";"
 W !,"        else self.prevInput = text;"

 W !,"        if (self.composing) {"
 W !,"          self.composing.range.clear();"
 W !,"          self.composing.range = cm.markText(self.composing.start, cm.getCursor(""to""),"
 W !,"                                             {className: ""CodeMirror-composing""});"
 W !,"        }"
 W !,"      });"
 W !,"      return true;"
 W !,"    },"

 W !,"    ensurePolled: function() {"
 W !,"      if (this.pollingFast && this.poll()) this.pollingFast = false;"
 W !,"    },"

 W !,"    onKeyPress: function() {"
 W !,"      if (ie && ie_version >= 9) this.hasSelection = null;"
 W !,"      this.fastPoll();"
 W !,"    },"

 W !,"    onContextMenu: function(e) {"
 W !,"      var input = this, cm = input.cm, display = cm.display, te = input.textarea;"
 W !,"      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;"
 W !,"      if (!pos || presto) return; // Opera is difficult."

 W !,"      // Reset the current text selection only if the click is done outside of the selection"
 W !,"      // and 'resetSelectionOnContextMenu' option is true."
 W !,"      var reset = cm.options.resetSelectionOnContextMenu;"
 W !,"      if (reset && cm.doc.sel.contains(pos) == -1)"
 W !,"        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);"

 W !,"      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;"
 W !,"      input.wrapper.style.cssText = ""position: absolute"""
 W !,"      var wrapperBox = input.wrapper.getBoundingClientRect()"
 W !,"      te.style.cssText = ""position: absolute; width: 30px; height: 30px; top: "" + (e.clientY - wrapperBox.top - 5) +"
 W !,"        ""px; left: "" + (e.clientX - wrapperBox.left - 5) + ""px; z-index: 1000; background: "" +"
 W !,"        (ie ? ""rgba(255, 255, 255, .05)"" : ""transparent"") +"
 W !,"        ""; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);"";"
 W !,"      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)"
 W !,"      display.input.focus();"
 W !,"      if (webkit) window.scrollTo(null, oldScrollY);"
 W !,"      display.input.reset();"
 W !,"      // Adds ""Select all"" to context menu in FF"
 W !,"      if (!cm.somethingSelected()) te.value = input.prevInput = "" "";"
 W !,"      input.contextMenuPending = true;"
 W !,"      display.selForContextMenu = cm.doc.sel;"
 W !,"      clearTimeout(display.detectingSelectAll);"

 W !,"      // Select-all will be greyed out if there's nothing to select, so"
 W !,"      // this adds a zero-width space so that we can later check whether"
 W !,"      // it got selected."
 W !,"      function prepareSelectAllHack() {"
 W !,"        if (te.selectionStart != null) {"
 W !,"          var selected = cm.somethingSelected();"
 W !,"          var extval = ""\u200b"" + (selected ? te.value : """");"
 W !,"          te.value = ""\u21da""; // Used to catch context-menu undo"
 W !,"          te.value = extval;"
 W !,"          input.prevInput = selected ? """" : ""\u200b"";"
 W !,"          te.selectionStart = 1; te.selectionEnd = extval.length;"
 W !,"          // Re-set this, in case some other handler touched the"
 W !,"          // selection in the meantime."
 W !,"          display.selForContextMenu = cm.doc.sel;"
 W !,"        }"
 W !,"      }"
 W !,"      function rehide() {"
 W !,"        input.contextMenuPending = false;"
 W !,"        input.wrapper.style.cssText = oldWrapperCSS"
 W !,"        te.style.cssText = oldCSS;"
 W !,"        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);"

 W !,"        // Try to detect the user choosing select-all"
 W !,"        if (te.selectionStart != null) {"
 W !,"          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();"
 W !,"          var i = 0, poll = function() {"
 W !,"            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&"
 W !,"                te.selectionEnd > 0 && input.prevInput == ""\u200b"")"
 W !,"              operation(cm, commands.selectAll)(cm);"
 W !,"            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);"
 W !,"            else display.input.reset();"
 W !,"          };"
 W !,"          display.detectingSelectAll = setTimeout(poll, 200);"
 W !,"        }"
 W !,"      }"

 W !,"      if (ie && ie_version >= 9) prepareSelectAllHack();"
 W !,"      if (captureRightClick) {"
 W !,"        e_stop(e);"
 W !,"        var mouseup = function() {"
 W !,"          off(window, ""mouseup"", mouseup);"
 W !,"          setTimeout(rehide, 20);"
 W !,"        };"
 W !,"        on(window, ""mouseup"", mouseup);"
 W !,"      } else {"
 W !,"        setTimeout(rehide, 50);"
 W !,"      }"
 W !,"    },"

 W !,"    readOnlyChanged: function(val) {"
 W !,"      if (!val) this.reset();"
 W !,"    },"

 W !,"    setUneditable: nothing,"

 W !,"    needsContentAttribute: false"
 W !,"  }, TextareaInput.prototype);"

 W !,"  // CONTENTEDITABLE INPUT STYLE"

 W !,"  function ContentEditableInput(cm) {"
 W !,"    this.cm = cm;"
 W !,"    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;"
 W !,"    this.polling = new Delayed();"
 W !,"    this.gracePeriod = false;"
 W !,"  }"

 W !,"  ContentEditableInput.prototype = copyObj({"
 W !,"    init: function(display) {"
 W !,"      var input = this, cm = input.cm;"
 W !,"      var div = input.div = display.lineDiv;"
 W !,"      disableBrowserMagic(div);"

 W !,"      on(div, ""paste"", function(e) {"
 W !,"        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);"
 W !,"      })"

 W !,"      on(div, ""compositionstart"", function(e) {"
 W !,"        var data = e.data;"
 W !,"        input.composing = {sel: cm.doc.sel, data: data, startData: data};"
 W !,"        if (!data) return;"
 W !,"        var prim = cm.doc.sel.primary();"
 W !,"        var line = cm.getLine(prim.head.line);"
 W !,"        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));"
 W !,"        if (found > -1 && found <= prim.head.ch)"
 W !,"          input.composing.sel = simpleSelection(Pos(prim.head.line, found),"
 W !,"                                                Pos(prim.head.line, found + data.length));"
 W !,"      });"
 W !,"      on(div, ""compositionupdate"", function(e) {"
 W !,"        input.composing.data = e.data;"
 W !,"      });"
 W !,"      on(div, ""compositionend"", function(e) {"
 W !,"        var ours = input.composing;"
 W !,"        if (!ours) return;"
 W !,"        if (e.data != ours.startData && !/\u200b/.test(e.data))"
 W !,"          ours.data = e.data;"
 W !,"        // Need a small delay to prevent other code (input event,"
 W !,"        // selection polling) from doing damage when fired right after"
 W !,"        // compositionend."
 W !,"        setTimeout(function() {"
 W !,"          if (!ours.handled)"
 W !,"            input.applyComposition(ours);"
 W !,"          if (input.composing == ours)"
 W !,"            input.composing = null;"
 W !,"        }, 50);"
 W !,"      });"

 W !,"      on(div, ""touchstart"", function() {"
 W !,"        input.forceCompositionEnd();"
 W !,"      });"

 W !,"      on(div, ""input"", function() {"
 W !,"        if (input.composing) return;"
 W !,"        if (cm.isReadOnly() || !input.pollContent())"
 W !,"          runInOp(input.cm, function() {regChange(cm);});"
 W !,"      });"

 W !,"      function onCopyCut(e) {"
 W !,"        if (signalDOMEvent(cm, e)) return"
 W !,"        if (cm.somethingSelected()) {"
 W !,"          lastCopied = cm.getSelections();"
 W !,"          if (e.type == ""cut"") cm.replaceSelection("""", null, ""cut"");"
 W !,"        } else if (!cm.options.lineWiseCopyCut) {"
 W !,"          return;"
 W !,"        } else {"
 W !,"          var ranges = copyableRanges(cm);"
 W !,"          lastCopied = ranges.text;"
 W !,"          if (e.type == ""cut"") {"
 W !,"            cm.operation(function() {"
 W !,"              cm.setSelections(ranges.ranges, 0, sel_dontScroll);"
 W !,"              cm.replaceSelection("""", null, ""cut"");"
 W !,"            });"
 W !,"          }"
 W !,"        }"
 W !,"        // iOS exposes the clipboard API, but seems to discard content inserted into it"
 W !,"        if (e.clipboardData && !ios) {"
 W !,"          e.preventDefault();"
 W !,"          e.clipboardData.clearData();"
 W !,"          e.clipboardData.setData(""text/plain"", lastCopied.join(""\n""));"
 W !,"        } else {"
 W !,"          // Old-fashioned briefly-focus-a-textarea hack"
 W !,"          var kludge = hiddenTextarea(), te = kludge.firstChild;"
 W !,"          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);"
 W !,"          te.value = lastCopied.join(""\n"");"
 W !,"          var hadFocus = document.activeElement;"
 W !,"          selectInput(te);"
 W !,"          setTimeout(function() {"
 W !,"            cm.display.lineSpace.removeChild(kludge);"
 W !,"            hadFocus.focus();"
 W !,"          }, 50);"
 W !,"        }"
 W !,"      }"
 W !,"      on(div, ""copy"", onCopyCut);"
 W !,"      on(div, ""cut"", onCopyCut);"
 W !,"    },"

 W !,"    prepareSelection: function() {"
 W !,"      var result = prepareSelection(this.cm, false);"
 W !,"      result.focus = this.cm.state.focused;"
 W !,"      return result;"
 W !,"    },"

 W !,"    showSelection: function(info, takeFocus) {"
 W !,"      if (!info || !this.cm.display.view.length) return;"
 W !,"      if (info.focus || takeFocus) this.showPrimarySelection();"
 W !,"      this.showMultipleSelections(info);"
 W !,"    },"

 W !,"    showPrimarySelection: function() {"
 W !,"      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();"
 W !,"      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);"
 W !,"      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);"
 W !,"      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&"
 W !,"          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&"
 W !,"          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)"
 W !,"        return;"

 W !,"      var start = posToDOM(this.cm, prim.from());"
 W !,"      var end = posToDOM(this.cm, prim.to());"
 W !,"      if (!start && !end) return;"

 W !,"      var view = this.cm.display.view;"
 W !,"      var old = sel.rangeCount && sel.getRangeAt(0);"
 W !,"      if (!start) {"
 W !,"        start = {node: view[0].measure.map[2], offset: 0};"
 W !,"      } else if (!end) { // FIXME dangerously hacky"
 W !,"        var measure = view[view.length - 1].measure;"
 W !,"        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;"
 W !,"        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};"
 W !,"      }"

 W !,"      try { var rng = range(start.node, start.offset, end.offset, end.node); }"
 W !,"      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible"
 W !,"      if (rng) {"
 W !,"        if (!gecko && this.cm.state.focused) {"
 W !,"          sel.collapse(start.node, start.offset);"
 W !,"          if (!rng.collapsed) sel.addRange(rng);"
 W !,"        } else {"
 W !,"          sel.removeAllRanges();"
 W !,"          sel.addRange(rng);"
 W !,"        }"
 W !,"        if (old && sel.anchorNode == null) sel.addRange(old);"
 W !,"        else if (gecko) this.startGracePeriod();"
 W !,"      }"
 W !,"      this.rememberSelection();"
 W !,"    },"

 W !,"    startGracePeriod: function() {"
 W !,"      var input = this;"
 W !,"      clearTimeout(this.gracePeriod);"
 W !,"      this.gracePeriod = setTimeout(function() {"
 W !,"        input.gracePeriod = false;"
 W !,"        if (input.selectionChanged())"
 W !,"          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });"
 W !,"      }, 20);"
 W !,"    },"

 W !,"    showMultipleSelections: function(info) {"
 W !,"      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);"
 W !,"      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);"
 W !,"    },"

 W !,"    rememberSelection: function() {"
 W !,"      var sel = window.getSelection();"
 W !,"      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;"
 W !,"      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;"
 W !,"    },"

 W !,"    selectionInEditor: function() {"
 W !,"      var sel = window.getSelection();"
 W !,"      if (!sel.rangeCount) return false;"
 W !,"      var node = sel.getRangeAt(0).commonAncestorContainer;"
 W !,"      return contains(this.div, node);"
 W !,"    },"

 W !,"    focus: function() {"
 W !,"      if (this.cm.options.readOnly != ""nocursor"") this.div.focus();"
 W !,"    },"
 W !,"    blur: function() { this.div.blur(); },"
 W !,"    getField: function() { return this.div; },"

 W !,"    supportsTouch: function() { return true; },"

 W !,"    receivedFocus: function() {"
 W !,"      var input = this;"
 W !,"      if (this.selectionInEditor())"
 W !,"        this.pollSelection();"
 W !,"      else"
 W !,"        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });"

 W !,"      function poll() {"
 W !,"        if (input.cm.state.focused) {"
 W !,"          input.pollSelection();"
 W !,"          input.polling.set(input.cm.options.pollInterval, poll);"
 W !,"        }"
 W !,"      }"
 W !,"      this.polling.set(this.cm.options.pollInterval, poll);"
 W !,"    },"

 W !,"    selectionChanged: function() {"
 W !,"      var sel = window.getSelection();"
 W !,"      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||"
 W !,"        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;"
 W !,"    },"

 W !,"    pollSelection: function() {"
 W !,"      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {"
 W !,"        var sel = window.getSelection(), cm = this.cm;"
 W !,"        this.rememberSelection();"
 W !,"        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);"
 W !,"        var head = domToPos(cm, sel.focusNode, sel.focusOffset);"
 W !,"        if (anchor && head) runInOp(cm, function() {"
 W !,"          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);"
 W !,"          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;"
 W !,"        });"
 W !,"      }"
 W !,"    },"

 W !,"    pollContent: function() {"
 W !,"      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();"
 W !,"      var from = sel.from(), to = sel.to();"
 W !,"      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;"

 W !,"      var fromIndex;"
 W !,"      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {"
 W !,"        var fromLine = lineNo(display.view[0].line);"
 W !,"        var fromNode = display.view[0].node;"
 W !,"      } else {"
 W !,"        var fromLine = lineNo(display.view[fromIndex].line);"
 W !,"        var fromNode = display.view[fromIndex - 1].node.nextSibling;"
 W !,"      }"
 W !,"      var toIndex = findViewIndex(cm, to.line);"
 W !,"      if (toIndex == display.view.length - 1) {"
 W !,"        var toLine = display.viewTo - 1;"
 W !,"        var toNode = display.lineDiv.lastChild;"
 W !,"      } else {"
 W !,"        var toLine = lineNo(display.view[toIndex + 1].line) - 1;"
 W !,"        var toNode = display.view[toIndex + 1].node.previousSibling;"
 W !,"      }"

 W !,"      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));"
 W !,"      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));"
 W !,"      while (newText.length > 1 && oldText.length > 1) {"
 W !,"        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }"
 W !,"        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }"
 W !,"        else break;"
 W !,"      }"

 W !,"      var cutFront = 0, cutEnd = 0;"
 W !,"      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);"
 W !,"      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))"
 W !,"        ++cutFront;"
 W !,"      var newBot = lst(newText), oldBot = lst(oldText);"
 W !,"      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),"
 W !,"                               oldBot.length - (oldText.length == 1 ? cutFront : 0));"
 W !,"      while (cutEnd < maxCutEnd &&"
 W !,"             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))"
 W !,"        ++cutEnd;"

 W !,"      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);"
 W !,"      newText[0] = newText[0].slice(cutFront);"

 W !,"      var chFrom = Pos(fromLine, cutFront);"
 W !,"      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);"
 W !,"      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {"
 W !,"        replaceRange(cm.doc, newText, chFrom, chTo, ""+input"");"
 W !,"        return true;"
 W !,"      }"
 W !,"    },"

 W !,"    ensurePolled: function() {"
 W !,"      this.forceCompositionEnd();"
 W !,"    },"
 W !,"    reset: function() {"
 W !,"      this.forceCompositionEnd();"
 W !,"    },"
 W !,"    forceCompositionEnd: function() {"
 W !,"      if (!this.composing || this.composing.handled) return;"
 W !,"      this.applyComposition(this.composing);"
 W !,"      this.composing.handled = true;"
 W !,"      this.div.blur();"
 W !,"      this.div.focus();"
 W !,"    },"
 W !,"    applyComposition: function(composing) {"
 W !,"      if (this.cm.isReadOnly())"
 W !,"        operation(this.cm, regChange)(this.cm)"
 W !,"      else if (composing.data && composing.data != composing.startData)"
 W !,"        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);"
 W !,"    },"

 W !,"    setUneditable: function(node) {"
 W !,"      node.contentEditable = ""false"""
 W !,"    },"

 W !,"    onKeyPress: function(e) {"
 W !,"      e.preventDefault();"
 W !,"      if (!this.cm.isReadOnly())"
 W !,"        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);"
 W !,"    },"

 W !,"    readOnlyChanged: function(val) {"
 W !,"      this.div.contentEditable = String(val != ""nocursor"")"
 W !,"    },"

 W !,"    onContextMenu: nothing,"
 W !,"    resetPosition: nothing,"

 W !,"    needsContentAttribute: true"
 W !,"  }, ContentEditableInput.prototype);"

 W !,"  function posToDOM(cm, pos) {"
 W !,"    var view = findViewForLine(cm, pos.line);"
 W !,"    if (!view || view.hidden) return null;"
 W !,"    var line = getLine(cm.doc, pos.line);"
 W !,"    var info = mapFromLineView(view, line, pos.line);"

 W !,"    var order = getOrder(line), side = ""left"";"
 W !,"    if (order) {"
 W !,"      var partPos = getBidiPartAt(order, pos.ch);"
 W !,"      side = partPos % 2 ? ""right"" : ""left"";"
 W !,"    }"
 W !,"    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);"
 W !,"    result.offset = result.collapse == ""right"" ? result.end : result.start;"
 W !,"    return result;"
 W !,"  }"

 W !,"  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }"

 W !,"  function domToPos(cm, node, offset) {"
 W !,"    var lineNode;"
 W !,"    if (node == cm.display.lineDiv) {"
 W !,"      lineNode = cm.display.lineDiv.childNodes[offset];"
 W !,"      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);"
 W !,"      node = null; offset = 0;"
 W !,"    } else {"
 W !,"      for (lineNode = node;; lineNode = lineNode.parentNode) {"
 W !,"        if (!lineNode || lineNode == cm.display.lineDiv) return null;"
 W !,"        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;"
 W !,"      }"
 W !,"    }"
 W !,"    for (var i = 0; i < cm.display.view.length; i++) {"
 W !,"      var lineView = cm.display.view[i];"
 W !,"      if (lineView.node == lineNode)"
 W !,"        return locateNodeInLineView(lineView, node, offset);"
 W !,"    }"
 W !,"  }"

 W !,"  function locateNodeInLineView(lineView, node, offset) {"
 W !,"    var wrapper = lineView.text.firstChild, bad = false;"
 W !,"    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);"
 W !,"    if (node == wrapper) {"
 W !,"      bad = true;"
 W !,"      node = wrapper.childNodes[offset];"
 W !,"      offset = 0;"
 W !,"      if (!node) {"
 W !,"        var line = lineView.rest ? lst(lineView.rest) : lineView.line;"
 W !,"        return badPos(Pos(lineNo(line), line.text.length), bad);"
 W !,"      }"
 W !,"    }"

 W !,"    var textNode = node.nodeType == 3 ? node : null, topNode = node;"
 W !,"    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {"
 W !,"      textNode = node.firstChild;"
 W !,"      if (offset) offset = textNode.nodeValue.length;"
 W !,"    }"
 W !,"    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;"
 W !,"    var measure = lineView.measure, maps = measure.maps;"

 W !,"    function find(textNode, topNode, offset) {"
 W !,"      for (var i = -1; i < (maps ? maps.length : 0); i++) {"
 W !,"        var map = i < 0 ? measure.map : maps[i];"
 W !,"        for (var j = 0; j < map.length; j += 3) {"
 W !,"          var curNode = map[j + 2];"
 W !,"          if (curNode == textNode || curNode == topNode) {"
 W !,"            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);"
 W !,"            var ch = map[j] + offset;"
 W !,"            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];"
 W !,"            return Pos(line, ch);"
 W !,"          }"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"    var found = find(textNode, topNode, offset);"
 W !,"    if (found) return badPos(found, bad);"

 W !,"    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems"
 W !,"    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {"
 W !,"      found = find(after, after.firstChild, 0);"
 W !,"      if (found)"
 W !,"        return badPos(Pos(found.line, found.ch - dist), bad);"
 W !,"      else"
 W !,"        dist += after.textContent.length;"
 W !,"    }"
 W !,"    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {"
 W !,"      found = find(before, before.firstChild, -1);"
 W !,"      if (found)"
 W !,"        return badPos(Pos(found.line, found.ch + dist), bad);"
 W !,"      else"
 W !,"        dist += after.textContent.length;"
 W !,"    }"
 W !,"  }"

 W !,"  function domTextBetween(cm, from, to, fromLine, toLine) {"
 W !,"    var text = """", closing = false, lineSep = cm.doc.lineSeparator();"
 W !,"    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }"
}

ClassMethod ScriptLibCodemirror4()
{
 W !,"    function walk(node) {"
 W !,"      if (node.nodeType == 1) {"
 W !,"        var cmText = node.getAttribute(""cm-text"");"
 W !,"        if (cmText != null) {"
 W !,"          if (cmText == """") cmText = node.textContent.replace(/\u200b/g, """");"
 W !,"          text += cmText;"
 W !,"          return;"
 W !,"        }"
 W !,"        var markerID = node.getAttribute(""cm-marker""), range;"
 W !,"        if (markerID) {"
 W !,"          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));"
 W !,"          if (found.length && (range = found[0].find()))"
 W !,"            text += getBetween(cm.doc, range.from, range.to).join(lineSep);"
 W !,"          return;"
 W !,"        }"
 W !,"        if (node.getAttribute(""contenteditable"") == ""false"") return;"
 W !,"        for (var i = 0; i < node.childNodes.length; i++)"
 W !,"          walk(node.childNodes[i]);"
 W !,"        if (/^(pre|div|p)$/i.test(node.nodeName))"
 W !,"          closing = true;"
 W !,"      } else if (node.nodeType == 3) {"
 W !,"        var val = node.nodeValue;"
 W !,"        if (!val) return;"
 W !,"        if (closing) {"
 W !,"          text += lineSep;"
 W !,"          closing = false;"
 W !,"        }"
 W !,"        text += val;"
 W !,"      }"
 W !,"    }"
 W !,"    for (;;) {"
 W !,"      walk(from);"
 W !,"      if (from == to) break;"
 W !,"      from = from.nextSibling;"
 W !,"    }"
 W !,"    return text;"
 W !,"  }"

 W !,"  CodeMirror.inputStyles = {""textarea"": TextareaInput, ""contenteditable"": ContentEditableInput};"

 W !,"  // SELECTION / CURSOR"

 W !,"  // Selection objects are immutable. A new one is created every time"
 W !,"  // the selection changes. A selection is one or more non-overlapping"
 W !,"  // (and non-touching) ranges, sorted, and an integer that indicates"
 W !,"  // which one is the primary selection (the one that's scrolled into"
 W !,"  // view, that getCursor returns, etc)."
 W !,"  function Selection(ranges, primIndex) {"
 W !,"    this.ranges = ranges;"
 W !,"    this.primIndex = primIndex;"
 W !,"  }"

 W !,"  Selection.prototype = {"
 W !,"    primary: function() { return this.ranges[this.primIndex]; },"
 W !,"    equals: function(other) {"
 W !,"      if (other == this) return true;"
 W !,"      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;"
 W !,"      for (var i = 0; i < this.ranges.length; i++) {"
 W !,"        var here = this.ranges[i], there = other.ranges[i];"
 W !,"        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;"
 W !,"      }"
 W !,"      return true;"
 W !,"    },"
 W !,"    deepCopy: function() {"
 W !,"      for (var out = [], i = 0; i < this.ranges.length; i++)"
 W !,"        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));"
 W !,"      return new Selection(out, this.primIndex);"
 W !,"    },"
 W !,"    somethingSelected: function() {"
 W !,"      for (var i = 0; i < this.ranges.length; i++)"
 W !,"        if (!this.ranges[i].empty()) return true;"
 W !,"      return false;"
 W !,"    },"
 W !,"    contains: function(pos, end) {"
 W !,"      if (!end) end = pos;"
 W !,"      for (var i = 0; i < this.ranges.length; i++) {"
 W !,"        var range = this.ranges[i];"
 W !,"        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)"
 W !,"          return i;"
 W !,"      }"
 W !,"      return -1;"
 W !,"    }"
 W !,"  };"

 W !,"  function Range(anchor, head) {"
 W !,"    this.anchor = anchor; this.head = head;"
 W !,"  }"

 W !,"  Range.prototype = {"
 W !,"    from: function() { return minPos(this.anchor, this.head); },"
 W !,"    to: function() { return maxPos(this.anchor, this.head); },"
 W !,"    empty: function() {"
 W !,"      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;"
 W !,"    }"
 W !,"  };"

 W !,"  // Take an unsorted, potentially overlapping set of ranges, and"
 W !,"  // build a selection out of it. 'Consumes' ranges array (modifying"
 W !,"  // it)."
 W !,"  function normalizeSelection(ranges, primIndex) {"
 W !,"    var prim = ranges[primIndex];"
 W !,"    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });"
 W !,"    primIndex = indexOf(ranges, prim);"
 W !,"    for (var i = 1; i < ranges.length; i++) {"
 W !,"      var cur = ranges[i], prev = ranges[i - 1];"
 W !,"      if (cmp(prev.to(), cur.from()) >= 0) {"
 W !,"        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());"
 W !,"        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;"
 W !,"        if (i <= primIndex) --primIndex;"
 W !,"        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));"
 W !,"      }"
 W !,"    }"
 W !,"    return new Selection(ranges, primIndex);"
 W !,"  }"

 W !,"  function simpleSelection(anchor, head) {"
 W !,"    return new Selection([new Range(anchor, head || anchor)], 0);"
 W !,"  }"

 W !,"  // Most of the external API clips given positions to make sure they"
 W !,"  // actually exist within the document."
 W !,"  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}"
 W !,"  function clipPos(doc, pos) {"
 W !,"    if (pos.line < doc.first) return Pos(doc.first, 0);"
 W !,"    var last = doc.first + doc.size - 1;"
 W !,"    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);"
 W !,"    return clipToLen(pos, getLine(doc, pos.line).text.length);"
 W !,"  }"
 W !,"  function clipToLen(pos, linelen) {"
 W !,"    var ch = pos.ch;"
 W !,"    if (ch == null || ch > linelen) return Pos(pos.line, linelen);"
 W !,"    else if (ch < 0) return Pos(pos.line, 0);"
 W !,"    else return pos;"
 W !,"  }"
 W !,"  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}"
 W !,"  function clipPosArray(doc, array) {"
 W !,"    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);"
 W !,"    return out;"
 W !,"  }"

 W !,"  // SELECTION UPDATES"

 W !,"  // The 'scroll' parameter given to many of these indicated whether"
 W !,"  // the new cursor position should be scrolled into view after"
 W !,"  // modifying the selection."

 W !,"  // If shift is held or the extend flag is set, extends a range to"
 W !,"  // include a given position (and optionally a second position)."
 W !,"  // Otherwise, simply returns the range between the given positions."
 W !,"  // Used for cursor motion and such."
 W !,"  function extendRange(doc, range, head, other) {"
 W !,"    if (doc.cm && doc.cm.display.shift || doc.extend) {"
 W !,"      var anchor = range.anchor;"
 W !,"      if (other) {"
 W !,"        var posBefore = cmp(head, anchor) < 0;"
 W !,"        if (posBefore != (cmp(other, anchor) < 0)) {"
 W !,"          anchor = head;"
 W !,"          head = other;"
 W !,"        } else if (posBefore != (cmp(head, other) < 0)) {"
 W !,"          head = other;"
 W !,"        }"
 W !,"      }"
 W !,"      return new Range(anchor, head);"
 W !,"    } else {"
 W !,"      return new Range(other || head, head);"
 W !,"    }"
 W !,"  }"

 W !,"  // Extend the primary selection range, discard the rest."
 W !,"  function extendSelection(doc, head, other, options) {"
 W !,"    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);"
 W !,"  }"

 W !,"  // Extend all selections (pos is an array of selections with length"
 W !,"  // equal the number of selections)"
 W !,"  function extendSelections(doc, heads, options) {"
 W !,"    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)"
 W !,"      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);"
 W !,"    var newSel = normalizeSelection(out, doc.sel.primIndex);"
 W !,"    setSelection(doc, newSel, options);"
 W !,"  }"

 W !,"  // Updates a single range in the selection."
 W !,"  function replaceOneSelection(doc, i, range, options) {"
 W !,"    var ranges = doc.sel.ranges.slice(0);"
 W !,"    ranges[i] = range;"
 W !,"    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);"
 W !,"  }"

 W !,"  // Reset the selection to a single range."
 W !,"  function setSimpleSelection(doc, anchor, head, options) {"
 W !,"    setSelection(doc, simpleSelection(anchor, head), options);"
 W !,"  }"

 W !,"  // Give beforeSelectionChange handlers a change to influence a"
 W !,"  // selection update."
 W !,"  function filterSelectionChange(doc, sel, options) {"
 W !,"    var obj = {"
 W !,"      ranges: sel.ranges,"
 W !,"      update: function(ranges) {"
 W !,"        this.ranges = [];"
 W !,"        for (var i = 0; i < ranges.length; i++)"
 W !,"          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),"
 W !,"                                     clipPos(doc, ranges[i].head));"
 W !,"      },"
 W !,"      origin: options && options.origin"
 W !,"    };"
 W !,"    signal(doc, ""beforeSelectionChange"", doc, obj);"
 W !,"    if (doc.cm) signal(doc.cm, ""beforeSelectionChange"", doc.cm, obj);"
 W !,"    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);"
 W !,"    else return sel;"
 W !,"  }"

 W !,"  function setSelectionReplaceHistory(doc, sel, options) {"
 W !,"    var done = doc.history.done, last = lst(done);"
 W !,"    if (last && last.ranges) {"
 W !,"      done[done.length - 1] = sel;"
 W !,"      setSelectionNoUndo(doc, sel, options);"
 W !,"    } else {"
 W !,"      setSelection(doc, sel, options);"
 W !,"    }"
 W !,"  }"

 W !,"  // Set a new selection."
 W !,"  function setSelection(doc, sel, options) {"
 W !,"    setSelectionNoUndo(doc, sel, options);"
 W !,"    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);"
 W !,"  }"

 W !,"  function setSelectionNoUndo(doc, sel, options) {"
 W !,"    if (hasHandler(doc, ""beforeSelectionChange"") || doc.cm && hasHandler(doc.cm, ""beforeSelectionChange""))"
 W !,"      sel = filterSelectionChange(doc, sel, options);"

 W !,"    var bias = options && options.bias ||"
 W !,"      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);"
 W !,"    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));"

 W !,"    if (!(options && options.scroll === false) && doc.cm)"
 W !,"      ensureCursorVisible(doc.cm);"
 W !,"  }"

 W !,"  function setSelectionInner(doc, sel) {"
 W !,"    if (sel.equals(doc.sel)) return;"

 W !,"    doc.sel = sel;"

 W !,"    if (doc.cm) {"
 W !,"      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;"
 W !,"      signalCursorActivity(doc.cm);"
 W !,"    }"
 W !,"    signalLater(doc, ""cursorActivity"", doc);"
 W !,"  }"

 W !,"  // Verify that the selection does not partially select any atomic"
 W !,"  // marked ranges."
 W !,"  function reCheckSelection(doc) {"
 W !,"    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);"
 W !,"  }"

 W !,"  // Return a selection that does not partially select any atomic"
 W !,"  // ranges."
 W !,"  function skipAtomicInSelection(doc, sel, bias, mayClear) {"
 W !,"    var out;"
 W !,"    for (var i = 0; i < sel.ranges.length; i++) {"
 W !,"      var range = sel.ranges[i];"
 W !,"      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];"
 W !,"      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);"
 W !,"      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);"
 W !,"      if (out || newAnchor != range.anchor || newHead != range.head) {"
 W !,"        if (!out) out = sel.ranges.slice(0, i);"
 W !,"        out[i] = new Range(newAnchor, newHead);"
 W !,"      }"
 W !,"    }"
 W !,"    return out ? normalizeSelection(out, sel.primIndex) : sel;"
 W !,"  }"

 W !,"  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {"
 W !,"    var line = getLine(doc, pos.line);"
 W !,"    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {"
 W !,"      var sp = line.markedSpans[i], m = sp.marker;"
 W !,"      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&"
 W !,"          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {"
 W !,"        if (mayClear) {"
 W !,"          signal(m, ""beforeCursorEnter"");"
 W !,"          if (m.explicitlyCleared) {"
 W !,"            if (!line.markedSpans) break;"
 W !,"            else {--i; continue;}"
 W !,"          }"
 W !,"        }"
 W !,"        if (!m.atomic) continue;"

 W !,"        if (oldPos) {"
 W !,"          var near = m.find(dir < 0 ? 1 : -1), diff;"
 W !,"          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)"
 W !,"            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);"
 W !,"          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))"
 W !,"            return skipAtomicInner(doc, near, pos, dir, mayClear);"
 W !,"        }"

 W !,"        var far = m.find(dir < 0 ? -1 : 1);"
 W !,"        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)"
 W !,"          far = movePos(doc, far, dir, far.line == pos.line ? line : null);"
 W !,"        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;"
 W !,"      }"
 W !,"    }"
 W !,"    return pos;"
 W !,"  }"

 W !,"  // Ensure a given position is not inside an atomic range."
 W !,"  function skipAtomic(doc, pos, oldPos, bias, mayClear) {"
 W !,"    var dir = bias || 1;"
 W !,"    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||"
 W !,"        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||"
 W !,"        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||"
 W !,"        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));"
 W !,"    if (!found) {"
 W !,"      doc.cantEdit = true;"
 W !,"      return Pos(doc.first, 0);"
 W !,"    }"
 W !,"    return found;"
 W !,"  }"

 W !,"  function movePos(doc, pos, dir, line) {"
 W !,"    if (dir < 0 && pos.ch == 0) {"
 W !,"      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));"
 W !,"      else return null;"
 W !,"    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {"
 W !,"      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);"
 W !,"      else return null;"
 W !,"    } else {"
 W !,"      return new Pos(pos.line, pos.ch + dir);"
 W !,"    }"
 W !,"  }"

 W !,"  // SELECTION DRAWING"

 W !,"  function updateSelection(cm) {"
 W !,"    cm.display.input.showSelection(cm.display.input.prepareSelection());"
 W !,"  }"

 W !,"  function prepareSelection(cm, primary) {"
 W !,"    var doc = cm.doc, result = {};"
 W !,"    var curFragment = result.cursors = document.createDocumentFragment();"
 W !,"    var selFragment = result.selection = document.createDocumentFragment();"

 W !,"    for (var i = 0; i < doc.sel.ranges.length; i++) {"
 W !,"      if (primary === false && i == doc.sel.primIndex) continue;"
 W !,"      var range = doc.sel.ranges[i];"
 W !,"      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;"
 W !,"      var collapsed = range.empty();"
 W !,"      if (collapsed || cm.options.showCursorWhenSelecting)"
 W !,"        drawSelectionCursor(cm, range.head, curFragment);"
 W !,"      if (!collapsed)"
 W !,"        drawSelectionRange(cm, range, selFragment);"
 W !,"    }"
 W !,"    return result;"
 W !,"  }"

 W !,"  // Draws a cursor for the given range"
 W !,"  function drawSelectionCursor(cm, head, output) {"
 W !,"    var pos = cursorCoords(cm, head, ""div"", null, null, !cm.options.singleCursorHeightPerLine);"

 W !,"    var cursor = output.appendChild(elt(""div"", ""\u00a0"", ""CodeMirror-cursor""));"
 W !,"    cursor.style.left = pos.left + ""px"";"
 W !,"    cursor.style.top = pos.top + ""px"";"
 W !,"    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + ""px"";"

 W !,"    if (pos.other) {"
 W !,"      // Secondary cursor, shown when on a 'jump' in bi-directional text"
 W !,"      var otherCursor = output.appendChild(elt(""div"", ""\u00a0"", ""CodeMirror-cursor CodeMirror-secondarycursor""));"
 W !,"      otherCursor.style.display = """";"
 W !,"      otherCursor.style.left = pos.other.left + ""px"";"
 W !,"      otherCursor.style.top = pos.other.top + ""px"";"
 W !,"      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + ""px"";"
 W !,"    }"
 W !,"  }"

 W !,"  // Draws the given range as a highlighted selection"
 W !,"  function drawSelectionRange(cm, range, output) {"
 W !,"    var display = cm.display, doc = cm.doc;"
 W !,"    var fragment = document.createDocumentFragment();"
 W !,"    var padding = paddingH(cm.display), leftSide = padding.left;"
 W !,"    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;"

 W !,"    function add(left, top, width, bottom) {"
 W !,"      if (top < 0) top = 0;"
 W !,"      top = Math.round(top);"
 W !,"      bottom = Math.round(bottom);"
 W !,"      fragment.appendChild(elt(""div"", null, ""CodeMirror-selected"", ""position: absolute; left: "" + left +"
 W !,"                               ""px; top: "" + top + ""px; width: "" + (width == null ? rightSide - left : width) +"
 W !,"                               ""px; height: "" + (bottom - top) + ""px""));"
 W !,"    }"

 W !,"    function drawForLine(line, fromArg, toArg) {"
 W !,"      var lineObj = getLine(doc, line);"
 W !,"      var lineLen = lineObj.text.length;"
 W !,"      var start, end;"
 W !,"      function coords(ch, bias) {"
 W !,"        return charCoords(cm, Pos(line, ch), ""div"", lineObj, bias);"
 W !,"      }"

 W !,"      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {"
 W !,"        var leftPos = coords(from, ""left""), rightPos, left, right;"
 W !,"        if (from == to) {"
 W !,"          rightPos = leftPos;"
 W !,"          left = right = leftPos.left;"
 W !,"        } else {"
 W !,"          rightPos = coords(to - 1, ""right"");"
 W !,"          if (dir == ""rtl"") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }"
 W !,"          left = leftPos.left;"
 W !,"          right = rightPos.right;"
 W !,"        }"
 W !,"        if (fromArg == null && from == 0) left = leftSide;"
 W !,"        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part"
 W !,"          add(left, leftPos.top, null, leftPos.bottom);"
 W !,"          left = leftSide;"
 W !,"          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);"
 W !,"        }"
 W !,"        if (toArg == null && to == lineLen) right = rightSide;"
 W !,"        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)"
 W !,"          start = leftPos;"
 W !,"        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)"
 W !,"          end = rightPos;"
 W !,"        if (left < leftSide + 1) left = leftSide;"
 W !,"        add(left, rightPos.top, right - left, rightPos.bottom);"
 W !,"      });"
 W !,"      return {start: start, end: end};"
 W !,"    }"

 W !,"    var sFrom = range.from(), sTo = range.to();"
 W !,"    if (sFrom.line == sTo.line) {"
 W !,"      drawForLine(sFrom.line, sFrom.ch, sTo.ch);"
 W !,"    } else {"
 W !,"      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);"
 W !,"      var singleVLine = visualLine(fromLine) == visualLine(toLine);"
 W !,"      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;"
 W !,"      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;"
 W !,"      if (singleVLine) {"
 W !,"        if (leftEnd.top < rightStart.top - 2) {"
 W !,"          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);"
 W !,"          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);"
 W !,"        } else {"
 W !,"          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);"
 W !,"        }"
 W !,"      }"
 W !,"      if (leftEnd.bottom < rightStart.top)"
 W !,"        add(leftSide, leftEnd.bottom, null, rightStart.top);"
 W !,"    }"

 W !,"    output.appendChild(fragment);"
 W !,"  }"

 W !,"  // Cursor-blinking"
 W !,"  function restartBlink(cm) {"
 W !,"    if (!cm.state.focused) return;"
 W !,"    var display = cm.display;"
 W !,"    clearInterval(display.blinker);"
 W !,"    var on = true;"
 W !,"    display.cursorDiv.style.visibility = """";"
 W !,"    if (cm.options.cursorBlinkRate > 0)"
 W !,"      display.blinker = setInterval(function() {"
 W !,"        display.cursorDiv.style.visibility = (on = !on) ? """" : ""hidden"";"
 W !,"      }, cm.options.cursorBlinkRate);"
 W !,"    else if (cm.options.cursorBlinkRate < 0)"
 W !,"      display.cursorDiv.style.visibility = ""hidden"";"
 W !,"  }"

 W !,"  // HIGHLIGHT WORKER"

 W !,"  function startWorker(cm, time) {"
 W !,"    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)"
 W !,"      cm.state.highlight.set(time, bind(highlightWorker, cm));"
 W !,"  }"

 W !,"  function highlightWorker(cm) {"
 W !,"    var doc = cm.doc;"
 W !,"    if (doc.frontier < doc.first) doc.frontier = doc.first;"
 W !,"    if (doc.frontier >= cm.display.viewTo) return;"
 W !,"    var end = +new Date + cm.options.workTime;"
 W !,"    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));"
 W !,"    var changedLines = [];"

 W !,"    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {"
 W !,"      if (doc.frontier >= cm.display.viewFrom) { // Visible"
 W !,"        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;"
 W !,"        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);"
 W !,"        line.styles = highlighted.styles;"
 W !,"        var oldCls = line.styleClasses, newCls = highlighted.classes;"
 W !,"        if (newCls) line.styleClasses = newCls;"
 W !,"        else if (oldCls) line.styleClasses = null;"
 W !,"        var ischange = !oldStyles || oldStyles.length != line.styles.length ||"
 W !,"          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);"
 W !,"        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];"
 W !,"        if (ischange) changedLines.push(doc.frontier);"
 W !,"        line.stateAfter = tooLong ? state : copyState(doc.mode, state);"
 W !,"      } else {"
 W !,"        if (line.text.length <= cm.options.maxHighlightLength)"
 W !,"          processLine(cm, line.text, state);"
 W !,"        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;"
 W !,"      }"
 W !,"      ++doc.frontier;"
 W !,"      if (+new Date > end) {"
 W !,"        startWorker(cm, cm.options.workDelay);"
 W !,"        return true;"
 W !,"      }"
 W !,"    });"
 W !,"    if (changedLines.length) runInOp(cm, function() {"
 W !,"      for (var i = 0; i < changedLines.length; i++)"
 W !,"        regLineChange(cm, changedLines[i], ""text"");"
 W !,"    });"
 W !,"  }"

 W !,"  // Finds the line to start with when starting a parse. Tries to"
 W !,"  // find a line with a stateAfter, so that it can start with a"
 W !,"  // valid state. If that fails, it returns the line with the"
 W !,"  // smallest indentation, which tends to need the least context to"
 W !,"  // parse correctly."
 W !,"  function findStartLine(cm, n, precise) {"
 W !,"    var minindent, minline, doc = cm.doc;"
 W !,"    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);"
 W !,"    for (var search = n; search > lim; --search) {"
 W !,"      if (search <= doc.first) return doc.first;"
 W !,"      var line = getLine(doc, search - 1);"
 W !,"      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;"
 W !,"      var indented = countColumn(line.text, null, cm.options.tabSize);"
 W !,"      if (minline == null || minindent > indented) {"
 W !,"        minline = search - 1;"
 W !,"        minindent = indented;"
 W !,"      }"
 W !,"    }"
 W !,"    return minline;"
 W !,"  }"

 W !,"  function getStateBefore(cm, n, precise) {"
 W !,"    var doc = cm.doc, display = cm.display;"
 W !,"    if (!doc.mode.startState) return true;"
 W !,"    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;"
 W !,"    if (!state) state = startState(doc.mode);"
 W !,"    else state = copyState(doc.mode, state);"
 W !,"    doc.iter(pos, n, function(line) {"
 W !,"      processLine(cm, line.text, state);"
 W !,"      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;"
 W !,"      line.stateAfter = save ? copyState(doc.mode, state) : null;"
 W !,"      ++pos;"
 W !,"    });"
 W !,"    if (precise) doc.frontier = pos;"
 W !,"    return state;"
 W !,"  }"

 W !,"  // POSITION MEASUREMENT"

 W !,"  function paddingTop(display) {return display.lineSpace.offsetTop;}"
 W !,"  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}"
 W !,"  function paddingH(display) {"
 W !,"    if (display.cachedPaddingH) return display.cachedPaddingH;"
 W !,"    var e = removeChildrenAndAdd(display.measure, elt(""pre"", ""x""));"
 W !,"    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;"
 W !,"    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};"
 W !,"    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;"
 W !,"    return data;"
 W !,"  }"

 W !,"  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }"
 W !,"  function displayWidth(cm) {"
 W !,"    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;"
 W !,"  }"
 W !,"  function displayHeight(cm) {"
 W !,"    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;"
 W !,"  }"

 W !,"  // Ensure the lineView.wrapping.heights array is populated. This is"
 W !,"  // an array of bottom offsets for the lines that make up a drawn"
 W !,"  // line. When lineWrapping is on, there might be more than one"
 W !,"  // height."
 W !,"  function ensureLineHeights(cm, lineView, rect) {"
 W !,"    var wrapping = cm.options.lineWrapping;"
 W !,"    var curWidth = wrapping && displayWidth(cm);"
 W !,"    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {"
 W !,"      var heights = lineView.measure.heights = [];"
 W !,"      if (wrapping) {"
 W !,"        lineView.measure.width = curWidth;"
 W !,"        var rects = lineView.text.firstChild.getClientRects();"
 W !,"        for (var i = 0; i < rects.length - 1; i++) {"
 W !,"          var cur = rects[i], next = rects[i + 1];"
 W !,"          if (Math.abs(cur.bottom - next.bottom) > 2)"
 W !,"            heights.push((cur.bottom + next.top) / 2 - rect.top);"
 W !,"        }"
 W !,"      }"
 W !,"      heights.push(rect.bottom - rect.top);"
 W !,"    }"
 W !,"  }"

 W !,"  // Find a line map (mapping character offsets to text nodes) and a"
 W !,"  // measurement cache for the given line number. (A line view might"
 W !,"  // contain multiple lines when collapsed ranges are present.)"
 W !,"  function mapFromLineView(lineView, line, lineN) {"
 W !,"    if (lineView.line == line)"
 W !,"      return {map: lineView.measure.map, cache: lineView.measure.cache};"
 W !,"    for (var i = 0; i < lineView.rest.length; i++)"
 W !,"      if (lineView.rest[i] == line)"
 W !,"        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};"
 W !,"    for (var i = 0; i < lineView.rest.length; i++)"
 W !,"      if (lineNo(lineView.rest[i]) > lineN)"
 W !,"        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};"
 W !,"  }"

 W !,"  // Render a line into the hidden node display.externalMeasured. Used"
 W !,"  // when measurement is needed for a line that's not in the viewport."
 W !,"  function updateExternalMeasurement(cm, line) {"
 W !,"    line = visualLine(line);"
 W !,"    var lineN = lineNo(line);"
 W !,"    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);"
 W !,"    view.lineN = lineN;"
 W !,"    var built = view.built = buildLineContent(cm, view);"
 W !,"    view.text = built.pre;"
 W !,"    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);"
 W !,"    return view;"
 W !,"  }"

 W !,"  // Get a {top, bottom, left, right} box (in line-local coordinates)"
 W !,"  // for a given character."
 W !,"  function measureChar(cm, line, ch, bias) {"
 W !,"    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);"
 W !,"  }"

 W !,"  // Find a line view that corresponds to the given line number."
 W !,"  function findViewForLine(cm, lineN) {"
 W !,"    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)"
 W !,"      return cm.display.view[findViewIndex(cm, lineN)];"
 W !,"    var ext = cm.display.externalMeasured;"
 W !,"    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)"
 W !,"      return ext;"
 W !,"  }"

 W !,"  // Measurement can be split in two steps, the set-up work that"
 W !,"  // applies to the whole line, and the measurement of the actual"
 W !,"  // character. Functions like coordsChar, that need to do a lot of"
 W !,"  // measurements in a row, can thus ensure that the set-up work is"
 W !,"  // only done once."
 W !,"  function prepareMeasureForLine(cm, line) {"
 W !,"    var lineN = lineNo(line);"
 W !,"    var view = findViewForLine(cm, lineN);"
 W !,"    if (view && !view.text) {"
 W !,"      view = null;"
 W !,"    } else if (view && view.changes) {"
 W !,"      updateLineForChanges(cm, view, lineN, getDimensions(cm));"
 W !,"      cm.curOp.forceUpdate = true;"
 W !,"    }"
 W !,"    if (!view)"
 W !,"      view = updateExternalMeasurement(cm, line);"

 W !,"    var info = mapFromLineView(view, line, lineN);"
 W !,"    return {"
 W !,"      line: line, view: view, rect: null,"
 W !,"      map: info.map, cache: info.cache, before: info.before,"
 W !,"      hasHeights: false"
 W !,"    };"
 W !,"  }"

 W !,"  // Given a prepared measurement object, measures the position of an"
 W !,"  // actual character (or fetches it from the cache)."
 W !,"  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {"
 W !,"    if (prepared.before) ch = -1;"
 W !,"    var key = ch + (bias || """"), found;"
 W !,"    if (prepared.cache.hasOwnProperty(key)) {"
 W !,"      found = prepared.cache[key];"
 W !,"    } else {"
 W !,"      if (!prepared.rect)"
 W !,"        prepared.rect = prepared.view.text.getBoundingClientRect();"
 W !,"      if (!prepared.hasHeights) {"
 W !,"        ensureLineHeights(cm, prepared.view, prepared.rect);"
 W !,"        prepared.hasHeights = true;"
 W !,"      }"
 W !,"      found = measureCharInner(cm, prepared, ch, bias);"
 W !,"      if (!found.bogus) prepared.cache[key] = found;"
 W !,"    }"
 W !,"    return {left: found.left, right: found.right,"
 W !,"            top: varHeight ? found.rtop : found.top,"
 W !,"            bottom: varHeight ? found.rbottom : found.bottom};"
 W !,"  }"

 W !,"  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};"
}

ClassMethod ScriptLibCodemirror5()
{
 W !,"  function nodeAndOffsetInLineMap(map, ch, bias) {"
 W !,"    var node, start, end, collapse;"
 W !,"    // First, search the line map for the text node corresponding to,"
 W !,"    // or closest to, the target character."
 W !,"    for (var i = 0; i < map.length; i += 3) {"
 W !,"      var mStart = map[i], mEnd = map[i + 1];"
 W !,"      if (ch < mStart) {"
 W !,"        start = 0; end = 1;"
 W !,"        collapse = ""left"";"
 W !,"      } else if (ch < mEnd) {"
 W !,"        start = ch - mStart;"
 W !,"        end = start + 1;"
 W !,"      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {"
 W !,"        end = mEnd - mStart;"
 W !,"        start = end - 1;"
 W !,"        if (ch >= mEnd) collapse = ""right"";"
 W !,"      }"
 W !,"      if (start != null) {"
 W !,"        node = map[i + 2];"
 W !,"        if (mStart == mEnd && bias == (node.insertLeft ? ""left"" : ""right""))"
 W !,"          collapse = bias;"
 W !,"        if (bias == ""left"" && start == 0)"
 W !,"          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {"
 W !,"            node = map[(i -= 3) + 2];"
 W !,"            collapse = ""left"";"
 W !,"          }"
 W !,"        if (bias == ""right"" && start == mEnd - mStart)"
 W !,"          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {"
 W !,"            node = map[(i += 3) + 2];"
 W !,"            collapse = ""right"";"
 W !,"          }"
 W !,"        break;"
 W !,"      }"
 W !,"    }"
 W !,"    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};"
 W !,"  }"

 W !,"  function measureCharInner(cm, prepared, ch, bias) {"
 W !,"    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);"
 W !,"    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;"

 W !,"    var rect;"
 W !,"    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates."
 W !,"      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned"
 W !,"        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;"
 W !,"        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;"
 W !,"        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {"
 W !,"          rect = node.parentNode.getBoundingClientRect();"
 W !,"        } else if (ie && cm.options.lineWrapping) {"
 W !,"          var rects = range(node, start, end).getClientRects();"
 W !,"          if (rects.length)"
 W !,"            rect = rects[bias == ""right"" ? rects.length - 1 : 0];"
 W !,"          else"
 W !,"            rect = nullRect;"
 W !,"        } else {"
 W !,"          rect = range(node, start, end).getBoundingClientRect() || nullRect;"
 W !,"        }"
 W !,"        if (rect.left || rect.right || start == 0) break;"
 W !,"        end = start;"
 W !,"        start = start - 1;"
 W !,"        collapse = ""right"";"
 W !,"      }"
 W !,"      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);"
 W !,"    } else { // If it is a widget, simply get the box for the whole widget."
 W !,"      if (start > 0) collapse = bias = ""right"";"
 W !,"      var rects;"
 W !,"      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)"
 W !,"        rect = rects[bias == ""right"" ? rects.length - 1 : 0];"
 W !,"      else"
 W !,"        rect = node.getBoundingClientRect();"
 W !,"    }"
 W !,"    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {"
 W !,"      var rSpan = node.parentNode.getClientRects()[0];"
 W !,"      if (rSpan)"
 W !,"        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};"
 W !,"      else"
 W !,"        rect = nullRect;"
 W !,"    }"

 W !,"    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;"
 W !,"    var mid = (rtop + rbot) / 2;"
 W !,"    var heights = prepared.view.measure.heights;"
 W !,"    for (var i = 0; i < heights.length - 1; i++)"
 W !,"      if (mid < heights[i]) break;"
 W !,"    var top = i ? heights[i - 1] : 0, bot = heights[i];"
 W !,"    var result = {left: (collapse == ""right"" ? rect.right : rect.left) - prepared.rect.left,"
 W !,"                  right: (collapse == ""left"" ? rect.left : rect.right) - prepared.rect.left,"
 W !,"                  top: top, bottom: bot};"
 W !,"    if (!rect.left && !rect.right) result.bogus = true;"
 W !,"    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }"

 W !,"    return result;"
 W !,"  }"

 W !,"  // Work around problem with bounding client rects on ranges being"
 W !,"  // returned incorrectly when zoomed on IE10 and below."
 W !,"  function maybeUpdateRectForZooming(measure, rect) {"
 W !,"    if (!window.screen || screen.logicalXDPI == null ||"
 W !,"        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))"
 W !,"      return rect;"
 W !,"    var scaleX = screen.logicalXDPI / screen.deviceXDPI;"
 W !,"    var scaleY = screen.logicalYDPI / screen.deviceYDPI;"
 W !,"    return {left: rect.left * scaleX, right: rect.right * scaleX,"
 W !,"            top: rect.top * scaleY, bottom: rect.bottom * scaleY};"
 W !,"  }"

 W !,"  function clearLineMeasurementCacheFor(lineView) {"
 W !,"    if (lineView.measure) {"
 W !,"      lineView.measure.cache = {};"
 W !,"      lineView.measure.heights = null;"
 W !,"      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)"
 W !,"        lineView.measure.caches[i] = {};"
 W !,"    }"
 W !,"  }"

 W !,"  function clearLineMeasurementCache(cm) {"
 W !,"    cm.display.externalMeasure = null;"
 W !,"    removeChildren(cm.display.lineMeasure);"
 W !,"    for (var i = 0; i < cm.display.view.length; i++)"
 W !,"      clearLineMeasurementCacheFor(cm.display.view[i]);"
 W !,"  }"

 W !,"  function clearCaches(cm) {"
 W !,"    clearLineMeasurementCache(cm);"
 W !,"    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;"
 W !,"    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;"
 W !,"    cm.display.lineNumChars = null;"
 W !,"  }"

 W !,"  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }"
 W !,"  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }"

 W !,"  // Converts a {top, bottom, left, right} box from line-local"
 W !,"  // coordinates into another coordinate system. Context may be one of"
 W !,"  // ""line"", ""div"" (display.lineDiv), ""local""/null (editor), ""window"","
 W !,"  // or ""page""."
 W !,"  function intoCoordSystem(cm, lineObj, rect, context) {"
 W !,"    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {"
 W !,"      var size = widgetHeight(lineObj.widgets[i]);"
 W !,"      rect.top += size; rect.bottom += size;"
 W !,"    }"
 W !,"    if (context == ""line"") return rect;"
 W !,"    if (!context) context = ""local"";"
 W !,"    var yOff = heightAtLine(lineObj);"
 W !,"    if (context == ""local"") yOff += paddingTop(cm.display);"
 W !,"    else yOff -= cm.display.viewOffset;"
 W !,"    if (context == ""page"" || context == ""window"") {"
 W !,"      var lOff = cm.display.lineSpace.getBoundingClientRect();"
 W !,"      yOff += lOff.top + (context == ""window"" ? 0 : pageScrollY());"
 W !,"      var xOff = lOff.left + (context == ""window"" ? 0 : pageScrollX());"
 W !,"      rect.left += xOff; rect.right += xOff;"
 W !,"    }"
 W !,"    rect.top += yOff; rect.bottom += yOff;"
 W !,"    return rect;"
 W !,"  }"

 W !,"  // Coverts a box from ""div"" coords to another coordinate system."
 W !,"  // Context may be ""window"", ""page"", ""div"", or ""local""/null."
 W !,"  function fromCoordSystem(cm, coords, context) {"
 W !,"    if (context == ""div"") return coords;"
 W !,"    var left = coords.left, top = coords.top;"
 W !,"    // First move into ""page"" coordinate system"
 W !,"    if (context == ""page"") {"
 W !,"      left -= pageScrollX();"
 W !,"      top -= pageScrollY();"
 W !,"    } else if (context == ""local"" || !context) {"
 W !,"      var localBox = cm.display.sizer.getBoundingClientRect();"
 W !,"      left += localBox.left;"
 W !,"      top += localBox.top;"
 W !,"    }"

 W !,"    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();"
 W !,"    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};"
 W !,"  }"

 W !,"  function charCoords(cm, pos, context, lineObj, bias) {"
 W !,"    if (!lineObj) lineObj = getLine(cm.doc, pos.line);"
 W !,"    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);"
 W !,"  }"

 W !,"  // Returns a box for a given cursor position, which may have an"
 W !,"  // 'other' property containing the position of the secondary cursor"
 W !,"  // on a bidi boundary."
 W !,"  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {"
 W !,"    lineObj = lineObj || getLine(cm.doc, pos.line);"
 W !,"    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);"
 W !,"    function get(ch, right) {"
 W !,"      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? ""right"" : ""left"", varHeight);"
 W !,"      if (right) m.left = m.right; else m.right = m.left;"
 W !,"      return intoCoordSystem(cm, lineObj, m, context);"
 W !,"    }"
 W !,"    function getBidi(ch, partPos) {"
 W !,"      var part = order[partPos], right = part.level % 2;"
 W !,"      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {"
 W !,"        part = order[--partPos];"
 W !,"        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);"
 W !,"        right = true;"
 W !,"      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {"
 W !,"        part = order[++partPos];"
 W !,"        ch = bidiLeft(part) - part.level % 2;"
 W !,"        right = false;"
 W !,"      }"
 W !,"      if (right && ch == part.to && ch > part.from) return get(ch - 1);"
 W !,"      return get(ch, right);"
 W !,"    }"
 W !,"    var order = getOrder(lineObj), ch = pos.ch;"
 W !,"    if (!order) return get(ch);"
 W !,"    var partPos = getBidiPartAt(order, ch);"
 W !,"    var val = getBidi(ch, partPos);"
 W !,"    if (bidiOther != null) val.other = getBidi(ch, bidiOther);"
 W !,"    return val;"
 W !,"  }"

 W !,"  // Used to cheaply estimate the coordinates for a position. Used for"
 W !,"  // intermediate scroll updates."
 W !,"  function estimateCoords(cm, pos) {"
 W !,"    var left = 0, pos = clipPos(cm.doc, pos);"
 W !,"    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;"
 W !,"    var lineObj = getLine(cm.doc, pos.line);"
 W !,"    var top = heightAtLine(lineObj) + paddingTop(cm.display);"
 W !,"    return {left: left, right: left, top: top, bottom: top + lineObj.height};"
 W !,"  }"

 W !,"  // Positions returned by coordsChar contain some extra information."
 W !,"  // xRel is the relative x position of the input coordinates compared"
 W !,"  // to the found position (so xRel > 0 means the coordinates are to"
 W !,"  // the right of the character position, for example). When outside"
 W !,"  // is true, that means the coordinates lie outside the line's"
 W !,"  // vertical range."
 W !,"  function PosWithInfo(line, ch, outside, xRel) {"
 W !,"    var pos = Pos(line, ch);"
 W !,"    pos.xRel = xRel;"
 W !,"    if (outside) pos.outside = true;"
 W !,"    return pos;"
 W !,"  }"

 W !,"  // Compute the character position closest to the given coordinates."
 W !,"  // Input must be lineSpace-local (""div"" coordinate system)."
 W !,"  function coordsChar(cm, x, y) {"
 W !,"    var doc = cm.doc;"
 W !,"    y += cm.display.viewOffset;"
 W !,"    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);"
 W !,"    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;"
 W !,"    if (lineN > last)"
 W !,"      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);"
 W !,"    if (x < 0) x = 0;"

 W !,"    var lineObj = getLine(doc, lineN);"
 W !,"    for (;;) {"
 W !,"      var found = coordsCharInner(cm, lineObj, lineN, x, y);"
 W !,"      var merged = collapsedSpanAtEnd(lineObj);"
 W !,"      var mergedPos = merged && merged.find(0, true);"
 W !,"      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))"
 W !,"        lineN = lineNo(lineObj = mergedPos.to.line);"
 W !,"      else"
 W !,"        return found;"
 W !,"    }"
 W !,"  }"

 W !,"  function coordsCharInner(cm, lineObj, lineNo, x, y) {"
 W !,"    var innerOff = y - heightAtLine(lineObj);"
 W !,"    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;"
 W !,"    var preparedMeasure = prepareMeasureForLine(cm, lineObj);"

 W !,"    function getX(ch) {"
 W !,"      var sp = cursorCoords(cm, Pos(lineNo, ch), ""line"", lineObj, preparedMeasure);"
 W !,"      wrongLine = true;"
 W !,"      if (innerOff > sp.bottom) return sp.left - adjust;"
 W !,"      else if (innerOff < sp.top) return sp.left + adjust;"
 W !,"      else wrongLine = false;"
 W !,"      return sp.left;"
 W !,"    }"

 W !,"    var bidi = getOrder(lineObj), dist = lineObj.text.length;"
 W !,"    var from = lineLeft(lineObj), to = lineRight(lineObj);"
 W !,"    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;"

 W !,"    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);"
 W !,"    // Do a binary search between these bounds."
 W !,"    for (;;) {"
 W !,"      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {"
 W !,"        var ch = x < fromX || x - fromX <= toX - x ? from : to;"
 W !,"        var xDiff = x - (ch == from ? fromX : toX);"
 W !,"        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;"
 W !,"        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,"
 W !,"                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);"
 W !,"        return pos;"
 W !,"      }"
 W !,"      var step = Math.ceil(dist / 2), middle = from + step;"
 W !,"      if (bidi) {"
 W !,"        middle = from;"
 W !,"        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);"
 W !,"      }"
 W !,"      var middleX = getX(middle);"
 W !,"      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}"
 W !,"      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}"
 W !,"    }"
 W !,"  }"

 W !,"  var measureText;"
 W !,"  // Compute the default text height."
 W !,"  function textHeight(display) {"
 W !,"    if (display.cachedTextHeight != null) return display.cachedTextHeight;"
 W !,"    if (measureText == null) {"
 W !,"      measureText = elt(""pre"");"
 W !,"      // Measure a bunch of lines, for browsers that compute"
 W !,"      // fractional heights."
 W !,"      for (var i = 0; i < 49; ++i) {"
 W !,"        measureText.appendChild(document.createTextNode(""x""));"
 W !,"        measureText.appendChild(elt(""br""));"
 W !,"      }"
 W !,"      measureText.appendChild(document.createTextNode(""x""));"
 W !,"    }"
 W !,"    removeChildrenAndAdd(display.measure, measureText);"
 W !,"    var height = measureText.offsetHeight / 50;"
 W !,"    if (height > 3) display.cachedTextHeight = height;"
 W !,"    removeChildren(display.measure);"
 W !,"    return height || 1;"
 W !,"  }"

 W !,"  // Compute the default character width."
 W !,"  function charWidth(display) {"
 W !,"    if (display.cachedCharWidth != null) return display.cachedCharWidth;"
 W !,"    var anchor = elt(""span"", ""xxxxxxxxxx"");"
 W !,"    var pre = elt(""pre"", [anchor]);"
 W !,"    removeChildrenAndAdd(display.measure, pre);"
 W !,"    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;"
 W !,"    if (width > 2) display.cachedCharWidth = width;"
 W !,"    return width || 10;"
 W !,"  }"

 W !,"  // OPERATIONS"

 W !,"  // Operations are used to wrap a series of changes to the editor"
 W !,"  // state in such a way that each change won't have to update the"
 W !,"  // cursor and display (which would be awkward, slow, and"
 W !,"  // error-prone). Instead, display updates are batched and then all"
 W !,"  // combined and executed at once."

 W !,"  var operationGroup = null;"

 W !,"  var nextOpId = 0;"
 W !,"  // Start a new operation."
 W !,"  function startOperation(cm) {"
 W !,"    cm.curOp = {"
 W !,"      cm: cm,"
 W !,"      viewChanged: false,      // Flag that indicates that lines might need to be redrawn"
 W !,"      startHeight: cm.doc.height, // Used to detect need to update scrollbar"
 W !,"      forceUpdate: false,      // Used to force a redraw"
 W !,"      updateInput: null,       // Whether to reset the input textarea"
 W !,"      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)"
 W !,"      changeObjs: null,        // Accumulated changes, for firing change events"
 W !,"      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on"
 W !,"      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already"
 W !,"      selectionChanged: false, // Whether the selection needs to be redrawn"
 W !,"      updateMaxLine: false,    // Set when the widest line needs to be determined anew"
 W !,"      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet"
 W !,"      scrollToPos: null,       // Used to scroll to a specific position"
 W !,"      focus: false,"
 W !,"      id: ++nextOpId           // Unique ID"
 W !,"    };"
 W !,"    if (operationGroup) {"
 W !,"      operationGroup.ops.push(cm.curOp);"
 W !,"    } else {"
 W !,"      cm.curOp.ownsGroup = operationGroup = {"
 W !,"        ops: [cm.curOp],"
 W !,"        delayedCallbacks: []"
 W !,"      };"
 W !,"    }"
 W !,"  }"

 W !,"  function fireCallbacksForOps(group) {"
 W !,"    // Calls delayed callbacks and cursorActivity handlers until no"
 W !,"    // new ones appear"
 W !,"    var callbacks = group.delayedCallbacks, i = 0;"
 W !,"    do {"
 W !,"      for (; i < callbacks.length; i++)"
 W !,"        callbacks[i].call(null);"
 W !,"      for (var j = 0; j < group.ops.length; j++) {"
 W !,"        var op = group.ops[j];"
 W !,"        if (op.cursorActivityHandlers)"
 W !,"          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)"
 W !,"            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);"
 W !,"      }"
 W !,"    } while (i < callbacks.length);"
 W !,"  }"

 W !,"  // Finish an operation, updating the display and signalling delayed events"
 W !,"  function endOperation(cm) {"
 W !,"    var op = cm.curOp, group = op.ownsGroup;"
 W !,"    if (!group) return;"

 W !,"    try { fireCallbacksForOps(group); }"
 W !,"    finally {"
 W !,"      operationGroup = null;"
 W !,"      for (var i = 0; i < group.ops.length; i++)"
 W !,"        group.ops[i].cm.curOp = null;"
 W !,"      endOperations(group);"
 W !,"    }"
 W !,"  }"

 W !,"  // The DOM updates done when an operation finishes are batched so"
 W !,"  // that the minimum number of relayouts are required."
 W !,"  function endOperations(group) {"
 W !,"    var ops = group.ops;"
 W !,"    for (var i = 0; i < ops.length; i++) // Read DOM"
 W !,"      endOperation_R1(ops[i]);"
 W !,"    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)"
 W !,"      endOperation_W1(ops[i]);"
 W !,"    for (var i = 0; i < ops.length; i++) // Read DOM"
 W !,"      endOperation_R2(ops[i]);"
 W !,"    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)"
 W !,"      endOperation_W2(ops[i]);"
 W !,"    for (var i = 0; i < ops.length; i++) // Read DOM"
 W !,"      endOperation_finish(ops[i]);"
 W !,"  }"

 W !,"  function endOperation_R1(op) {"
 W !,"    var cm = op.cm, display = cm.display;"
 W !,"    maybeClipScrollbars(cm);"
 W !,"    if (op.updateMaxLine) findMaxLine(cm);"

 W !,"    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||"
 W !,"      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||"
 W !,"                         op.scrollToPos.to.line >= display.viewTo) ||"
 W !,"      display.maxLineChanged && cm.options.lineWrapping;"
 W !,"    op.update = op.mustUpdate &&"
 W !,"      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);"
 W !,"  }"

 W !,"  function endOperation_W1(op) {"
 W !,"    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);"
 W !,"  }"

 W !,"  function endOperation_R2(op) {"
 W !,"    var cm = op.cm, display = cm.display;"
 W !,"    if (op.updatedDisplay) updateHeightsInViewport(cm);"

 W !,"    op.barMeasure = measureForScrollbars(cm);"

 W !,"    // If the max line changed since it was last measured, measure it,"
 W !,"    // and ensure the document's width matches it."
 W !,"    // updateDisplay_W2 will use these properties to do the actual resizing"
 W !,"    if (display.maxLineChanged && !cm.options.lineWrapping) {"
 W !,"      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;"
 W !,"      cm.display.sizerWidth = op.adjustWidthTo;"
 W !,"      op.barMeasure.scrollWidth ="
 W !,"        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);"
 W !,"      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));"
 W !,"    }"

 W !,"    if (op.updatedDisplay || op.selectionChanged)"
 W !,"      op.preparedSelection = display.input.prepareSelection(op.focus);"
 W !,"  }"

 W !,"  function endOperation_W2(op) {"
 W !,"    var cm = op.cm;"

 W !,"    if (op.adjustWidthTo != null) {"
 W !,"      cm.display.sizer.style.minWidth = op.adjustWidthTo + ""px"";"
 W !,"      if (op.maxScrollLeft < cm.doc.scrollLeft)"
 W !,"        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);"
 W !,"      cm.display.maxLineChanged = false;"
 W !,"    }"

 W !,"    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())"
 W !,"    if (op.preparedSelection)"
 W !,"      cm.display.input.showSelection(op.preparedSelection, takeFocus);"
 W !,"    if (op.updatedDisplay || op.startHeight != cm.doc.height)"
 W !,"      updateScrollbars(cm, op.barMeasure);"
 W !,"    if (op.updatedDisplay)"
 W !,"      setDocumentHeight(cm, op.barMeasure);"

 W !,"    if (op.selectionChanged) restartBlink(cm);"

 W !,"    if (cm.state.focused && op.updateInput)"
 W !,"      cm.display.input.reset(op.typing);"
 W !,"    if (takeFocus) ensureFocus(op.cm);"
 W !,"  }"

 W !,"  function endOperation_finish(op) {"
 W !,"    var cm = op.cm, display = cm.display, doc = cm.doc;"

 W !,"    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);"

 W !,"    // Abort mouse wheel delta measurement, when scrolling explicitly"
 W !,"    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))"
 W !,"      display.wheelStartX = display.wheelStartY = null;"

 W !,"    // Propagate the scroll position to the actual DOM scroller"
 W !,"    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {"
 W !,"      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));"
 W !,"      display.scrollbars.setScrollTop(doc.scrollTop);"
 W !,"      display.scroller.scrollTop = doc.scrollTop;"
 W !,"    }"
 W !,"    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {"
 W !,"      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));"
 W !,"      display.scrollbars.setScrollLeft(doc.scrollLeft);"
 W !,"      display.scroller.scrollLeft = doc.scrollLeft;"
 W !,"      alignHorizontally(cm);"
 W !,"    }"
 W !,"    // If we need to scroll a specific position into view, do so."
 W !,"    if (op.scrollToPos) {"
 W !,"      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),"
 W !,"                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);"
 W !,"      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);"
 W !,"    }"

 W !,"    // Fire events for markers that are hidden/unidden by editing or"
 W !,"    // undoing"
 W !,"    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;"
 W !,"    if (hidden) for (var i = 0; i < hidden.length; ++i)"
 W !,"      if (!hidden[i].lines.length) signal(hidden[i], ""hide"");"
 W !,"    if (unhidden) for (var i = 0; i < unhidden.length; ++i)"
 W !,"      if (unhidden[i].lines.length) signal(unhidden[i], ""unhide"");"

 W !,"    if (display.wrapper.offsetHeight)"
 W !,"      doc.scrollTop = cm.display.scroller.scrollTop;"

 W !,"    // Fire change events, and delayed event handlers"
 W !,"    if (op.changeObjs)"
 W !,"      signal(cm, ""changes"", cm, op.changeObjs);"
 W !,"    if (op.update)"
 W !,"      op.update.finish();"
 W !,"  }"

 W !,"  // Run the given function in an operation"
 W !,"  function runInOp(cm, f) {"
 W !,"    if (cm.curOp) return f();"
 W !,"    startOperation(cm);"
 W !,"    try { return f(); }"
 W !,"    finally { endOperation(cm); }"
 W !,"  }"
 W !,"  // Wraps a function in an operation. Returns the wrapped function."
 W !,"  function operation(cm, f) {"
 W !,"    return function() {"
 W !,"      if (cm.curOp) return f.apply(cm, arguments);"
 W !,"      startOperation(cm);"
 W !,"      try { return f.apply(cm, arguments); }"
 W !,"      finally { endOperation(cm); }"
 W !,"    };"
 W !,"  }"
 W !,"  // Used to add methods to editor and doc instances, wrapping them in"
 W !,"  // operations."
 W !,"  function methodOp(f) {"
 W !,"    return function() {"
 W !,"      if (this.curOp) return f.apply(this, arguments);"
 W !,"      startOperation(this);"
 W !,"      try { return f.apply(this, arguments); }"
 W !,"      finally { endOperation(this); }"
 W !,"    };"
 W !,"  }"
 W !,"  function docMethodOp(f) {"
 W !,"    return function() {"
 W !,"      var cm = this.cm;"
 W !,"      if (!cm || cm.curOp) return f.apply(this, arguments);"
 W !,"      startOperation(cm);"
 W !,"      try { return f.apply(this, arguments); }"
 W !,"      finally { endOperation(cm); }"
 W !,"    };"
 W !,"  }"

 W !,"  // VIEW TRACKING"

 W !,"  // These objects are used to represent the visible (currently drawn)"
 W !,"  // part of the document. A LineView may correspond to multiple"
 W !,"  // logical lines, if those are connected by collapsed ranges."
 W !,"  function LineView(doc, line, lineN) {"
 W !,"    // The starting line"
 W !,"    this.line = line;"
 W !,"    // Continuing lines, if any"
 W !,"    this.rest = visualLineContinued(line);"
 W !,"    // Number of logical lines in this visual line"
 W !,"    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;"
 W !,"    this.node = this.text = null;"
 W !,"    this.hidden = lineIsHidden(doc, line);"
 W !,"  }"

 W !,"  // Create a range of LineView objects for the given lines."
 W !,"  function buildViewArray(cm, from, to) {"
 W !,"    var array = [], nextPos;"
 W !,"    for (var pos = from; pos < to; pos = nextPos) {"
 W !,"      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);"
 W !,"      nextPos = pos + view.size;"
 W !,"      array.push(view);"
 W !,"    }"
 W !,"    return array;"
 W !,"  }"

 W !,"  // Updates the display.view data structure for a given change to the"
 W !,"  // document. From and to are in pre-change coordinates. Lendiff is"
 W !,"  // the amount of lines added or subtracted by the change. This is"
 W !,"  // used for changes that span multiple lines, or change the way"
 W !,"  // lines are divided into visual lines. regLineChange (below)"
 W !,"  // registers single-line changes."
 W !,"  function regChange(cm, from, to, lendiff) {"
 W !,"    if (from == null) from = cm.doc.first;"
 W !,"    if (to == null) to = cm.doc.first + cm.doc.size;"
 W !,"    if (!lendiff) lendiff = 0;"

 W !,"    var display = cm.display;"
 W !,"    if (lendiff && to < display.viewTo &&"
 W !,"        (display.updateLineNumbers == null || display.updateLineNumbers > from))"
 W !,"      display.updateLineNumbers = from;"

 W !,"    cm.curOp.viewChanged = true;"

 W !,"    if (from >= display.viewTo) { // Change after"
 W !,"      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)"
 W !,"        resetView(cm);"
 W !,"    } else if (to <= display.viewFrom) { // Change before"
 W !,"      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {"
 W !,"        resetView(cm);"
 W !,"      } else {"
 W !,"        display.viewFrom += lendiff;"
 W !,"        display.viewTo += lendiff;"
 W !,"      }"
 W !,"    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap"
 W !,"      resetView(cm);"
 W !,"    } else if (from <= display.viewFrom) { // Top overlap"
 W !,"      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);"
 W !,"      if (cut) {"
 W !,"        display.view = display.view.slice(cut.index);"
 W !,"        display.viewFrom = cut.lineN;"
 W !,"        display.viewTo += lendiff;"
 W !,"      } else {"
 W !,"        resetView(cm);"
 W !,"      }"
 W !,"    } else if (to >= display.viewTo) { // Bottom overlap"
 W !,"      var cut = viewCuttingPoint(cm, from, from, -1);"
 W !,"      if (cut) {"
 W !,"        display.view = display.view.slice(0, cut.index);"
 W !,"        display.viewTo = cut.lineN;"
 W !,"      } else {"
 W !,"        resetView(cm);"
 W !,"      }"
 W !,"    } else { // Gap in the middle"
 W !,"      var cutTop = viewCuttingPoint(cm, from, from, -1);"
 W !,"      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);"
 W !,"      if (cutTop && cutBot) {"
 W !,"        display.view = display.view.slice(0, cutTop.index)"
 W !,"          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))"
 W !,"          .concat(display.view.slice(cutBot.index));"
 W !,"        display.viewTo += lendiff;"
 W !,"      } else {"
 W !,"        resetView(cm);"
 W !,"      }"
 W !,"    }"

 W !,"    var ext = display.externalMeasured;"
 W !,"    if (ext) {"
 W !,"      if (to < ext.lineN)"
 W !,"        ext.lineN += lendiff;"
 W !,"      else if (from < ext.lineN + ext.size)"
 W !,"        display.externalMeasured = null;"
 W !,"    }"
 W !,"  }"
}

ClassMethod ScriptLibCodemirror6()
{
 W !,"  // Register a change to a single line. Type must be one of ""text"","
 W !,"  // ""gutter"", ""class"", ""widget"""
 W !,"  function regLineChange(cm, line, type) {"
 W !,"    cm.curOp.viewChanged = true;"
 W !,"    var display = cm.display, ext = cm.display.externalMeasured;"
 W !,"    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)"
 W !,"      display.externalMeasured = null;"

 W !,"    if (line < display.viewFrom || line >= display.viewTo) return;"
 W !,"    var lineView = display.view[findViewIndex(cm, line)];"
 W !,"    if (lineView.node == null) return;"
 W !,"    var arr = lineView.changes || (lineView.changes = []);"
 W !,"    if (indexOf(arr, type) == -1) arr.push(type);"
 W !,"  }"

 W !,"  // Clear the view."
 W !,"  function resetView(cm) {"
 W !,"    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;"
 W !,"    cm.display.view = [];"
 W !,"    cm.display.viewOffset = 0;"
 W !,"  }"

 W !,"  // Find the view element corresponding to a given line. Return null"
 W !,"  // when the line isn't visible."
 W !,"  function findViewIndex(cm, n) {"
 W !,"    if (n >= cm.display.viewTo) return null;"
 W !,"    n -= cm.display.viewFrom;"
 W !,"    if (n < 0) return null;"
 W !,"    var view = cm.display.view;"
 W !,"    for (var i = 0; i < view.length; i++) {"
 W !,"      n -= view[i].size;"
 W !,"      if (n < 0) return i;"
 W !,"    }"
 W !,"  }"

 W !,"  function viewCuttingPoint(cm, oldN, newN, dir) {"
 W !,"    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;"
 W !,"    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)"
 W !,"      return {index: index, lineN: newN};"
 W !,"    for (var i = 0, n = cm.display.viewFrom; i < index; i++)"
 W !,"      n += view[i].size;"
 W !,"    if (n != oldN) {"
 W !,"      if (dir > 0) {"
 W !,"        if (index == view.length - 1) return null;"
 W !,"        diff = (n + view[index].size) - oldN;"
 W !,"        index++;"
 W !,"      } else {"
 W !,"        diff = n - oldN;"
 W !,"      }"
 W !,"      oldN += diff; newN += diff;"
 W !,"    }"
 W !,"    while (visualLineNo(cm.doc, newN) != newN) {"
 W !,"      if (index == (dir < 0 ? 0 : view.length - 1)) return null;"
 W !,"      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;"
 W !,"      index += dir;"
 W !,"    }"
 W !,"    return {index: index, lineN: newN};"
 W !,"  }"

 W !,"  // Force the view to cover a given range, adding empty view element"
 W !,"  // or clipping off existing ones as needed."
 W !,"  function adjustView(cm, from, to) {"
 W !,"    var display = cm.display, view = display.view;"
 W !,"    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {"
 W !,"      display.view = buildViewArray(cm, from, to);"
 W !,"      display.viewFrom = from;"
 W !,"    } else {"
 W !,"      if (display.viewFrom > from)"
 W !,"        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);"
 W !,"      else if (display.viewFrom < from)"
 W !,"        display.view = display.view.slice(findViewIndex(cm, from));"
 W !,"      display.viewFrom = from;"
 W !,"      if (display.viewTo < to)"
 W !,"        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));"
 W !,"      else if (display.viewTo > to)"
 W !,"        display.view = display.view.slice(0, findViewIndex(cm, to));"
 W !,"    }"
 W !,"    display.viewTo = to;"
 W !,"  }"

 W !,"  // Count the number of lines in the view whose DOM representation is"
 W !,"  // out of date (or nonexistent)."
 W !,"  function countDirtyView(cm) {"
 W !,"    var view = cm.display.view, dirty = 0;"
 W !,"    for (var i = 0; i < view.length; i++) {"
 W !,"      var lineView = view[i];"
 W !,"      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;"
 W !,"    }"
 W !,"    return dirty;"
 W !,"  }"

 W !,"  // EVENT HANDLERS"

 W !,"  // Attach the necessary event handlers when initializing the editor"
 W !,"  function registerEventHandlers(cm) {"
 W !,"    var d = cm.display;"
 W !,"    on(d.scroller, ""mousedown"", operation(cm, onMouseDown));"
 W !,"    // Older IE's will not fire a second mousedown for a double click"
 W !,"    if (ie && ie_version < 11)"
 W !,"      on(d.scroller, ""dblclick"", operation(cm, function(e) {"
 W !,"        if (signalDOMEvent(cm, e)) return;"
 W !,"        var pos = posFromMouse(cm, e);"
 W !,"        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;"
 W !,"        e_preventDefault(e);"
 W !,"        var word = cm.findWordAt(pos);"
 W !,"        extendSelection(cm.doc, word.anchor, word.head);"
 W !,"      }));"
 W !,"    else"
 W !,"      on(d.scroller, ""dblclick"", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });"
 W !,"    // Some browsers fire contextmenu *after* opening the menu, at"
 W !,"    // which point we can't mess with it anymore. Context menu is"
 W !,"    // handled in onMouseDown for these browsers."
 W !,"    if (!captureRightClick) on(d.scroller, ""contextmenu"", function(e) {onContextMenu(cm, e);});"

 W !,"    // Used to suppress mouse event handling when a touch happens"
 W !,"    var touchFinished, prevTouch = {end: 0};"
 W !,"    function finishTouch() {"
 W !,"      if (d.activeTouch) {"
 W !,"        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);"
 W !,"        prevTouch = d.activeTouch;"
 W !,"        prevTouch.end = +new Date;"
 W !,"      }"
 W !,"    };"
 W !,"    function isMouseLikeTouchEvent(e) {"
 W !,"      if (e.touches.length != 1) return false;"
 W !,"      var touch = e.touches[0];"
 W !,"      return touch.radiusX <= 1 && touch.radiusY <= 1;"
 W !,"    }"
 W !,"    function farAway(touch, other) {"
 W !,"      if (other.left == null) return true;"
 W !,"      var dx = other.left - touch.left, dy = other.top - touch.top;"
 W !,"      return dx * dx + dy * dy > 20 * 20;"
 W !,"    }"
 W !,"    on(d.scroller, ""touchstart"", function(e) {"
 W !,"      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {"
 W !,"        clearTimeout(touchFinished);"
 W !,"        var now = +new Date;"
 W !,"        d.activeTouch = {start: now, moved: false,"
 W !,"                         prev: now - prevTouch.end <= 300 ? prevTouch : null};"
 W !,"        if (e.touches.length == 1) {"
 W !,"          d.activeTouch.left = e.touches[0].pageX;"
 W !,"          d.activeTouch.top = e.touches[0].pageY;"
 W !,"        }"
 W !,"      }"
 W !,"    });"
 W !,"    on(d.scroller, ""touchmove"", function() {"
 W !,"      if (d.activeTouch) d.activeTouch.moved = true;"
 W !,"    });"
 W !,"    on(d.scroller, ""touchend"", function(e) {"
 W !,"      var touch = d.activeTouch;"
 W !,"      if (touch && !eventInWidget(d, e) && touch.left != null &&"
 W !,"          !touch.moved && new Date - touch.start < 300) {"
 W !,"        var pos = cm.coordsChar(d.activeTouch, ""page""), range;"
 W !,"        if (!touch.prev || farAway(touch, touch.prev)) // Single tap"
 W !,"          range = new Range(pos, pos);"
 W !,"        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap"
 W !,"          range = cm.findWordAt(pos);"
 W !,"        else // Triple tap"
 W !,"          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));"
 W !,"        cm.setSelection(range.anchor, range.head);"
 W !,"        cm.focus();"
 W !,"        e_preventDefault(e);"
 W !,"      }"
 W !,"      finishTouch();"
 W !,"    });"
 W !,"    on(d.scroller, ""touchcancel"", finishTouch);"

 W !,"    // Sync scrolling between fake scrollbars and real scrollable"
 W !,"    // area, ensure viewport is updated when scrolling."
 W !,"    on(d.scroller, ""scroll"", function() {"
 W !,"      if (d.scroller.clientHeight) {"
 W !,"        setScrollTop(cm, d.scroller.scrollTop);"
 W !,"        setScrollLeft(cm, d.scroller.scrollLeft, true);"
 W !,"        signal(cm, ""scroll"", cm);"
 W !,"      }"
 W !,"    });"

 W !,"    // Listen to wheel events in order to try and update the viewport on time."
 W !,"    on(d.scroller, ""mousewheel"", function(e){onScrollWheel(cm, e);});"
 W !,"    on(d.scroller, ""DOMMouseScroll"", function(e){onScrollWheel(cm, e);});"

 W !,"    // Prevent wrapper from ever scrolling"
 W !,"    on(d.wrapper, ""scroll"", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });"

 W !,"    d.dragFunctions = {"
 W !,"      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},"
 W !,"      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},"
 W !,"      start: function(e){onDragStart(cm, e);},"
 W !,"      drop: operation(cm, onDrop),"
 W !,"      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}"
 W !,"    };"

 W !,"    var inp = d.input.getField();"
 W !,"    on(inp, ""keyup"", function(e) { onKeyUp.call(cm, e); });"
 W !,"    on(inp, ""keydown"", operation(cm, onKeyDown));"
 W !,"    on(inp, ""keypress"", operation(cm, onKeyPress));"
 W !,"    on(inp, ""focus"", bind(onFocus, cm));"
 W !,"    on(inp, ""blur"", bind(onBlur, cm));"
 W !,"  }"

 W !,"  function dragDropChanged(cm, value, old) {"
 W !,"    var wasOn = old && old != CodeMirror.Init;"
 W !,"    if (!value != !wasOn) {"
 W !,"      var funcs = cm.display.dragFunctions;"
 W !,"      var toggle = value ? on : off;"
 W !,"      toggle(cm.display.scroller, ""dragstart"", funcs.start);"
 W !,"      toggle(cm.display.scroller, ""dragenter"", funcs.enter);"
 W !,"      toggle(cm.display.scroller, ""dragover"", funcs.over);"
 W !,"      toggle(cm.display.scroller, ""dragleave"", funcs.leave);"
 W !,"      toggle(cm.display.scroller, ""drop"", funcs.drop);"
 W !,"    }"
 W !,"  }"

 W !,"  // Called when the window resizes"
 W !,"  function onResize(cm) {"
 W !,"    var d = cm.display;"
 W !,"    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)"
 W !,"      return;"
 W !,"    // Might be a text scaling operation, clear size caches."
 W !,"    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;"
 W !,"    d.scrollbarsClipped = false;"
 W !,"    cm.setSize();"
 W !,"  }"

 W !,"  // MOUSE EVENTS"

 W !,"  // Return true when the given mouse event happened in a widget"
 W !,"  function eventInWidget(display, e) {"
 W !,"    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {"
 W !,"      if (!n || (n.nodeType == 1 && n.getAttribute(""cm-ignore-events"") == ""true"") ||"
 W !,"          (n.parentNode == display.sizer && n != display.mover))"
 W !,"        return true;"
 W !,"    }"
 W !,"  }"

 W !,"  // Given a mouse event, find the corresponding position. If liberal"
 W !,"  // is false, it checks whether a gutter or scrollbar was clicked,"
 W !,"  // and returns null if it was. forRect is used by rectangular"
 W !,"  // selections, and tries to estimate a character position even for"
 W !,"  // coordinates beyond the right of the text."
 W !,"  function posFromMouse(cm, e, liberal, forRect) {"
 W !,"    var display = cm.display;"
 W !,"    if (!liberal && e_target(e).getAttribute(""cm-not-content"") == ""true"") return null;"

 W !,"    var x, y, space = display.lineSpace.getBoundingClientRect();"
 W !,"    // Fails unpredictably on IE[67] when mouse is dragged around quickly."
 W !,"    try { x = e.clientX - space.left; y = e.clientY - space.top; }"
 W !,"    catch (e) { return null; }"
 W !,"    var coords = coordsChar(cm, x, y), line;"
 W !,"    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {"
 W !,"      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;"
 W !,"      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));"
 W !,"    }"
 W !,"    return coords;"
 W !,"  }"

 W !,"  // A mouse down can be a single click, double click, triple click,"
 W !,"  // start of selection drag, start of text drag, new cursor"
 W !,"  // (ctrl-click), rectangle drag (alt-drag), or xwin"
 W !,"  // middle-click-paste. Or it might be a click on something we should"
 W !,"  // not interfere with, such as a scrollbar or widget."
 W !,"  function onMouseDown(e) {"
 W !,"    var cm = this, display = cm.display;"
 W !,"    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;"
 W !,"    display.shift = e.shiftKey;"

 W !,"    if (eventInWidget(display, e)) {"
 W !,"      if (!webkit) {"
 W !,"        // Briefly turn off draggability, to allow widgets to do"
 W !,"        // normal dragging things."
 W !,"        display.scroller.draggable = false;"
 W !,"        setTimeout(function(){display.scroller.draggable = true;}, 100);"
 W !,"      }"
 W !,"      return;"
 W !,"    }"
 W !,"    if (clickInGutter(cm, e)) return;"
 W !,"    var start = posFromMouse(cm, e);"
 W !,"    window.focus();"

 W !,"    switch (e_button(e)) {"
 W !,"    case 1:"
 W !,"      // #3261: make sure, that we're not starting a second selection"
 W !,"      if (cm.state.selectingText)"
 W !,"        cm.state.selectingText(e);"
 W !,"      else if (start)"
 W !,"        leftButtonDown(cm, e, start);"
 W !,"      else if (e_target(e) == display.scroller)"
 W !,"        e_preventDefault(e);"
 W !,"      break;"
 W !,"    case 2:"
 W !,"      if (webkit) cm.state.lastMiddleDown = +new Date;"
 W !,"      if (start) extendSelection(cm.doc, start);"
 W !,"      setTimeout(function() {display.input.focus();}, 20);"
 W !,"      e_preventDefault(e);"
 W !,"      break;"
 W !,"    case 3:"
 W !,"      if (captureRightClick) onContextMenu(cm, e);"
 W !,"      else delayBlurEvent(cm);"
 W !,"      break;"
 W !,"    }"
 W !,"  }"

 W !,"  var lastClick, lastDoubleClick;"
 W !,"  function leftButtonDown(cm, e, start) {"
 W !,"    if (ie) setTimeout(bind(ensureFocus, cm), 0);"
 W !,"    else cm.curOp.focus = activeElt();"

 W !,"    var now = +new Date, type;"
 W !,"    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {"
 W !,"      type = ""triple"";"
 W !,"    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {"
 W !,"      type = ""double"";"
 W !,"      lastDoubleClick = {time: now, pos: start};"
 W !,"    } else {"
 W !,"      type = ""single"";"
 W !,"      lastClick = {time: now, pos: start};"
 W !,"    }"

 W !,"    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;"
 W !,"    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&"
 W !,"        type == ""single"" && (contained = sel.contains(start)) > -1 &&"
 W !,"        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&"
 W !,"        (cmp(contained.to(), start) > 0 || start.xRel < 0))"
 W !,"      leftButtonStartDrag(cm, e, start, modifier);"
 W !,"    else"
 W !,"      leftButtonSelect(cm, e, start, type, modifier);"
 W !,"  }"

 W !,"  // Start a text drag. When it ends, see if any dragging actually"
 W !,"  // happen, and treat as a click if it didn't."
 W !,"  function leftButtonStartDrag(cm, e, start, modifier) {"
 W !,"    var display = cm.display, startTime = +new Date;"
 W !,"    var dragEnd = operation(cm, function(e2) {"
 W !,"      if (webkit) display.scroller.draggable = false;"
 W !,"      cm.state.draggingText = false;"
 W !,"      off(document, ""mouseup"", dragEnd);"
 W !,"      off(display.scroller, ""drop"", dragEnd);"
 W !,"      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {"
 W !,"        e_preventDefault(e2);"
 W !,"        if (!modifier && +new Date - 200 < startTime)"
 W !,"          extendSelection(cm.doc, start);"
 W !,"        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)"
 W !,"        if (webkit || ie && ie_version == 9)"
 W !,"          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);"
 W !,"        else"
 W !,"          display.input.focus();"
 W !,"      }"
 W !,"    });"
 W !,"    // Let the drag handler handle this."
 W !,"    if (webkit) display.scroller.draggable = true;"
 W !,"    cm.state.draggingText = dragEnd;"
 W !,"    // IE's approach to draggable"
 W !,"    if (display.scroller.dragDrop) display.scroller.dragDrop();"
 W !,"    on(document, ""mouseup"", dragEnd);"
 W !,"    on(display.scroller, ""drop"", dragEnd);"
 W !,"  }"

 W !,"  // Normal selection, as opposed to text dragging."
 W !,"  function leftButtonSelect(cm, e, start, type, addNew) {"
 W !,"    var display = cm.display, doc = cm.doc;"
 W !,"    e_preventDefault(e);"

 W !,"    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;"
 W !,"    if (addNew && !e.shiftKey) {"
 W !,"      ourIndex = doc.sel.contains(start);"
 W !,"      if (ourIndex > -1)"
 W !,"        ourRange = ranges[ourIndex];"
 W !,"      else"
 W !,"        ourRange = new Range(start, start);"
 W !,"    } else {"
 W !,"      ourRange = doc.sel.primary();"
 W !,"      ourIndex = doc.sel.primIndex;"
 W !,"    }"

 W !,"    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {"
 W !,"      type = ""rect"";"
 W !,"      if (!addNew) ourRange = new Range(start, start);"
 W !,"      start = posFromMouse(cm, e, true, true);"
 W !,"      ourIndex = -1;"
 W !,"    } else if (type == ""double"") {"
 W !,"      var word = cm.findWordAt(start);"
 W !,"      if (cm.display.shift || doc.extend)"
 W !,"        ourRange = extendRange(doc, ourRange, word.anchor, word.head);"
 W !,"      else"
 W !,"        ourRange = word;"
 W !,"    } else if (type == ""triple"") {"
 W !,"      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));"
 W !,"      if (cm.display.shift || doc.extend)"
 W !,"        ourRange = extendRange(doc, ourRange, line.anchor, line.head);"
 W !,"      else"
 W !,"        ourRange = line;"
 W !,"    } else {"
 W !,"      ourRange = extendRange(doc, ourRange, start);"
 W !,"    }"

 W !,"    if (!addNew) {"
 W !,"      ourIndex = 0;"
 W !,"      setSelection(doc, new Selection([ourRange], 0), sel_mouse);"
 W !,"      startSel = doc.sel;"
 W !,"    } else if (ourIndex == -1) {"
 W !,"      ourIndex = ranges.length;"
 W !,"      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),"
 W !,"                   {scroll: false, origin: ""*mouse""});"
 W !,"    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == ""single"" && !e.shiftKey) {"
 W !,"      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),"
 W !,"                   {scroll: false, origin: ""*mouse""});"
 W !,"      startSel = doc.sel;"
 W !,"    } else {"
 W !,"      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);"
 W !,"    }"

 W !,"    var lastPos = start;"
 W !,"    function extendTo(pos) {"
 W !,"      if (cmp(lastPos, pos) == 0) return;"
 W !,"      lastPos = pos;"

 W !,"      if (type == ""rect"") {"
 W !,"        var ranges = [], tabSize = cm.options.tabSize;"
 W !,"        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);"
 W !,"        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);"
 W !,"        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);"
 W !,"        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));"
 W !,"             line <= end; line++) {"
 W !,"          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);"
 W !,"          if (left == right)"
 W !,"            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));"
 W !,"          else if (text.length > leftPos)"
 W !,"            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));"
 W !,"        }"
 W !,"        if (!ranges.length) ranges.push(new Range(start, start));"
 W !,"        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),"
 W !,"                     {origin: ""*mouse"", scroll: false});"
 W !,"        cm.scrollIntoView(pos);"
 W !,"      } else {"
 W !,"        var oldRange = ourRange;"
 W !,"        var anchor = oldRange.anchor, head = pos;"
 W !,"        if (type != ""single"") {"
 W !,"          if (type == ""double"")"
 W !,"            var range = cm.findWordAt(pos);"
 W !,"          else"
 W !,"            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));"
 W !,"          if (cmp(range.anchor, anchor) > 0) {"
 W !,"            head = range.head;"
 W !,"            anchor = minPos(oldRange.from(), range.anchor);"
 W !,"          } else {"
 W !,"            head = range.anchor;"
 W !,"            anchor = maxPos(oldRange.to(), range.head);"
 W !,"          }"
 W !,"        }"
 W !,"        var ranges = startSel.ranges.slice(0);"
 W !,"        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);"
 W !,"        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);"
 W !,"      }"
 W !,"    }"

 W !,"    var editorSize = display.wrapper.getBoundingClientRect();"
 W !,"    // Used to ensure timeout re-tries don't fire when another extend"
 W !,"    // happened in the meantime (clearTimeout isn't reliable -- at"
 W !,"    // least on Chrome, the timeouts still happen even when cleared,"
 W !,"    // if the clear happens after their scheduled firing time)."
 W !,"    var counter = 0;"

 W !,"    function extend(e) {"
 W !,"      var curCount = ++counter;"
 W !,"      var cur = posFromMouse(cm, e, true, type == ""rect"");"
 W !,"      if (!cur) return;"
 W !,"      if (cmp(cur, lastPos) != 0) {"
 W !,"        cm.curOp.focus = activeElt();"
 W !,"        extendTo(cur);"
 W !,"        var visible = visibleLines(display, doc);"
 W !,"        if (cur.line >= visible.to || cur.line < visible.from)"
 W !,"          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);"
 W !,"      } else {"
 W !,"        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;"
 W !,"        if (outside) setTimeout(operation(cm, function() {"
 W !,"          if (counter != curCount) return;"
 W !,"          display.scroller.scrollTop += outside;"
 W !,"          extend(e);"
 W !,"        }), 50);"
 W !,"      }"
 W !,"    }"

 W !,"    function done(e) {"
 W !,"      cm.state.selectingText = false;"
 W !,"      counter = Infinity;"
 W !,"      e_preventDefault(e);"
 W !,"      display.input.focus();"
 W !,"      off(document, ""mousemove"", move);"
 W !,"      off(document, ""mouseup"", up);"
 W !,"      doc.history.lastSelOrigin = null;"
 W !,"    }"

 W !,"    var move = operation(cm, function(e) {"
 W !,"      if (!e_button(e)) done(e);"
 W !,"      else extend(e);"
 W !,"    });"
 W !,"    var up = operation(cm, done);"
 W !,"    cm.state.selectingText = up;"
 W !,"    on(document, ""mousemove"", move);"
 W !,"    on(document, ""mouseup"", up);"
 W !,"  }"

 W !,"  // Determines whether an event happened in the gutter, and fires the"
 W !,"  // handlers for the corresponding event."
 W !,"  function gutterEvent(cm, e, type, prevent) {"
 W !,"    try { var mX = e.clientX, mY = e.clientY; }"
 W !,"    catch(e) { return false; }"
 W !,"    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;"
 W !,"    if (prevent) e_preventDefault(e);"

 W !,"    var display = cm.display;"
 W !,"    var lineBox = display.lineDiv.getBoundingClientRect();"

 W !,"    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);"
 W !,"    mY -= lineBox.top - display.viewOffset;"

 W !,"    for (var i = 0; i < cm.options.gutters.length; ++i) {"
 W !,"      var g = display.gutters.childNodes[i];"
 W !,"      if (g && g.getBoundingClientRect().right >= mX) {"
 W !,"        var line = lineAtHeight(cm.doc, mY);"
 W !,"        var gutter = cm.options.gutters[i];"
 W !,"        signal(cm, type, cm, line, gutter, e);"
 W !,"        return e_defaultPrevented(e);"
 W !,"      }"
 W !,"    }"
 W !,"  }"

 W !,"  function clickInGutter(cm, e) {"
 W !,"    return gutterEvent(cm, e, ""gutterClick"", true);"
 W !,"  }"

 W !,"  // Kludge to work around strange IE behavior where it'll sometimes"
 W !,"  // re-fire a series of drag-related events right after the drop (#1551)"
 W !,"  var lastDrop = 0;"

 W !,"  function onDrop(e) {"
 W !,"    var cm = this;"
 W !,"    clearDragCursor(cm);"
 W !,"    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))"
 W !,"      return;"
 W !,"    e_preventDefault(e);"
 W !,"    if (ie) lastDrop = +new Date;"
 W !,"    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;"
 W !,"    if (!pos || cm.isReadOnly()) return;"
 W !,"    // Might be a file drop, in which case we simply extract the text"
 W !,"    // and insert it."
 W !,"    if (files && files.length && window.FileReader && window.File) {"
 W !,"      var n = files.length, text = Array(n), read = 0;"
 W !,"      var loadFile = function(file, i) {"
 W !,"        if (cm.options.allowDropFileTypes &&"
 W !,"            indexOf(cm.options.allowDropFileTypes, file.type) == -1)"
 W !,"          return;"

 W !,"        var reader = new FileReader;"
 W !,"        reader.onload = operation(cm, function() {"
 W !,"          var content = reader.result;"
 W !,"          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = """";"
 W !,"          text[i] = content;"
 W !,"          if (++read == n) {"
 W !,"            pos = clipPos(cm.doc, pos);"
 W !,"            var change = {from: pos, to: pos,"
 W !,"                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),"
 W !,"                          origin: ""paste""};"
 W !,"            makeChange(cm.doc, change);"
 W !,"            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));"
 W !,"          }"
 W !,"        });"
 W !,"        reader.readAsText(file);"
 W !,"      };"
 W !,"      for (var i = 0; i < n; ++i) loadFile(files[i], i);"
 W !,"    } else { // Normal drop"
 W !,"      // Don't do a replace if the drop happened inside of the selected text."
 W !,"      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {"
 W !,"        cm.state.draggingText(e);"
 W !,"        // Ensure the editor is re-focused"
 W !,"        setTimeout(function() {cm.display.input.focus();}, 20);"
 W !,"        return;"
 W !,"      }"
 W !,"      try {"
 W !,"        var text = e.dataTransfer.getData(""Text"");"
 W !,"        if (text) {"
 W !,"          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))"
 W !,"            var selected = cm.listSelections();"
 W !,"          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));"
 W !,"          if (selected) for (var i = 0; i < selected.length; ++i)"
 W !,"            replaceRange(cm.doc, """", selected[i].anchor, selected[i].head, ""drag"");"
 W !,"          cm.replaceSelection(text, ""around"", ""paste"");"
 W !,"          cm.display.input.focus();"
 W !,"        }"
 W !,"      }"
 W !,"      catch(e){}"
 W !,"    }"
 W !,"  }"

 W !,"  function onDragStart(cm, e) {"
 W !,"    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }"
 W !,"    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;"

 W !,"    e.dataTransfer.setData(""Text"", cm.getSelection());"
 W !,"    e.dataTransfer.effectAllowed = ""copyMove"""

 W !,"    // Use dummy image instead of default browsers image."
 W !,"    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there."
 W !,"    if (e.dataTransfer.setDragImage && !safari) {"
 W !,"      var img = elt(""img"", null, null, ""position: fixed; left: 0; top: 0;"");"
 W !,"      img.src = ""data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="";"
 W !,"      if (presto) {"
 W !,"        img.width = img.height = 1;"
 W !,"        cm.display.wrapper.appendChild(img);"
 W !,"        // Force a relayout, or Opera won't use our image for some obscure reason"
 W !,"        img._top = img.offsetTop;"
 W !,"      }"
 W !,"      e.dataTransfer.setDragImage(img, 0, 0);"
 W !,"      if (presto) img.parentNode.removeChild(img);"
 W !,"    }"
 W !,"  }"

 W !,"  function onDragOver(cm, e) {"
 W !,"    var pos = posFromMouse(cm, e);"
 W !,"    if (!pos) return;"
 W !,"    var frag = document.createDocumentFragment();"
 W !,"    drawSelectionCursor(cm, pos, frag);"
 W !,"    if (!cm.display.dragCursor) {"
 W !,"      cm.display.dragCursor = elt(""div"", null, ""CodeMirror-cursors CodeMirror-dragcursors"");"
 W !,"      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);"
 W !,"    }"
 W !,"    removeChildrenAndAdd(cm.display.dragCursor, frag);"
 W !,"  }"

 W !,"  function clearDragCursor(cm) {"
 W !,"    if (cm.display.dragCursor) {"
 W !,"      cm.display.lineSpace.removeChild(cm.display.dragCursor);"
 W !,"      cm.display.dragCursor = null;"
 W !,"    }"
 W !,"  }"

 W !,"  // SCROLL EVENTS"

 W !,"  // Sync the scrollable area and scrollbars, ensure the viewport"
 W !,"  // covers the visible area."
 W !,"  function setScrollTop(cm, val) {"
 W !,"    if (Math.abs(cm.doc.scrollTop - val) < 2) return;"
 W !,"    cm.doc.scrollTop = val;"
 W !,"    if (!gecko) updateDisplaySimple(cm, {top: val});"
 W !,"    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;"
 W !,"    cm.display.scrollbars.setScrollTop(val);"
 W !,"    if (gecko) updateDisplaySimple(cm);"
 W !,"    startWorker(cm, 100);"
 W !,"  }"
 W !,"  // Sync scroller and scrollbar, ensure the gutter elements are"
 W !,"  // aligned."
 W !,"  function setScrollLeft(cm, val, isScroller) {"
 W !,"    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;"
 W !,"    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);"
 W !,"    cm.doc.scrollLeft = val;"
 W !,"    alignHorizontally(cm);"
 W !,"    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;"
 W !,"    cm.display.scrollbars.setScrollLeft(val);"
 W !,"  }"

 W !,"  // Since the delta values reported on mouse wheel events are"
 W !,"  // unstandardized between browsers and even browser versions, and"
 W !,"  // generally horribly unpredictable, this code starts by measuring"
 W !,"  // the scroll effect that the first few mouse wheel events have,"
 W !,"  // and, from that, detects the way it can convert deltas to pixel"
 W !,"  // offsets afterwards."
 W !,"  //"
 W !,"  // The reason we want to know the amount a wheel event will scroll"
 W !,"  // is that it gives us a chance to update the display before the"
 W !,"  // actual scrolling happens, reducing flickering."

 W !,"  var wheelSamples = 0, wheelPixelsPerUnit = null;"
 W !,"  // Fill in a browser-detected starting value on browsers where we"
 W !,"  // know one. These don't have to be accurate -- the result of them"
 W !,"  // being wrong would just be a slight flicker on the first wheel"
 W !,"  // scroll (if it is large enough)."
 W !,"  if (ie) wheelPixelsPerUnit = -.53;"
 W !,"  else if (gecko) wheelPixelsPerUnit = 15;"
 W !,"  else if (chrome) wheelPixelsPerUnit = -.7;"
 W !,"  else if (safari) wheelPixelsPerUnit = -1/3;"

 W !,"  var wheelEventDelta = function(e) {"
 W !,"    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;"
 W !,"    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;"
 W !,"    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;"
 W !,"    else if (dy == null) dy = e.wheelDelta;"
 W !,"    return {x: dx, y: dy};"
 W !,"  };"
 W !,"  CodeMirror.wheelEventPixels = function(e) {"
 W !,"    var delta = wheelEventDelta(e);"
 W !,"    delta.x *= wheelPixelsPerUnit;"
 W !,"    delta.y *= wheelPixelsPerUnit;"
 W !,"    return delta;"
 W !,"  };"
}

ClassMethod ScriptLibCodemirror7()
{
 W !,"  function onScrollWheel(cm, e) {"
 W !,"    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;"

 W !,"    var display = cm.display, scroll = display.scroller;"
 W !,"    // Quit if there's nothing to scroll here"
 W !,"    var canScrollX = scroll.scrollWidth > scroll.clientWidth;"
 W !,"    var canScrollY = scroll.scrollHeight > scroll.clientHeight;"
 W !,"    if (!(dx && canScrollX || dy && canScrollY)) return;"

 W !,"    // Webkit browsers on OS X abort momentum scrolls when the target"
 W !,"    // of the scroll event is removed from the scrollable element."
 W !,"    // This hack (see related code in patchDisplay) makes sure the"
 W !,"    // element is kept around."
 W !,"    if (dy && mac && webkit) {"
 W !,"      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {"
 W !,"        for (var i = 0; i < view.length; i++) {"
 W !,"          if (view[i].node == cur) {"
 W !,"            cm.display.currentWheelTarget = cur;"
 W !,"            break outer;"
 W !,"          }"
 W !,"        }"
 W !,"      }"
 W !,"    }"

 W !,"    // On some browsers, horizontal scrolling will cause redraws to"
 W !,"    // happen before the gutter has been realigned, causing it to"
 W !,"    // wriggle around in a most unseemly way. When we have an"
 W !,"    // estimated pixels/delta value, we just handle horizontal"
 W !,"    // scrolling entirely here. It'll be slightly off from native, but"
 W !,"    // better than glitching out."
 W !,"    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {"
 W !,"      if (dy && canScrollY)"
 W !,"        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));"
 W !,"      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));"
 W !,"      // Only prevent default scrolling if vertical scrolling is"
 W !,"      // actually possible. Otherwise, it causes vertical scroll"
 W !,"      // jitter on OSX trackpads when deltaX is small and deltaY"
 W !,"      // is large (issue #3579)"
 W !,"      if (!dy || (dy && canScrollY))"
 W !,"        e_preventDefault(e);"
 W !,"      display.wheelStartX = null; // Abort measurement, if in progress"
 W !,"      return;"
 W !,"    }"

 W !,"    // 'Project' the visible viewport to cover the area that is being"
 W !,"    // scrolled into view (if we know enough to estimate it)."
 W !,"    if (dy && wheelPixelsPerUnit != null) {"
 W !,"      var pixels = dy * wheelPixelsPerUnit;"
 W !,"      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;"
 W !,"      if (pixels < 0) top = Math.max(0, top + pixels - 50);"
 W !,"      else bot = Math.min(cm.doc.height, bot + pixels + 50);"
 W !,"      updateDisplaySimple(cm, {top: top, bottom: bot});"
 W !,"    }"

 W !,"    if (wheelSamples < 20) {"
 W !,"      if (display.wheelStartX == null) {"
 W !,"        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;"
 W !,"        display.wheelDX = dx; display.wheelDY = dy;"
 W !,"        setTimeout(function() {"
 W !,"          if (display.wheelStartX == null) return;"
 W !,"          var movedX = scroll.scrollLeft - display.wheelStartX;"
 W !,"          var movedY = scroll.scrollTop - display.wheelStartY;"
 W !,"          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||"
 W !,"            (movedX && display.wheelDX && movedX / display.wheelDX);"
 W !,"          display.wheelStartX = display.wheelStartY = null;"
 W !,"          if (!sample) return;"
 W !,"          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);"
 W !,"          ++wheelSamples;"
 W !,"        }, 200);"
 W !,"      } else {"
 W !,"        display.wheelDX += dx; display.wheelDY += dy;"
 W !,"      }"
 W !,"    }"
 W !,"  }"

 W !,"  // KEY EVENTS"

 W !,"  // Run a handler that was bound to a key."
 W !,"  function doHandleBinding(cm, bound, dropShift) {"
 W !,"    if (typeof bound == ""string"") {"
 W !,"      bound = commands[bound];"
 W !,"      if (!bound) return false;"
 W !,"    }"
 W !,"    // Ensure previous input has been read, so that the handler sees a"
 W !,"    // consistent view of the document"
 W !,"    cm.display.input.ensurePolled();"
 W !,"    var prevShift = cm.display.shift, done = false;"
 W !,"    try {"
 W !,"      if (cm.isReadOnly()) cm.state.suppressEdits = true;"
 W !,"      if (dropShift) cm.display.shift = false;"
 W !,"      done = bound(cm) != Pass;"
 W !,"    } finally {"
 W !,"      cm.display.shift = prevShift;"
 W !,"      cm.state.suppressEdits = false;"
 W !,"    }"
 W !,"    return done;"
 W !,"  }"

 W !,"  function lookupKeyForEditor(cm, name, handle) {"
 W !,"    for (var i = 0; i < cm.state.keyMaps.length; i++) {"
 W !,"      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);"
 W !,"      if (result) return result;"
 W !,"    }"
 W !,"    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))"
 W !,"      || lookupKey(name, cm.options.keyMap, handle, cm);"
 W !,"  }"

 W !,"  var stopSeq = new Delayed;"
 W !,"  function dispatchKey(cm, name, e, handle) {"
 W !,"    var seq = cm.state.keySeq;"
 W !,"    if (seq) {"
 W !,"      if (isModifierKey(name)) return ""handled"";"
 W !,"      stopSeq.set(50, function() {"
 W !,"        if (cm.state.keySeq == seq) {"
 W !,"          cm.state.keySeq = null;"
 W !,"          cm.display.input.reset();"
 W !,"        }"
 W !,"      });"
 W !,"      name = seq + "" "" + name;"
 W !,"    }"
 W !,"    var result = lookupKeyForEditor(cm, name, handle);"

 W !,"    if (result == ""multi"")"
 W !,"      cm.state.keySeq = name;"
 W !,"    if (result == ""handled"")"
 W !,"      signalLater(cm, ""keyHandled"", cm, name, e);"

 W !,"    if (result == ""handled"" || result == ""multi"") {"
 W !,"      e_preventDefault(e);"
 W !,"      restartBlink(cm);"
 W !,"    }"

 W !,"    if (seq && !result && /\'$/.test(name)) {"
 W !,"      e_preventDefault(e);"
 W !,"      return true;"
 W !,"    }"
 W !,"    return !!result;"
 W !,"  }"

 W !,"  // Handle a key from the keydown event."
 W !,"  function handleKeyBinding(cm, e) {"
 W !,"    var name = keyName(e, true);"
 W !,"    if (!name) return false;"

 W !,"    if (e.shiftKey && !cm.state.keySeq) {"
 W !,"      // First try to resolve full name (including 'Shift-'). Failing"
 W !,"      // that, see if there is a cursor-motion command (starting with"
 W !,"      // 'go') bound to the keyname without 'Shift-'."
 W !,"      return dispatchKey(cm, ""Shift-"" + name, e, function(b) {return doHandleBinding(cm, b, true);})"
 W !,"          || dispatchKey(cm, name, e, function(b) {"
 W !,"               if (typeof b == ""string"" ? /^go[A-Z]/.test(b) : b.motion)"
 W !,"                 return doHandleBinding(cm, b);"
 W !,"             });"
 W !,"    } else {"
 W !,"      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });"
 W !,"    }"
 W !,"  }"

 W !,"  // Handle a key from the keypress event"
 W !,"  function handleCharBinding(cm, e, ch) {"
 W !,"    return dispatchKey(cm, ""'"" + ch + ""'"", e,"
 W !,"                       function(b) { return doHandleBinding(cm, b, true); });"
 W !,"  }"

 W !,"  var lastStoppedKey = null;"
 W !,"  function onKeyDown(e) {"
 W !,"    var cm = this;"
 W !,"    cm.curOp.focus = activeElt();"
 W !,"    if (signalDOMEvent(cm, e)) return;"
 W !,"    // IE does strange things with escape."
 W !,"    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;"
 W !,"    var code = e.keyCode;"
 W !,"    cm.display.shift = code == 16 || e.shiftKey;"
 W !,"    var handled = handleKeyBinding(cm, e);"
 W !,"    if (presto) {"
 W !,"      lastStoppedKey = handled ? code : null;"
 W !,"      // Opera has no cut event... we try to at least catch the key combo"
 W !,"      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))"
 W !,"        cm.replaceSelection("""", null, ""cut"");"
 W !,"    }"

 W !,"    // Turn mouse into crosshair when Alt is held on Mac."
 W !,"    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))"
 W !,"      showCrossHair(cm);"
 W !,"  }"

 W !,"  function showCrossHair(cm) {"
 W !,"    var lineDiv = cm.display.lineDiv;"
 W !,"    addClass(lineDiv, ""CodeMirror-crosshair"");"

 W !,"    function up(e) {"
 W !,"      if (e.keyCode == 18 || !e.altKey) {"
 W !,"        rmClass(lineDiv, ""CodeMirror-crosshair"");"
 W !,"        off(document, ""keyup"", up);"
 W !,"        off(document, ""mouseover"", up);"
 W !,"      }"
 W !,"    }"
 W !,"    on(document, ""keyup"", up);"
 W !,"    on(document, ""mouseover"", up);"
 W !,"  }"

 W !,"  function onKeyUp(e) {"
 W !,"    if (e.keyCode == 16) this.doc.sel.shift = false;"
 W !,"    signalDOMEvent(this, e);"
 W !,"  }"

 W !,"  function onKeyPress(e) {"
 W !,"    var cm = this;"
 W !,"    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;"
 W !,"    var keyCode = e.keyCode, charCode = e.charCode;"
 W !,"    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}"
 W !,"    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;"
 W !,"    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);"
 W !,"    if (handleCharBinding(cm, e, ch)) return;"
 W !,"    cm.display.input.onKeyPress(e);"
 W !,"  }"

 W !,"  // FOCUS/BLUR EVENTS"

 W !,"  function delayBlurEvent(cm) {"
 W !,"    cm.state.delayingBlurEvent = true;"
 W !,"    setTimeout(function() {"
 W !,"      if (cm.state.delayingBlurEvent) {"
 W !,"        cm.state.delayingBlurEvent = false;"
 W !,"        onBlur(cm);"
 W !,"      }"
 W !,"    }, 100);"
 W !,"  }"

 W !,"  function onFocus(cm) {"
 W !,"    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;"

 W !,"    if (cm.options.readOnly == ""nocursor"") return;"
 W !,"    if (!cm.state.focused) {"
 W !,"      signal(cm, ""focus"", cm);"
 W !,"      cm.state.focused = true;"
 W !,"      addClass(cm.display.wrapper, ""CodeMirror-focused"");"
 W !,"      // This test prevents this from firing when a context"
 W !,"      // menu is closed (since the input reset would kill the"
 W !,"      // select-all detection hack)"
 W !,"      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {"
 W !,"        cm.display.input.reset();"
 W !,"        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730"
 W !,"      }"
 W !,"      cm.display.input.receivedFocus();"
 W !,"    }"
 W !,"    restartBlink(cm);"
 W !,"  }"
 W !,"  function onBlur(cm) {"
 W !,"    if (cm.state.delayingBlurEvent) return;"

 W !,"    if (cm.state.focused) {"
 W !,"      signal(cm, ""blur"", cm);"
 W !,"      cm.state.focused = false;"
 W !,"      rmClass(cm.display.wrapper, ""CodeMirror-focused"");"
 W !,"    }"
 W !,"    clearInterval(cm.display.blinker);"
 W !,"    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);"
 W !,"  }"

 W !,"  // CONTEXT MENU HANDLING"

 W !,"  // To make the context menu work, we need to briefly unhide the"
 W !,"  // textarea (making it as unobtrusive as possible) to let the"
 W !,"  // right-click take effect on it."
 W !,"  function onContextMenu(cm, e) {"
 W !,"    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;"
 W !,"    if (signalDOMEvent(cm, e, ""contextmenu"")) return;"
 W !,"    cm.display.input.onContextMenu(e);"
 W !,"  }"

 W !,"  function contextMenuInGutter(cm, e) {"
 W !,"    if (!hasHandler(cm, ""gutterContextMenu"")) return false;"
 W !,"    return gutterEvent(cm, e, ""gutterContextMenu"", false);"
 W !,"  }"

 W !,"  // UPDATING"

 W !,"  // Compute the position of the end of a change (its 'to' property"
 W !,"  // refers to the pre-change end)."
 W !,"  var changeEnd = CodeMirror.changeEnd = function(change) {"
 W !,"    if (!change.text) return change.to;"
 W !,"    return Pos(change.from.line + change.text.length - 1,"
 W !,"               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));"
 W !,"  };"

 W !,"  // Adjust a position to refer to the post-change position of the"
 W !,"  // same text, or the end of the change if the change covers it."
 W !,"  function adjustForChange(pos, change) {"
 W !,"    if (cmp(pos, change.from) < 0) return pos;"
 W !,"    if (cmp(pos, change.to) <= 0) return changeEnd(change);"

 W !,"    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;"
 W !,"    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;"
 W !,"    return Pos(line, ch);"
 W !,"  }"

 W !,"  function computeSelAfterChange(doc, change) {"
 W !,"    var out = [];"
 W !,"    for (var i = 0; i < doc.sel.ranges.length; i++) {"
 W !,"      var range = doc.sel.ranges[i];"
 W !,"      out.push(new Range(adjustForChange(range.anchor, change),"
 W !,"                         adjustForChange(range.head, change)));"
 W !,"    }"
 W !,"    return normalizeSelection(out, doc.sel.primIndex);"
 W !,"  }"

 W !,"  function offsetPos(pos, old, nw) {"
 W !,"    if (pos.line == old.line)"
 W !,"      return Pos(nw.line, pos.ch - old.ch + nw.ch);"
 W !,"    else"
 W !,"      return Pos(nw.line + (pos.line - old.line), pos.ch);"
 W !,"  }"

 W !,"  // Used by replaceSelections to allow moving the selection to the"
 W !,"  // start or around the replaced test. Hint may be ""start"" or ""around""."
 W !,"  function computeReplacedSel(doc, changes, hint) {"
 W !,"    var out = [];"
 W !,"    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;"
 W !,"    for (var i = 0; i < changes.length; i++) {"
 W !,"      var change = changes[i];"
 W !,"      var from = offsetPos(change.from, oldPrev, newPrev);"
 W !,"      var to = offsetPos(changeEnd(change), oldPrev, newPrev);"
 W !,"      oldPrev = change.to;"
 W !,"      newPrev = to;"
 W !,"      if (hint == ""around"") {"
 W !,"        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;"
 W !,"        out[i] = new Range(inv ? to : from, inv ? from : to);"
 W !,"      } else {"
 W !,"        out[i] = new Range(from, from);"
 W !,"      }"
 W !,"    }"
 W !,"    return new Selection(out, doc.sel.primIndex);"
 W !,"  }"

 W !,"  // Allow ""beforeChange"" event handlers to influence a change"
 W !,"  function filterChange(doc, change, update) {"
 W !,"    var obj = {"
 W !,"      canceled: false,"
 W !,"      from: change.from,"
 W !,"      to: change.to,"
 W !,"      text: change.text,"
 W !,"      origin: change.origin,"
 W !,"      cancel: function() { this.canceled = true; }"
 W !,"    };"
 W !,"    if (update) obj.update = function(from, to, text, origin) {"
 W !,"      if (from) this.from = clipPos(doc, from);"
 W !,"      if (to) this.to = clipPos(doc, to);"
 W !,"      if (text) this.text = text;"
 W !,"      if (origin !== undefined) this.origin = origin;"
 W !,"    };"
 W !,"    signal(doc, ""beforeChange"", doc, obj);"
 W !,"    if (doc.cm) signal(doc.cm, ""beforeChange"", doc.cm, obj);"

 W !,"    if (obj.canceled) return null;"
 W !,"    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};"
 W !,"  }"

 W !,"  // Apply a change to a document, and add it to the document's"
 W !,"  // history, and propagating it to all linked documents."
 W !,"  function makeChange(doc, change, ignoreReadOnly) {"
 W !,"    if (doc.cm) {"
 W !,"      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);"
 W !,"      if (doc.cm.state.suppressEdits) return;"
 W !,"    }"

 W !,"    if (hasHandler(doc, ""beforeChange"") || doc.cm && hasHandler(doc.cm, ""beforeChange"")) {"
 W !,"      change = filterChange(doc, change, true);"
 W !,"      if (!change) return;"
 W !,"    }"

 W !,"    // Possibly split or suppress the update based on the presence"
 W !,"    // of read-only spans in its range."
 W !,"    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);"
 W !,"    if (split) {"
 W !,"      for (var i = split.length - 1; i >= 0; --i)"
 W !,"        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""""] : change.text});"
 W !,"    } else {"
 W !,"      makeChangeInner(doc, change);"
 W !,"    }"
 W !,"  }"

 W !,"  function makeChangeInner(doc, change) {"
 W !,"    if (change.text.length == 1 && change.text[0] == """" && cmp(change.from, change.to) == 0) return;"
 W !,"    var selAfter = computeSelAfterChange(doc, change);"
 W !,"    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);"

 W !,"    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));"
 W !,"    var rebased = [];"

 W !,"    linkedDocs(doc, function(doc, sharedHist) {"
 W !,"      if (!sharedHist && indexOf(rebased, doc.history) == -1) {"
 W !,"        rebaseHist(doc.history, change);"
 W !,"        rebased.push(doc.history);"
 W !,"      }"
 W !,"      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));"
 W !,"    });"
 W !,"  }"

 W !,"  // Revert a change stored in a document's history."
 W !,"  function makeChangeFromHistory(doc, type, allowSelectionOnly) {"
 W !,"    if (doc.cm && doc.cm.state.suppressEdits) return;"

 W !,"    var hist = doc.history, event, selAfter = doc.sel;"
 W !,"    var source = type == ""undo"" ? hist.done : hist.undone, dest = type == ""undo"" ? hist.undone : hist.done;"

 W !,"    // Verify that there is a useable event (so that ctrl-z won't"
 W !,"    // needlessly clear selection events)"
 W !,"    for (var i = 0; i < source.length; i++) {"
 W !,"      event = source[i];"
 W !,"      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)"
 W !,"        break;"
 W !,"    }"
 W !,"    if (i == source.length) return;"
 W !,"    hist.lastOrigin = hist.lastSelOrigin = null;"

 W !,"    for (;;) {"
 W !,"      event = source.pop();"
 W !,"      if (event.ranges) {"
 W !,"        pushSelectionToHistory(event, dest);"
 W !,"        if (allowSelectionOnly && !event.equals(doc.sel)) {"
 W !,"          setSelection(doc, event, {clearRedo: false});"
 W !,"          return;"
 W !,"        }"
 W !,"        selAfter = event;"
 W !,"      }"
 W !,"      else break;"
 W !,"    }"

 W !,"    // Build up a reverse change object to add to the opposite history"
 W !,"    // stack (redo when undoing, and vice versa)."
 W !,"    var antiChanges = [];"
 W !,"    pushSelectionToHistory(selAfter, dest);"
 W !,"    dest.push({changes: antiChanges, generation: hist.generation});"
 W !,"    hist.generation = event.generation || ++hist.maxGeneration;"

 W !,"    var filter = hasHandler(doc, ""beforeChange"") || doc.cm && hasHandler(doc.cm, ""beforeChange"");"

 W !,"    for (var i = event.changes.length - 1; i >= 0; --i) {"
 W !,"      var change = event.changes[i];"
 W !,"      change.origin = type;"
 W !,"      if (filter && !filterChange(doc, change, false)) {"
 W !,"        source.length = 0;"
 W !,"        return;"
 W !,"      }"

 W !,"      antiChanges.push(historyChangeFromChange(doc, change));"

 W !,"      var after = i ? computeSelAfterChange(doc, change) : lst(source);"
 W !,"      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));"
 W !,"      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});"
 W !,"      var rebased = [];"

 W !,"      // Propagate to the linked documents"
 W !,"      linkedDocs(doc, function(doc, sharedHist) {"
 W !,"        if (!sharedHist && indexOf(rebased, doc.history) == -1) {"
 W !,"          rebaseHist(doc.history, change);"
 W !,"          rebased.push(doc.history);"
 W !,"        }"
 W !,"        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));"
 W !,"      });"
 W !,"    }"
 W !,"  }"

 W !,"  // Sub-views need their line numbers shifted when text is added"
 W !,"  // above or below them in the parent document."
 W !,"  function shiftDoc(doc, distance) {"
 W !,"    if (distance == 0) return;"
 W !,"    doc.first += distance;"
 W !,"    doc.sel = new Selection(map(doc.sel.ranges, function(range) {"
 W !,"      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),"
 W !,"                       Pos(range.head.line + distance, range.head.ch));"
 W !,"    }), doc.sel.primIndex);"
 W !,"    if (doc.cm) {"
 W !,"      regChange(doc.cm, doc.first, doc.first - distance, distance);"
 W !,"      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)"
 W !,"        regLineChange(doc.cm, l, ""gutter"");"
 W !,"    }"
 W !,"  }"

 W !,"  // More lower-level change function, handling only a single document"
 W !,"  // (not linked ones)."
 W !,"  function makeChangeSingleDoc(doc, change, selAfter, spans) {"
 W !,"    if (doc.cm && !doc.cm.curOp)"
 W !,"      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);"

 W !,"    if (change.to.line < doc.first) {"
 W !,"      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));"
 W !,"      return;"
 W !,"    }"
 W !,"    if (change.from.line > doc.lastLine()) return;"

 W !,"    // Clip the change to the size of this doc"
 W !,"    if (change.from.line < doc.first) {"
 W !,"      var shift = change.text.length - 1 - (doc.first - change.from.line);"
 W !,"      shiftDoc(doc, shift);"
 W !,"      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),"
 W !,"                text: [lst(change.text)], origin: change.origin};"
 W !,"    }"
 W !,"    var last = doc.lastLine();"
 W !,"    if (change.to.line > last) {"
 W !,"      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),"
 W !,"                text: [change.text[0]], origin: change.origin};"
 W !,"    }"

 W !,"    change.removed = getBetween(doc, change.from, change.to);"

 W !,"    if (!selAfter) selAfter = computeSelAfterChange(doc, change);"
 W !,"    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);"
 W !,"    else updateDoc(doc, change, spans);"
 W !,"    setSelectionNoUndo(doc, selAfter, sel_dontScroll);"
 W !,"  }"

 W !,"  // Handle the interaction of a change to a document with the editor"
 W !,"  // that this document is part of."
 W !,"  function makeChangeSingleDocInEditor(cm, change, spans) {"
 W !,"    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;"

 W !,"    var recomputeMaxLength = false, checkWidthStart = from.line;"
 W !,"    if (!cm.options.lineWrapping) {"
 W !,"      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));"
 W !,"      doc.iter(checkWidthStart, to.line + 1, function(line) {"
 W !,"        if (line == display.maxLine) {"
 W !,"          recomputeMaxLength = true;"
 W !,"          return true;"
 W !,"        }"
 W !,"      });"
 W !,"    }"

 W !,"    if (doc.sel.contains(change.from, change.to) > -1)"
 W !,"      signalCursorActivity(cm);"

 W !,"    updateDoc(doc, change, spans, estimateHeight(cm));"

 W !,"    if (!cm.options.lineWrapping) {"
 W !,"      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {"
 W !,"        var len = lineLength(line);"
 W !,"        if (len > display.maxLineLength) {"
 W !,"          display.maxLine = line;"
 W !,"          display.maxLineLength = len;"
 W !,"          display.maxLineChanged = true;"
 W !,"          recomputeMaxLength = false;"
 W !,"        }"
 W !,"      });"
 W !,"      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;"
 W !,"    }"

 W !,"    // Adjust frontier, schedule worker"
 W !,"    doc.frontier = Math.min(doc.frontier, from.line);"
 W !,"    startWorker(cm, 400);"

 W !,"    var lendiff = change.text.length - (to.line - from.line) - 1;"
 W !,"    // Remember that these lines changed, for updating the display"
 W !,"    if (change.full)"
 W !,"      regChange(cm);"
 W !,"    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))"
 W !,"      regLineChange(cm, from.line, ""text"");"
 W !,"    else"
 W !,"      regChange(cm, from.line, to.line + 1, lendiff);"

 W !,"    var changesHandler = hasHandler(cm, ""changes""), changeHandler = hasHandler(cm, ""change"");"
 W !,"    if (changeHandler || changesHandler) {"
 W !,"      var obj = {"
 W !,"        from: from, to: to,"
 W !,"        text: change.text,"
 W !,"        removed: change.removed,"
 W !,"        origin: change.origin"
 W !,"      };"
 W !,"      if (changeHandler) signalLater(cm, ""change"", cm, obj);"
 W !,"      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);"
 W !,"    }"
 W !,"    cm.display.selForContextMenu = null;"
 W !,"  }"

 W !,"  function replaceRange(doc, code, from, to, origin) {"
 W !,"    if (!to) to = from;"
 W !,"    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }"
 W !,"    if (typeof code == ""string"") code = doc.splitLines(code);"
 W !,"    makeChange(doc, {from: from, to: to, text: code, origin: origin});"
 W !,"  }"

 W !,"  // SCROLLING THINGS INTO VIEW"

 W !,"  // If an editor sits on the top or bottom of the window, partially"
 W !,"  // scrolled out of view, this ensures that the cursor is visible."
 W !,"  function maybeScrollWindow(cm, coords) {"
 W !,"    if (signalDOMEvent(cm, ""scrollCursorIntoView"")) return;"

 W !,"    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;"
 W !,"    if (coords.top + box.top < 0) doScroll = true;"
 W !,"    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;"
 W !,"    if (doScroll != null && !phantom) {"
 W !,"      var scrollNode = elt(""div"", ""\u200b"", null, ""position: absolute; top: "" +"
 W !,"                           (coords.top - display.viewOffset - paddingTop(cm.display)) + ""px; height: "" +"
 W !,"                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + ""px; left: "" +"
 W !,"                           coords.left + ""px; width: 2px;"");"
 W !,"      cm.display.lineSpace.appendChild(scrollNode);"
 W !,"      scrollNode.scrollIntoView(doScroll);"
 W !,"      cm.display.lineSpace.removeChild(scrollNode);"
 W !,"    }"
 W !,"  }"

 W !,"  // Scroll a given position into view (immediately), verifying that"
 W !,"  // it actually became visible (as line heights are accurately"
 W !,"  // measured, the position of something may 'drift' during drawing)."
 W !,"  function scrollPosIntoView(cm, pos, end, margin) {"
 W !,"    if (margin == null) margin = 0;"
 W !,"    for (var limit = 0; limit < 5; limit++) {"
 W !,"      var changed = false, coords = cursorCoords(cm, pos);"
 W !,"      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);"
 W !,"      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),"
 W !,"                                         Math.min(coords.top, endCoords.top) - margin,"
 W !,"                                         Math.max(coords.left, endCoords.left),"
 W !,"                                         Math.max(coords.bottom, endCoords.bottom) + margin);"
 W !,"      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;"
 W !,"      if (scrollPos.scrollTop != null) {"
 W !,"        setScrollTop(cm, scrollPos.scrollTop);"
 W !,"        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;"
 W !,"      }"
 W !,"      if (scrollPos.scrollLeft != null) {"
 W !,"        setScrollLeft(cm, scrollPos.scrollLeft);"
 W !,"        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;"
 W !,"      }"
 W !,"      if (!changed) break;"
 W !,"    }"
 W !,"    return coords;"
 W !,"  }"

 W !,"  // Scroll a given set of coordinates into view (immediately)."
 W !,"  function scrollIntoView(cm, x1, y1, x2, y2) {"
 W !,"    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);"
 W !,"    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);"
 W !,"    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);"
 W !,"  }"

 W !,"  // Calculate a new scroll position needed to scroll the given"
 W !,"  // rectangle into view. Returns an object with scrollTop and"
 W !,"  // scrollLeft properties. When these are undefined, the"
 W !,"  // vertical/horizontal position does not need to be adjusted."
 W !,"  function calculateScrollPos(cm, x1, y1, x2, y2) {"
 W !,"    var display = cm.display, snapMargin = textHeight(cm.display);"
 W !,"    if (y1 < 0) y1 = 0;"
 W !,"    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;"
 W !,"    var screen = displayHeight(cm), result = {};"
 W !,"    if (y2 - y1 > screen) y2 = y1 + screen;"
 W !,"    var docBottom = cm.doc.height + paddingVert(display);"
 W !,"    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;"
 W !,"    if (y1 < screentop) {"
 W !,"      result.scrollTop = atTop ? 0 : y1;"
 W !,"    } else if (y2 > screentop + screen) {"
 W !,"      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);"
 W !,"      if (newTop != screentop) result.scrollTop = newTop;"
 W !,"    }"

 W !,"    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;"
 W !,"    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);"
 W !,"    var tooWide = x2 - x1 > screenw;"
 W !,"    if (tooWide) x2 = x1 + screenw;"
 W !,"    if (x1 < 10)"
 W !,"      result.scrollLeft = 0;"
 W !,"    else if (x1 < screenleft)"
 W !,"      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));"
 W !,"    else if (x2 > screenw + screenleft - 3)"
 W !,"      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;"
 W !,"    return result;"
 W !,"  }"

 W !,"  // Store a relative adjustment to the scroll position in the current"
 W !,"  // operation (to be applied when the operation finishes)."
}

ClassMethod ScriptLibCodemirror8()
{
 W !,"  function addToScrollPos(cm, left, top) {"
 W !,"    if (left != null || top != null) resolveScrollToPos(cm);"
 W !,"    if (left != null)"
 W !,"      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;"
 W !,"    if (top != null)"
 W !,"      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;"
 W !,"  }"

 W !,"  // Make sure that at the end of the operation the current cursor is"
 W !,"  // shown."
 W !,"  function ensureCursorVisible(cm) {"
 W !,"    resolveScrollToPos(cm);"
 W !,"    var cur = cm.getCursor(), from = cur, to = cur;"
 W !,"    if (!cm.options.lineWrapping) {"
 W !,"      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;"
 W !,"      to = Pos(cur.line, cur.ch + 1);"
 W !,"    }"
 W !,"    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};"
 W !,"  }"

 W !,"  // When an operation has its scrollToPos property set, and another"
 W !,"  // scroll action is applied before the end of the operation, this"
 W !,"  // 'simulates' scrolling that position into view in a cheap way, so"
 W !,"  // that the effect of intermediate scroll commands is not ignored."
 W !,"  function resolveScrollToPos(cm) {"
 W !,"    var range = cm.curOp.scrollToPos;"
 W !,"    if (range) {"
 W !,"      cm.curOp.scrollToPos = null;"
 W !,"      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);"
 W !,"      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),"
 W !,"                                    Math.min(from.top, to.top) - range.margin,"
 W !,"                                    Math.max(from.right, to.right),"
 W !,"                                    Math.max(from.bottom, to.bottom) + range.margin);"
 W !,"      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);"
 W !,"    }"
 W !,"  }"

 W !,"  // API UTILITIES"

 W !,"  // Indent the given line. The how parameter can be ""smart"","
 W !,"  // ""add""/null, ""subtract"", or ""prev"". When aggressive is false"
 W !,"  // (typically set to true for forced single-line indents), empty"
 W !,"  // lines are not indented, and places where the mode returns Pass"
 W !,"  // are left alone."
 W !,"  function indentLine(cm, n, how, aggressive) {"
 W !,"    var doc = cm.doc, state;"
 W !,"    if (how == null) how = ""add"";"
 W !,"    if (how == ""smart"") {"
 W !,"      // Fall back to ""prev"" when the mode doesn't have an indentation"
 W !,"      // method."
 W !,"      if (!doc.mode.indent) how = ""prev"";"
 W !,"      else state = getStateBefore(cm, n);"
 W !,"    }"

 W !,"    var tabSize = cm.options.tabSize;"
 W !,"    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);"
 W !,"    if (line.stateAfter) line.stateAfter = null;"
 W !,"    var curSpaceString = line.text.match(/^\s*/)[0], indentation;"
 W !,"    if (!aggressive && !/\S/.test(line.text)) {"
 W !,"      indentation = 0;"
 W !,"      how = ""not"";"
 W !,"    } else if (how == ""smart"") {"
 W !,"      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);"
 W !,"      if (indentation == Pass || indentation > 150) {"
 W !,"        if (!aggressive) return;"
 W !,"        how = ""prev"";"
 W !,"      }"
 W !,"    }"
 W !,"    if (how == ""prev"") {"
 W !,"      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);"
 W !,"      else indentation = 0;"
 W !,"    } else if (how == ""add"") {"
 W !,"      indentation = curSpace + cm.options.indentUnit;"
 W !,"    } else if (how == ""subtract"") {"
 W !,"      indentation = curSpace - cm.options.indentUnit;"
 W !,"    } else if (typeof how == ""number"") {"
 W !,"      indentation = curSpace + how;"
 W !,"    }"
 W !,"    indentation = Math.max(0, indentation);"

 W !,"    var indentString = """", pos = 0;"
 W !,"    if (cm.options.indentWithTabs)"
 W !,"      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += ""\t"";}"
 W !,"    if (pos < indentation) indentString += spaceStr(indentation - pos);"

 W !,"    if (indentString != curSpaceString) {"
 W !,"      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), ""+input"");"
 W !,"      line.stateAfter = null;"
 W !,"      return true;"
 W !,"    } else {"
 W !,"      // Ensure that, if the cursor was in the whitespace at the start"
 W !,"      // of the line, it is moved to the end of that space."
 W !,"      for (var i = 0; i < doc.sel.ranges.length; i++) {"
 W !,"        var range = doc.sel.ranges[i];"
 W !,"        if (range.head.line == n && range.head.ch < curSpaceString.length) {"
 W !,"          var pos = Pos(n, curSpaceString.length);"
 W !,"          replaceOneSelection(doc, i, new Range(pos, pos));"
 W !,"          break;"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"  }"

 W !,"  // Utility for applying a change to a line by handle or number,"
 W !,"  // returning the number and optionally registering the line as"
 W !,"  // changed."
 W !,"  function changeLine(doc, handle, changeType, op) {"
 W !,"    var no = handle, line = handle;"
 W !,"    if (typeof handle == ""number"") line = getLine(doc, clipLine(doc, handle));"
 W !,"    else no = lineNo(handle);"
 W !,"    if (no == null) return null;"
 W !,"    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);"
 W !,"    return line;"
 W !,"  }"

 W !,"  // Helper for deleting text near the selection(s), used to implement"
 W !,"  // backspace, delete, and similar functionality."
 W !,"  function deleteNearSelection(cm, compute) {"
 W !,"    var ranges = cm.doc.sel.ranges, kill = [];"
 W !,"    // Build up a set of ranges to kill first, merging overlapping"
 W !,"    // ranges."
 W !,"    for (var i = 0; i < ranges.length; i++) {"
 W !,"      var toKill = compute(ranges[i]);"
 W !,"      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {"
 W !,"        var replaced = kill.pop();"
 W !,"        if (cmp(replaced.from, toKill.from) < 0) {"
 W !,"          toKill.from = replaced.from;"
 W !,"          break;"
 W !,"        }"
 W !,"      }"
 W !,"      kill.push(toKill);"
 W !,"    }"
 W !,"    // Next, remove those actual ranges."
 W !,"    runInOp(cm, function() {"
 W !,"      for (var i = kill.length - 1; i >= 0; i--)"
 W !,"        replaceRange(cm.doc, """", kill[i].from, kill[i].to, ""+delete"");"
 W !,"      ensureCursorVisible(cm);"
 W !,"    });"
 W !,"  }"

 W !,"  // Used for horizontal relative motion. Dir is -1 or 1 (left or"
 W !,"  // right), unit can be ""char"", ""column"" (like char, but doesn't"
 W !,"  // cross line boundaries), ""word"" (across next word), or ""group"" (to"
 W !,"  // the start of next group of word or non-word-non-whitespace"
 W !,"  // chars). The visually param controls whether, in right-to-left"
 W !,"  // text, direction 1 means to move towards the next index in the"
 W !,"  // string, or towards the character to the right of the current"
 W !,"  // position. The resulting position will have a hitSide=true"
 W !,"  // property if it reached the end of the document."
 W !,"  function findPosH(doc, pos, dir, unit, visually) {"
 W !,"    var line = pos.line, ch = pos.ch, origDir = dir;"
 W !,"    var lineObj = getLine(doc, line);"
 W !,"    function findNextLine() {"
 W !,"      var l = line + dir;"
 W !,"      if (l < doc.first || l >= doc.first + doc.size) return false"
 W !,"      line = l;"
 W !,"      return lineObj = getLine(doc, l);"
 W !,"    }"
 W !,"    function moveOnce(boundToLine) {"
 W !,"      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);"
 W !,"      if (next == null) {"
 W !,"        if (!boundToLine && findNextLine()) {"
 W !,"          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);"
 W !,"          else ch = dir < 0 ? lineObj.text.length : 0;"
 W !,"        } else return false"
 W !,"      } else ch = next;"
 W !,"      return true;"
 W !,"    }"

 W !,"    if (unit == ""char"") {"
 W !,"      moveOnce()"
 W !,"    } else if (unit == ""column"") {"
 W !,"      moveOnce(true)"
 W !,"    } else if (unit == ""word"" || unit == ""group"") {"
 W !,"      var sawType = null, group = unit == ""group"";"
 W !,"      var helper = doc.cm && doc.cm.getHelper(pos, ""wordChars"");"
 W !,"      for (var first = true;; first = false) {"
 W !,"        if (dir < 0 && !moveOnce(!first)) break;"
 W !,"        var cur = lineObj.text.charAt(ch) || ""\n"";"
 W !,"        var type = isWordChar(cur, helper) ? ""w"""
 W !,"          : group && cur == ""\n"" ? ""n"""
 W !,"          : !group || /\s/.test(cur) ? null"
 W !,"          : ""p"";"
 W !,"        if (group && !first && !type) type = ""s"";"
 W !,"        if (sawType && sawType != type) {"
 W !,"          if (dir < 0) {dir = 1; moveOnce();}"
 W !,"          break;"
 W !,"        }"

 W !,"        if (type) sawType = type;"
 W !,"        if (dir > 0 && !moveOnce(!first)) break;"
 W !,"      }"
 W !,"    }"
 W !,"    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);"
 W !,"    if (!cmp(pos, result)) result.hitSide = true;"
 W !,"    return result;"
 W !,"  }"

 W !,"  // For relative vertical movement. Dir may be -1 or 1. Unit can be"
 W !,"  // ""page"" or ""line"". The resulting position will have a hitSide=true"
 W !,"  // property if it reached the end of the document."
 W !,"  function findPosV(cm, pos, dir, unit) {"
 W !,"    var doc = cm.doc, x = pos.left, y;"
 W !,"    if (unit == ""page"") {"
 W !,"      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);"
 W !,"      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));"
 W !,"    } else if (unit == ""line"") {"
 W !,"      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;"
 W !,"    }"
 W !,"    for (;;) {"
 W !,"      var target = coordsChar(cm, x, y);"
 W !,"      if (!target.outside) break;"
 W !,"      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }"
 W !,"      y += dir * 5;"
 W !,"    }"
 W !,"    return target;"
 W !,"  }"

 W !,"  // EDITOR METHODS"

 W !,"  // The publicly visible API. Note that methodOp(f) means"
 W !,"  // 'wrap f in an operation, performed on its `this` parameter'."

 W !,"  // This is not the complete set of editor methods. Most of the"
 W !,"  // methods defined on the Doc type are also injected into"
 W !,"  // CodeMirror.prototype, for backwards compatibility and"
 W !,"  // convenience."

 W !,"  CodeMirror.prototype = {"
 W !,"    constructor: CodeMirror,"
 W !,"    focus: function(){window.focus(); this.display.input.focus();},"

 W !,"    setOption: function(option, value) {"
 W !,"      var options = this.options, old = options[option];"
 W !,"      if (options[option] == value && option != ""mode"") return;"
 W !,"      options[option] = value;"
 W !,"      if (optionHandlers.hasOwnProperty(option))"
 W !,"        operation(this, optionHandlers[option])(this, value, old);"
 W !,"    },"

 W !,"    getOption: function(option) {return this.options[option];},"
 W !,"    getDoc: function() {return this.doc;},"

 W !,"    addKeyMap: function(map, bottom) {"
 W !,"      this.state.keyMaps[bottom ? ""push"" : ""unshift""](getKeyMap(map));"
 W !,"    },"
 W !,"    removeKeyMap: function(map) {"
 W !,"      var maps = this.state.keyMaps;"
 W !,"      for (var i = 0; i < maps.length; ++i)"
 W !,"        if (maps[i] == map || maps[i].name == map) {"
 W !,"          maps.splice(i, 1);"
 W !,"          return true;"
 W !,"        }"
 W !,"    },"

 W !,"    addOverlay: methodOp(function(spec, options) {"
 W !,"      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);"
 W !,"      if (mode.startState) throw new Error(""Overlays may not be stateful."");"
 W !,"      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});"
 W !,"      this.state.modeGen++;"
 W !,"      regChange(this);"
 W !,"    }),"
 W !,"    removeOverlay: methodOp(function(spec) {"
 W !,"      var overlays = this.state.overlays;"
 W !,"      for (var i = 0; i < overlays.length; ++i) {"
 W !,"        var cur = overlays[i].modeSpec;"
 W !,"        if (cur == spec || typeof spec == ""string"" && cur.name == spec) {"
 W !,"          overlays.splice(i, 1);"
 W !,"          this.state.modeGen++;"
 W !,"          regChange(this);"
 W !,"          return;"
 W !,"        }"
 W !,"      }"
 W !,"    }),"

 W !,"    indentLine: methodOp(function(n, dir, aggressive) {"
 W !,"      if (typeof dir != ""string"" && typeof dir != ""number"") {"
 W !,"        if (dir == null) dir = this.options.smartIndent ? ""smart"" : ""prev"";"
 W !,"        else dir = dir ? ""add"" : ""subtract"";"
 W !,"      }"
 W !,"      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);"
 W !,"    }),"
 W !,"    indentSelection: methodOp(function(how) {"
 W !,"      var ranges = this.doc.sel.ranges, end = -1;"
 W !,"      for (var i = 0; i < ranges.length; i++) {"
 W !,"        var range = ranges[i];"
 W !,"        if (!range.empty()) {"
 W !,"          var from = range.from(), to = range.to();"
 W !,"          var start = Math.max(end, from.line);"
 W !,"          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;"
 W !,"          for (var j = start; j < end; ++j)"
 W !,"            indentLine(this, j, how);"
 W !,"          var newRanges = this.doc.sel.ranges;"
 W !,"          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)"
 W !,"            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);"
 W !,"        } else if (range.head.line > end) {"
 W !,"          indentLine(this, range.head.line, how, true);"
 W !,"          end = range.head.line;"
 W !,"          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);"
 W !,"        }"
 W !,"      }"
 W !,"    }),"

 W !,"    // Fetch the parser token for a given character. Useful for hacks"
 W !,"    // that want to inspect the mode state (say, for completion)."
 W !,"    getTokenAt: function(pos, precise) {"
 W !,"      return takeToken(this, pos, precise);"
 W !,"    },"

 W !,"    getLineTokens: function(line, precise) {"
 W !,"      return takeToken(this, Pos(line), precise, true);"
 W !,"    },"

 W !,"    getTokenTypeAt: function(pos) {"
 W !,"      pos = clipPos(this.doc, pos);"
 W !,"      var styles = getLineStyles(this, getLine(this.doc, pos.line));"
 W !,"      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;"
 W !,"      var type;"
 W !,"      if (ch == 0) type = styles[2];"
 W !,"      else for (;;) {"
 W !,"        var mid = (before + after) >> 1;"
 W !,"        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;"
 W !,"        else if (styles[mid * 2 + 1] < ch) before = mid + 1;"
 W !,"        else { type = styles[mid * 2 + 2]; break; }"
 W !,"      }"
 W !,"      var cut = type ? type.indexOf(""cm-overlay "") : -1;"
 W !,"      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);"
 W !,"    },"

 W !,"    getModeAt: function(pos) {"
 W !,"      var mode = this.doc.mode;"
 W !,"      if (!mode.innerMode) return mode;"
 W !,"      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;"
 W !,"    },"

 W !,"    getHelper: function(pos, type) {"
 W !,"      return this.getHelpers(pos, type)[0];"
 W !,"    },"

 W !,"    getHelpers: function(pos, type) {"
 W !,"      var found = [];"
 W !,"      if (!helpers.hasOwnProperty(type)) return found;"
 W !,"      var help = helpers[type], mode = this.getModeAt(pos);"
 W !,"      if (typeof mode[type] == ""string"") {"
 W !,"        if (help[mode[type]]) found.push(help[mode[type]]);"
 W !,"      } else if (mode[type]) {"
 W !,"        for (var i = 0; i < mode[type].length; i++) {"
 W !,"          var val = help[mode[type][i]];"
 W !,"          if (val) found.push(val);"
 W !,"        }"
 W !,"      } else if (mode.helperType && help[mode.helperType]) {"
 W !,"        found.push(help[mode.helperType]);"
 W !,"      } else if (help[mode.name]) {"
 W !,"        found.push(help[mode.name]);"
 W !,"      }"
 W !,"      for (var i = 0; i < help._global.length; i++) {"
 W !,"        var cur = help._global[i];"
 W !,"        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)"
 W !,"          found.push(cur.val);"
 W !,"      }"
 W !,"      return found;"
 W !,"    },"

 W !,"    getStateAfter: function(line, precise) {"
 W !,"      var doc = this.doc;"
 W !,"      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);"
 W !,"      return getStateBefore(this, line + 1, precise);"
 W !,"    },"

 W !,"    cursorCoords: function(start, mode) {"
 W !,"      var pos, range = this.doc.sel.primary();"
 W !,"      if (start == null) pos = range.head;"
 W !,"      else if (typeof start == ""object"") pos = clipPos(this.doc, start);"
 W !,"      else pos = start ? range.from() : range.to();"
 W !,"      return cursorCoords(this, pos, mode || ""page"");"
 W !,"    },"

 W !,"    charCoords: function(pos, mode) {"
 W !,"      return charCoords(this, clipPos(this.doc, pos), mode || ""page"");"
 W !,"    },"

 W !,"    coordsChar: function(coords, mode) {"
 W !,"      coords = fromCoordSystem(this, coords, mode || ""page"");"
 W !,"      return coordsChar(this, coords.left, coords.top);"
 W !,"    },"

 W !,"    lineAtHeight: function(height, mode) {"
 W !,"      height = fromCoordSystem(this, {top: height, left: 0}, mode || ""page"").top;"
 W !,"      return lineAtHeight(this.doc, height + this.display.viewOffset);"
 W !,"    },"
 W !,"    heightAtLine: function(line, mode) {"
 W !,"      var end = false, lineObj;"
 W !,"      if (typeof line == ""number"") {"
 W !,"        var last = this.doc.first + this.doc.size - 1;"
 W !,"        if (line < this.doc.first) line = this.doc.first;"
 W !,"        else if (line > last) { line = last; end = true; }"
 W !,"        lineObj = getLine(this.doc, line);"
 W !,"      } else {"
 W !,"        lineObj = line;"
 W !,"      }"
 W !,"      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || ""page"").top +"
 W !,"        (end ? this.doc.height - heightAtLine(lineObj) : 0);"
 W !,"    },"

 W !,"    defaultTextHeight: function() { return textHeight(this.display); },"
 W !,"    defaultCharWidth: function() { return charWidth(this.display); },"

 W !,"    setGutterMarker: methodOp(function(line, gutterID, value) {"
 W !,"      return changeLine(this.doc, line, ""gutter"", function(line) {"
 W !,"        var markers = line.gutterMarkers || (line.gutterMarkers = {});"
 W !,"        markers[gutterID] = value;"
 W !,"        if (!value && isEmpty(markers)) line.gutterMarkers = null;"
 W !,"        return true;"
 W !,"      });"
 W !,"    }),"

 W !,"    clearGutter: methodOp(function(gutterID) {"
 W !,"      var cm = this, doc = cm.doc, i = doc.first;"
 W !,"      doc.iter(function(line) {"
 W !,"        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {"
 W !,"          line.gutterMarkers[gutterID] = null;"
 W !,"          regLineChange(cm, i, ""gutter"");"
 W !,"          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;"
 W !,"        }"
 W !,"        ++i;"
 W !,"      });"
 W !,"    }),"

 W !,"    lineInfo: function(line) {"
 W !,"      if (typeof line == ""number"") {"
 W !,"        if (!isLine(this.doc, line)) return null;"
 W !,"        var n = line;"
 W !,"        line = getLine(this.doc, line);"
 W !,"        if (!line) return null;"
 W !,"      } else {"
 W !,"        var n = lineNo(line);"
 W !,"        if (n == null) return null;"
 W !,"      }"
 W !,"      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,"
 W !,"              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,"
 W !,"              widgets: line.widgets};"
 W !,"    },"

 W !,"    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},"

 W !,"    addWidget: function(pos, node, scroll, vert, horiz) {"
 W !,"      var display = this.display;"
 W !,"      pos = cursorCoords(this, clipPos(this.doc, pos));"
 W !,"      var top = pos.bottom, left = pos.left;"
 W !,"      node.style.position = ""absolute"";"
 W !,"      node.setAttribute(""cm-ignore-events"", ""true"");"
 W !,"      this.display.input.setUneditable(node);"
 W !,"      display.sizer.appendChild(node);"
 W !,"      if (vert == ""over"") {"
 W !,"        top = pos.top;"
 W !,"      } else if (vert == ""above"" || vert == ""near"") {"
 W !,"        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),"
 W !,"        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);"
 W !,"        // Default to positioning above (if specified and possible); otherwise default to positioning below"
 W !,"        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)"
 W !,"          top = pos.top - node.offsetHeight;"
 W !,"        else if (pos.bottom + node.offsetHeight <= vspace)"
 W !,"          top = pos.bottom;"
 W !,"        if (left + node.offsetWidth > hspace)"
 W !,"          left = hspace - node.offsetWidth;"
 W !,"      }"
 W !,"      node.style.top = top + ""px"";"
 W !,"      node.style.left = node.style.right = """";"
 W !,"      if (horiz == ""right"") {"
 W !,"        left = display.sizer.clientWidth - node.offsetWidth;"
 W !,"        node.style.right = ""0px"";"
 W !,"      } else {"
 W !,"        if (horiz == ""left"") left = 0;"
 W !,"        else if (horiz == ""middle"") left = (display.sizer.clientWidth - node.offsetWidth) / 2;"
 W !,"        node.style.left = left + ""px"";"
 W !,"      }"
 W !,"      if (scroll)"
 W !,"        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);"
 W !,"    },"

 W !,"    triggerOnKeyDown: methodOp(onKeyDown),"
 W !,"    triggerOnKeyPress: methodOp(onKeyPress),"
 W !,"    triggerOnKeyUp: onKeyUp,"

 W !,"    execCommand: function(cmd) {"
 W !,"      if (commands.hasOwnProperty(cmd))"
 W !,"        return commands[cmd].call(null, this);"
 W !,"    },"

 W !,"    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),"

 W !,"    findPosH: function(from, amount, unit, visually) {"
 W !,"      var dir = 1;"
 W !,"      if (amount < 0) { dir = -1; amount = -amount; }"
 W !,"      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {"
 W !,"        cur = findPosH(this.doc, cur, dir, unit, visually);"
 W !,"        if (cur.hitSide) break;"
 W !,"      }"
 W !,"      return cur;"
 W !,"    },"

 W !,"    moveH: methodOp(function(dir, unit) {"
 W !,"      var cm = this;"
 W !,"      cm.extendSelectionsBy(function(range) {"
 W !,"        if (cm.display.shift || cm.doc.extend || range.empty())"
 W !,"          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);"
 W !,"        else"
 W !,"          return dir < 0 ? range.from() : range.to();"
 W !,"      }, sel_move);"
 W !,"    }),"

 W !,"    deleteH: methodOp(function(dir, unit) {"
 W !,"      var sel = this.doc.sel, doc = this.doc;"
 W !,"      if (sel.somethingSelected())"
 W !,"        doc.replaceSelection("""", null, ""+delete"");"
 W !,"      else"
 W !,"        deleteNearSelection(this, function(range) {"
 W !,"          var other = findPosH(doc, range.head, dir, unit, false);"
 W !,"          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};"
 W !,"        });"
 W !,"    }),"

 W !,"    findPosV: function(from, amount, unit, goalColumn) {"
 W !,"      var dir = 1, x = goalColumn;"
 W !,"      if (amount < 0) { dir = -1; amount = -amount; }"
 W !,"      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {"
 W !,"        var coords = cursorCoords(this, cur, ""div"");"
 W !,"        if (x == null) x = coords.left;"
 W !,"        else coords.left = x;"
 W !,"        cur = findPosV(this, coords, dir, unit);"
 W !,"        if (cur.hitSide) break;"
 W !,"      }"
 W !,"      return cur;"
 W !,"    },"

 W !,"    moveV: methodOp(function(dir, unit) {"
 W !,"      var cm = this, doc = this.doc, goals = [];"
 W !,"      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();"
 W !,"      doc.extendSelectionsBy(function(range) {"
 W !,"        if (collapse)"
 W !,"          return dir < 0 ? range.from() : range.to();"
 W !,"        var headPos = cursorCoords(cm, range.head, ""div"");"
 W !,"        if (range.goalColumn != null) headPos.left = range.goalColumn;"
 W !,"        goals.push(headPos.left);"
 W !,"        var pos = findPosV(cm, headPos, dir, unit);"
 W !,"        if (unit == ""page"" && range == doc.sel.primary())"
 W !,"          addToScrollPos(cm, null, charCoords(cm, pos, ""div"").top - headPos.top);"
 W !,"        return pos;"
 W !,"      }, sel_move);"
 W !,"      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)"
 W !,"        doc.sel.ranges[i].goalColumn = goals[i];"
 W !,"    }),"

 W !,"    // Find the word at the given position (as returned by coordsChar)."
 W !,"    findWordAt: function(pos) {"
 W !,"      var doc = this.doc, line = getLine(doc, pos.line).text;"
 W !,"      var start = pos.ch, end = pos.ch;"
 W !,"      if (line) {"
 W !,"        var helper = this.getHelper(pos, ""wordChars"");"
 W !,"        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;"
 W !,"        var startChar = line.charAt(start);"
 W !,"        var check = isWordChar(startChar, helper)"
 W !,"          ? function(ch) { return isWordChar(ch, helper); }"
 W !,"          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}"
 W !,"          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};"
 W !,"        while (start > 0 && check(line.charAt(start - 1))) --start;"
 W !,"        while (end < line.length && check(line.charAt(end))) ++end;"
 W !,"      }"
 W !,"      return new Range(Pos(pos.line, start), Pos(pos.line, end));"
 W !,"    },"

 W !,"    toggleOverwrite: function(value) {"
 W !,"      if (value != null && value == this.state.overwrite) return;"
 W !,"      if (this.state.overwrite = !this.state.overwrite)"
 W !,"        addClass(this.display.cursorDiv, ""CodeMirror-overwrite"");"
 W !,"      else"
 W !,"        rmClass(this.display.cursorDiv, ""CodeMirror-overwrite"");"

 W !,"      signal(this, ""overwriteToggle"", this, this.state.overwrite);"
 W !,"    },"
 W !,"    hasFocus: function() { return this.display.input.getField() == activeElt(); },"
 W !,"    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },"

 W !,"    scrollTo: methodOp(function(x, y) {"
 W !,"      if (x != null || y != null) resolveScrollToPos(this);"
 W !,"      if (x != null) this.curOp.scrollLeft = x;"
 W !,"      if (y != null) this.curOp.scrollTop = y;"
 W !,"    }),"
 W !,"    getScrollInfo: function() {"
 W !,"      var scroller = this.display.scroller;"
 W !,"      return {left: scroller.scrollLeft, top: scroller.scrollTop,"
 W !,"              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,"
 W !,"              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,"
 W !,"              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};"
 W !,"    },"

 W !,"    scrollIntoView: methodOp(function(range, margin) {"
 W !,"      if (range == null) {"
 W !,"        range = {from: this.doc.sel.primary().head, to: null};"
 W !,"        if (margin == null) margin = this.options.cursorScrollMargin;"
 W !,"      } else if (typeof range == ""number"") {"
 W !,"        range = {from: Pos(range, 0), to: null};"
 W !,"      } else if (range.from == null) {"
 W !,"        range = {from: range, to: null};"
 W !,"      }"
 W !,"      if (!range.to) range.to = range.from;"
 W !,"      range.margin = margin || 0;"

 W !,"      if (range.from.line != null) {"
 W !,"        resolveScrollToPos(this);"
 W !,"        this.curOp.scrollToPos = range;"
 W !,"      } else {"
 W !,"        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),"
 W !,"                                      Math.min(range.from.top, range.to.top) - range.margin,"
 W !,"                                      Math.max(range.from.right, range.to.right),"
 W !,"                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);"
 W !,"        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);"
 W !,"      }"
 W !,"    }),"

 W !,"    setSize: methodOp(function(width, height) {"
 W !,"      var cm = this;"
 W !,"      function interpret(val) {"
 W !,"        return typeof val == ""number"" || /^\d+$/.test(String(val)) ? val + ""px"" : val;"
 W !,"      }"
 W !,"      if (width != null) cm.display.wrapper.style.width = interpret(width);"
 W !,"      if (height != null) cm.display.wrapper.style.height = interpret(height);"
 W !,"      if (cm.options.lineWrapping) clearLineMeasurementCache(this);"
 W !,"      var lineNo = cm.display.viewFrom;"
 W !,"      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {"
 W !,"        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)"
 W !,"          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, ""widget""); break; }"
 W !,"        ++lineNo;"
 W !,"      });"
 W !,"      cm.curOp.forceUpdate = true;"
 W !,"      signal(cm, ""refresh"", this);"
 W !,"    }),"

 W !,"    operation: function(f){return runInOp(this, f);},"

 W !,"    refresh: methodOp(function() {"
 W !,"      var oldHeight = this.display.cachedTextHeight;"
 W !,"      regChange(this);"
 W !,"      this.curOp.forceUpdate = true;"
 W !,"      clearCaches(this);"
 W !,"      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);"
 W !,"      updateGutterSpace(this);"
 W !,"      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)"
 W !,"        estimateLineHeights(this);"
 W !,"      signal(this, ""refresh"", this);"
 W !,"    }),"

 W !,"    swapDoc: methodOp(function(doc) {"
 W !,"      var old = this.doc;"
 W !,"      old.cm = null;"
 W !,"      attachDoc(this, doc);"
 W !,"      clearCaches(this);"
 W !,"      this.display.input.reset();"
 W !,"      this.scrollTo(doc.scrollLeft, doc.scrollTop);"
 W !,"      this.curOp.forceScroll = true;"
 W !,"      signalLater(this, ""swapDoc"", this, old);"
 W !,"      return old;"
 W !,"    }),"

 W !,"    getInputField: function(){return this.display.input.getField();},"
 W !,"    getWrapperElement: function(){return this.display.wrapper;},"
 W !,"    getScrollerElement: function(){return this.display.scroller;},"
 W !,"    getGutterElement: function(){return this.display.gutters;}"
 W !,"  };"
 W !,"  eventMixin(CodeMirror);"

 W !,"  // OPTION DEFAULTS"

 W !,"  // The default configuration options."
 W !,"  var defaults = CodeMirror.defaults = {};"
 W !,"  // Functions to run when options are changed."
 W !,"  var optionHandlers = CodeMirror.optionHandlers = {};"
}

ClassMethod ScriptLibCodemirror9()
{
 W !,"  function option(name, deflt, handle, notOnInit) {"
 W !,"    CodeMirror.defaults[name] = deflt;"
 W !,"    if (handle) optionHandlers[name] ="
 W !,"      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;"
 W !,"  }"

 W !,"  // Passed to option handlers when there is no old value."
 W !,"  var Init = CodeMirror.Init = {toString: function(){return ""CodeMirror.Init"";}};"

 W !,"  // These two are, on init, called from the constructor because they"
 W !,"  // have to be initialized before the editor can start at all."
 W !,"  option(""value"", """", function(cm, val) {"
 W !,"    cm.setValue(val);"
 W !,"  }, true);"
 W !,"  option(""mode"", null, function(cm, val) {"
 W !,"    cm.doc.modeOption = val;"
 W !,"    loadMode(cm);"
 W !,"  }, true);"

 W !,"  option(""indentUnit"", 2, loadMode, true);"
 W !,"  option(""indentWithTabs"", false);"
 W !,"  option(""smartIndent"", true);"
 W !,"  option(""tabSize"", 4, function(cm) {"
 W !,"    resetModeState(cm);"
 W !,"    clearCaches(cm);"
 W !,"    regChange(cm);"
 W !,"  }, true);"
 W !,"  option(""lineSeparator"", null, function(cm, val) {"
 W !,"    cm.doc.lineSep = val;"
 W !,"    if (!val) return;"
 W !,"    var newBreaks = [], lineNo = cm.doc.first;"
 W !,"    cm.doc.iter(function(line) {"
 W !,"      for (var pos = 0;;) {"
 W !,"        var found = line.text.indexOf(val, pos);"
 W !,"        if (found == -1) break;"
 W !,"        pos = found + val.length;"
 W !,"        newBreaks.push(Pos(lineNo, found));"
 W !,"      }"
 W !,"      lineNo++;"
 W !,"    });"
 W !,"    for (var i = newBreaks.length - 1; i >= 0; i--)"
 W !,"      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))"
 W !,"  });"
 W !,"  option(""specialChars"", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {"
 W !,"    cm.state.specialChars = new RegExp(val.source + (val.test(""\t"") ? """" : ""|\t""), ""g"");"
 W !,"    if (old != CodeMirror.Init) cm.refresh();"
 W !,"  });"
 W !,"  option(""specialCharPlaceholder"", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);"
 W !,"  option(""electricChars"", true);"
 W !,"  option(""inputStyle"", mobile ? ""contenteditable"" : ""textarea"", function() {"
 W !,"    throw new Error(""inputStyle can not (yet) be changed in a running editor""); // FIXME"
 W !,"  }, true);"
 W !,"  option(""rtlMoveVisually"", !windows);"
 W !,"  option(""wholeLineUpdateBefore"", true);"

 W !,"  option(""theme"", ""default"", function(cm) {"
 W !,"    themeChanged(cm);"
 W !,"    guttersChanged(cm);"
 W !,"  }, true);"
 W !,"  option(""keyMap"", ""default"", function(cm, val, old) {"
 W !,"    var next = getKeyMap(val);"
 W !,"    var prev = old != CodeMirror.Init && getKeyMap(old);"
 W !,"    if (prev && prev.detach) prev.detach(cm, next);"
 W !,"    if (next.attach) next.attach(cm, prev || null);"
 W !,"  });"
 W !,"  option(""extraKeys"", null);"

 W !,"  option(""lineWrapping"", false, wrappingChanged, true);"
 W !,"  option(""gutters"", [], function(cm) {"
 W !,"    setGuttersForLineNumbers(cm.options);"
 W !,"    guttersChanged(cm);"
 W !,"  }, true);"
 W !,"  option(""fixedGutter"", true, function(cm, val) {"
 W !,"    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + ""px"" : ""0"";"
 W !,"    cm.refresh();"
 W !,"  }, true);"
 W !,"  option(""coverGutterNextToScrollbar"", false, function(cm) {updateScrollbars(cm);}, true);"
 W !,"  option(""scrollbarStyle"", ""native"", function(cm) {"
 W !,"    initScrollbars(cm);"
 W !,"    updateScrollbars(cm);"
 W !,"    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);"
 W !,"    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);"
 W !,"  }, true);"
 W !,"  option(""lineNumbers"", false, function(cm) {"
 W !,"    setGuttersForLineNumbers(cm.options);"
 W !,"    guttersChanged(cm);"
 W !,"  }, true);"
 W !,"  option(""firstLineNumber"", 1, guttersChanged, true);"
 W !,"  option(""lineNumberFormatter"", function(integer) {return integer;}, guttersChanged, true);"
 W !,"  option(""showCursorWhenSelecting"", false, updateSelection, true);"

 W !,"  option(""resetSelectionOnContextMenu"", true);"
 W !,"  option(""lineWiseCopyCut"", true);"

 W !,"  option(""readOnly"", false, function(cm, val) {"
 W !,"    if (val == ""nocursor"") {"
 W !,"      onBlur(cm);"
 W !,"      cm.display.input.blur();"
 W !,"      cm.display.disabled = true;"
 W !,"    } else {"
 W !,"      cm.display.disabled = false;"
 W !,"    }"
 W !,"    cm.display.input.readOnlyChanged(val)"
 W !,"  });"
 W !,"  option(""disableInput"", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);"
 W !,"  option(""dragDrop"", true, dragDropChanged);"
 W !,"  option(""allowDropFileTypes"", null);"

 W !,"  option(""cursorBlinkRate"", 530);"
 W !,"  option(""cursorScrollMargin"", 0);"
 W !,"  option(""cursorHeight"", 1, updateSelection, true);"
 W !,"  option(""singleCursorHeightPerLine"", true, updateSelection, true);"
 W !,"  option(""workTime"", 100);"
 W !,"  option(""workDelay"", 100);"
 W !,"  option(""flattenSpans"", true, resetModeState, true);"
 W !,"  option(""addModeClass"", false, resetModeState, true);"
 W !,"  option(""pollInterval"", 100);"
 W !,"  option(""undoDepth"", 200, function(cm, val){cm.doc.history.undoDepth = val;});"
 W !,"  option(""historyEventDelay"", 1250);"
 W !,"  option(""viewportMargin"", 10, function(cm){cm.refresh();}, true);"
 W !,"  option(""maxHighlightLength"", 10000, resetModeState, true);"
 W !,"  option(""moveInputWithCursor"", true, function(cm, val) {"
 W !,"    if (!val) cm.display.input.resetPosition();"
 W !,"  });"

 W !,"  option(""tabindex"", null, function(cm, val) {"
 W !,"    cm.display.input.getField().tabIndex = val || """";"
 W !,"  });"
 W !,"  option(""autofocus"", null);"

 W !,"  // MODE DEFINITION AND QUERYING"

 W !,"  // Known modes, by name and by MIME"
 W !,"  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};"

 W !,"  // Extra arguments are stored as the mode's dependencies, which is"
 W !,"  // used by (legacy) mechanisms like loadmode.js to automatically"
 W !,"  // load a mode. (Preferred mechanism is the require/define calls.)"
 W !,"  CodeMirror.defineMode = function(name, mode) {"
 W !,"    if (!CodeMirror.defaults.mode && name != ""null"") CodeMirror.defaults.mode = name;"
 W !,"    if (arguments.length > 2)"
 W !,"      mode.dependencies = Array.prototype.slice.call(arguments, 2);"
 W !,"    modes[name] = mode;"
 W !,"  };"

 W !,"  CodeMirror.defineMIME = function(mime, spec) {"
 W !,"    mimeModes[mime] = spec;"
 W !,"  };"

 W !,"  // Given a MIME type, a {name, ...options} config object, or a name"
 W !,"  // string, return a mode config object."
 W !,"  CodeMirror.resolveMode = function(spec) {"
 W !,"    if (typeof spec == ""string"" && mimeModes.hasOwnProperty(spec)) {"
 W !,"      spec = mimeModes[spec];"
 W !,"    } else if (spec && typeof spec.name == ""string"" && mimeModes.hasOwnProperty(spec.name)) {"
 W !,"      var found = mimeModes[spec.name];"
 W !,"      if (typeof found == ""string"") found = {name: found};"
 W !,"      spec = createObj(found, spec);"
 W !,"      spec.name = found.name;"
 W !,"    } else if (typeof spec == ""string"" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {"
 W !,"      return CodeMirror.resolveMode(""application/xml"");"
 W !,"    }"
 W !,"    if (typeof spec == ""string"") return {name: spec};"
 W !,"    else return spec || {name: ""null""};"
 W !,"  };"

 W !,"  // Given a mode spec (anything that resolveMode accepts), find and"
 W !,"  // initialize an actual mode object."
 W !,"  CodeMirror.getMode = function(options, spec) {"
 W !,"    var spec = CodeMirror.resolveMode(spec);"
 W !,"    var mfactory = modes[spec.name];"
 W !,"    if (!mfactory) return CodeMirror.getMode(options, ""text/plain"");"
 W !,"    var modeObj = mfactory(options, spec);"
 W !,"    if (modeExtensions.hasOwnProperty(spec.name)) {"
 W !,"      var exts = modeExtensions[spec.name];"
 W !,"      for (var prop in exts) {"
 W !,"        if (!exts.hasOwnProperty(prop)) continue;"
 W !,"        if (modeObj.hasOwnProperty(prop)) modeObj[""_"" + prop] = modeObj[prop];"
 W !,"        modeObj[prop] = exts[prop];"
 W !,"      }"
 W !,"    }"
 W !,"    modeObj.name = spec.name;"
 W !,"    if (spec.helperType) modeObj.helperType = spec.helperType;"
 W !,"    if (spec.modeProps) for (var prop in spec.modeProps)"
 W !,"      modeObj[prop] = spec.modeProps[prop];"

 W !,"    return modeObj;"
 W !,"  };"

 W !,"  // Minimal default mode."
 W !,"  CodeMirror.defineMode(""null"", function() {"
 W !,"    return {token: function(stream) {stream.skipToEnd();}};"
 W !,"  });"
 W !,"  CodeMirror.defineMIME(""text/plain"", ""null"");"

 W !,"  // This can be used to attach properties to mode objects from"
 W !,"  // outside the actual mode definition."
 W !,"  var modeExtensions = CodeMirror.modeExtensions = {};"
 W !,"  CodeMirror.extendMode = function(mode, properties) {"
 W !,"    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});"
 W !,"    copyObj(properties, exts);"
 W !,"  };"

 W !,"  // EXTENSIONS"

 W !,"  CodeMirror.defineExtension = function(name, func) {"
 W !,"    CodeMirror.prototype[name] = func;"
 W !,"  };"
 W !,"  CodeMirror.defineDocExtension = function(name, func) {"
 W !,"    Doc.prototype[name] = func;"
 W !,"  };"
 W !,"  CodeMirror.defineOption = option;"

 W !,"  var initHooks = [];"
 W !,"  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};"

 W !,"  var helpers = CodeMirror.helpers = {};"
 W !,"  CodeMirror.registerHelper = function(type, name, value) {"
 W !,"    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};"
 W !,"    helpers[type][name] = value;"
 W !,"  };"
 W !,"  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {"
 W !,"    CodeMirror.registerHelper(type, name, value);"
 W !,"    helpers[type]._global.push({pred: predicate, val: value});"
 W !,"  };"

 W !,"  // MODE STATE HANDLING"

 W !,"  // Utility functions for working with state. Exported because nested"
 W !,"  // modes need to do this for their inner modes."

 W !,"  var copyState = CodeMirror.copyState = function(mode, state) {"
 W !,"    if (state === true) return state;"
 W !,"    if (mode.copyState) return mode.copyState(state);"
 W !,"    var nstate = {};"
 W !,"    for (var n in state) {"
 W !,"      var val = state[n];"
 W !,"      if (val instanceof Array) val = val.concat([]);"
 W !,"      nstate[n] = val;"
 W !,"    }"
 W !,"    return nstate;"
 W !,"  };"

 W !,"  var startState = CodeMirror.startState = function(mode, a1, a2) {"
 W !,"    return mode.startState ? mode.startState(a1, a2) : true;"
 W !,"  };"

 W !,"  // Given a mode and a state (for that mode), find the inner mode and"
 W !,"  // state at the position that the state refers to."
 W !,"  CodeMirror.innerMode = function(mode, state) {"
 W !,"    while (mode.innerMode) {"
 W !,"      var info = mode.innerMode(state);"
 W !,"      if (!info || info.mode == mode) break;"
 W !,"      state = info.state;"
 W !,"      mode = info.mode;"
 W !,"    }"
 W !,"    return info || {mode: mode, state: state};"
 W !,"  };"

 W !,"  // STANDARD COMMANDS"

 W !,"  // Commands are parameter-less actions that can be performed on an"
 W !,"  // editor, mostly used for keybindings."
 W !,"  var commands = CodeMirror.commands = {"
 W !,"    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},"
 W !,"    singleSelection: function(cm) {"
 W !,"      cm.setSelection(cm.getCursor(""anchor""), cm.getCursor(""head""), sel_dontScroll);"
 W !,"    },"
 W !,"    killLine: function(cm) {"
 W !,"      deleteNearSelection(cm, function(range) {"
 W !,"        if (range.empty()) {"
 W !,"          var len = getLine(cm.doc, range.head.line).text.length;"
 W !,"          if (range.head.ch == len && range.head.line < cm.lastLine())"
 W !,"            return {from: range.head, to: Pos(range.head.line + 1, 0)};"
 W !,"          else"
 W !,"            return {from: range.head, to: Pos(range.head.line, len)};"
 W !,"        } else {"
 W !,"          return {from: range.from(), to: range.to()};"
 W !,"        }"
 W !,"      });"
 W !,"    },"
 W !,"    deleteLine: function(cm) {"
 W !,"      deleteNearSelection(cm, function(range) {"
 W !,"        return {from: Pos(range.from().line, 0),"
 W !,"                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};"
 W !,"      });"
 W !,"    },"
 W !,"    delLineLeft: function(cm) {"
 W !,"      deleteNearSelection(cm, function(range) {"
 W !,"        return {from: Pos(range.from().line, 0), to: range.from()};"
 W !,"      });"
 W !,"    },"
 W !,"    delWrappedLineLeft: function(cm) {"
 W !,"      deleteNearSelection(cm, function(range) {"
 W !,"        var top = cm.charCoords(range.head, ""div"").top + 5;"
 W !,"        var leftPos = cm.coordsChar({left: 0, top: top}, ""div"");"
 W !,"        return {from: leftPos, to: range.from()};"
 W !,"      });"
 W !,"    },"
 W !,"    delWrappedLineRight: function(cm) {"
 W !,"      deleteNearSelection(cm, function(range) {"
 W !,"        var top = cm.charCoords(range.head, ""div"").top + 5;"
 W !,"        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, ""div"");"
 W !,"        return {from: range.from(), to: rightPos };"
 W !,"      });"
 W !,"    },"
 W !,"    undo: function(cm) {cm.undo();},"
 W !,"    redo: function(cm) {cm.redo();},"
 W !,"    undoSelection: function(cm) {cm.undoSelection();},"
 W !,"    redoSelection: function(cm) {cm.redoSelection();},"
 W !,"    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},"
 W !,"    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},"
 W !,"    goLineStart: function(cm) {"
 W !,"      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },"
 W !,"                            {origin: ""+move"", bias: 1});"
 W !,"    },"
 W !,"    goLineStartSmart: function(cm) {"
 W !,"      cm.extendSelectionsBy(function(range) {"
 W !,"        return lineStartSmart(cm, range.head);"
 W !,"      }, {origin: ""+move"", bias: 1});"
 W !,"    },"
 W !,"    goLineEnd: function(cm) {"
 W !,"      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },"
 W !,"                            {origin: ""+move"", bias: -1});"
 W !,"    },"
 W !,"    goLineRight: function(cm) {"
 W !,"      cm.extendSelectionsBy(function(range) {"
 W !,"        var top = cm.charCoords(range.head, ""div"").top + 5;"
 W !,"        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, ""div"");"
 W !,"      }, sel_move);"
 W !,"    },"
 W !,"    goLineLeft: function(cm) {"
 W !,"      cm.extendSelectionsBy(function(range) {"
 W !,"        var top = cm.charCoords(range.head, ""div"").top + 5;"
 W !,"        return cm.coordsChar({left: 0, top: top}, ""div"");"
 W !,"      }, sel_move);"
 W !,"    },"
 W !,"    goLineLeftSmart: function(cm) {"
 W !,"      cm.extendSelectionsBy(function(range) {"
 W !,"        var top = cm.charCoords(range.head, ""div"").top + 5;"
 W !,"        var pos = cm.coordsChar({left: 0, top: top}, ""div"");"
 W !,"        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);"
 W !,"        return pos;"
 W !,"      }, sel_move);"
 W !,"    },"
 W !,"    goLineUp: function(cm) {cm.moveV(-1, ""line"");},"
 W !,"    goLineDown: function(cm) {cm.moveV(1, ""line"");},"
 W !,"    goPageUp: function(cm) {cm.moveV(-1, ""page"");},"
 W !,"    goPageDown: function(cm) {cm.moveV(1, ""page"");},"
 W !,"    goCharLeft: function(cm) {cm.moveH(-1, ""char"");},"
 W !,"    goCharRight: function(cm) {cm.moveH(1, ""char"");},"
 W !,"    goColumnLeft: function(cm) {cm.moveH(-1, ""column"");},"
 W !,"    goColumnRight: function(cm) {cm.moveH(1, ""column"");},"
 W !,"    goWordLeft: function(cm) {cm.moveH(-1, ""word"");},"
 W !,"    goGroupRight: function(cm) {cm.moveH(1, ""group"");},"
 W !,"    goGroupLeft: function(cm) {cm.moveH(-1, ""group"");},"
 W !,"    goWordRight: function(cm) {cm.moveH(1, ""word"");},"
 W !,"    delCharBefore: function(cm) {cm.deleteH(-1, ""char"");},"
 W !,"    delCharAfter: function(cm) {cm.deleteH(1, ""char"");},"
 W !,"    delWordBefore: function(cm) {cm.deleteH(-1, ""word"");},"
 W !,"    delWordAfter: function(cm) {cm.deleteH(1, ""word"");},"
 W !,"    delGroupBefore: function(cm) {cm.deleteH(-1, ""group"");},"
 W !,"    delGroupAfter: function(cm) {cm.deleteH(1, ""group"");},"
 W !,"    indentAuto: function(cm) {cm.indentSelection(""smart"");},"
 W !,"    indentMore: function(cm) {cm.indentSelection(""add"");},"
 W !,"    indentLess: function(cm) {cm.indentSelection(""subtract"");},"
 W !,"    insertTab: function(cm) {cm.replaceSelection(""\t"");},"
 W !,"    insertSoftTab: function(cm) {"
 W !,"      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;"
 W !,"      for (var i = 0; i < ranges.length; i++) {"
 W !,"        var pos = ranges[i].from();"
 W !,"        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);"
 W !,"        spaces.push(new Array(tabSize - col % tabSize + 1).join("" ""));"
 W !,"      }"
 W !,"      cm.replaceSelections(spaces);"
 W !,"    },"
 W !,"    defaultTab: function(cm) {"
 W !,"      if (cm.somethingSelected()) cm.indentSelection(""add"");"
 W !,"      else cm.execCommand(""insertTab"");"
 W !,"    },"
 W !,"    transposeChars: function(cm) {"
 W !,"      runInOp(cm, function() {"
 W !,"        var ranges = cm.listSelections(), newSel = [];"
 W !,"        for (var i = 0; i < ranges.length; i++) {"
 W !,"          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;"
 W !,"          if (line) {"
 W !,"            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);"
 W !,"            if (cur.ch > 0) {"
 W !,"              cur = new Pos(cur.line, cur.ch + 1);"
 W !,"              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),"
 W !,"                              Pos(cur.line, cur.ch - 2), cur, ""+transpose"");"
 W !,"            } else if (cur.line > cm.doc.first) {"
 W !,"              var prev = getLine(cm.doc, cur.line - 1).text;"
 W !,"              if (prev)"
 W !,"                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +"
 W !,"                                prev.charAt(prev.length - 1),"
 W !,"                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), ""+transpose"");"
 W !,"            }"
 W !,"          }"
 W !,"          newSel.push(new Range(cur, cur));"
 W !,"        }"
 W !,"        cm.setSelections(newSel);"
 W !,"      });"
 W !,"    },"
 W !,"    newlineAndIndent: function(cm) {"
 W !,"      runInOp(cm, function() {"
 W !,"        var len = cm.listSelections().length;"
 W !,"        for (var i = 0; i < len; i++) {"
 W !,"          var range = cm.listSelections()[i];"
 W !,"          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, ""+input"");"
 W !,"          cm.indentLine(range.from().line + 1, null, true);"
 W !,"        }"
 W !,"        ensureCursorVisible(cm);"
 W !,"      });"
 W !,"    },"
 W !,"    toggleOverwrite: function(cm) {cm.toggleOverwrite();}"
 W !,"  };"


 W !,"  // STANDARD KEYMAPS"

 W !,"  var keyMap = CodeMirror.keyMap = {};"

 W !,"  keyMap.basic = {"
 W !,"    ""Left"": ""goCharLeft"", ""Right"": ""goCharRight"", ""Up"": ""goLineUp"", ""Down"": ""goLineDown"","
 W !,"    ""End"": ""goLineEnd"", ""Home"": ""goLineStartSmart"", ""PageUp"": ""goPageUp"", ""PageDown"": ""goPageDown"","
 W !,"    ""Delete"": ""delCharAfter"", ""Backspace"": ""delCharBefore"", ""Shift-Backspace"": ""delCharBefore"","
 W !,"    ""Tab"": ""defaultTab"", ""Shift-Tab"": ""indentAuto"","
 W !,"    ""Enter"": ""newlineAndIndent"", ""Insert"": ""toggleOverwrite"","
 W !,"    ""Esc"": ""singleSelection"""
 W !,"  };"
 W !,"  // Note that the save and find-related commands aren't defined by"
 W !,"  // default. User code or addons can define them. Unknown commands"
 W !,"  // are simply ignored."
 W !,"  keyMap.pcDefault = {"
 W !,"    ""Ctrl-A"": ""selectAll"", ""Ctrl-D"": ""deleteLine"", ""Ctrl-Z"": ""undo"", ""Shift-Ctrl-Z"": ""redo"", ""Ctrl-Y"": ""redo"","
 W !,"    ""Ctrl-Home"": ""goDocStart"", ""Ctrl-End"": ""goDocEnd"", ""Ctrl-Up"": ""goLineUp"", ""Ctrl-Down"": ""goLineDown"","
 W !,"    ""Ctrl-Left"": ""goGroupLeft"", ""Ctrl-Right"": ""goGroupRight"", ""Alt-Left"": ""goLineStart"", ""Alt-Right"": ""goLineEnd"","
 W !,"    ""Ctrl-Backspace"": ""delGroupBefore"", ""Ctrl-Delete"": ""delGroupAfter"", ""Ctrl-S"": ""save"", ""Ctrl-F"": ""find"","
 W !,"    ""Ctrl-G"": ""findNext"", ""Shift-Ctrl-G"": ""findPrev"", ""Shift-Ctrl-F"": ""replace"", ""Shift-Ctrl-R"": ""replaceAll"","
 W !,"    ""Ctrl-["": ""indentLess"", ""Ctrl-]"": ""indentMore"","
 W !,"    ""Ctrl-U"": ""undoSelection"", ""Shift-Ctrl-U"": ""redoSelection"", ""Alt-U"": ""redoSelection"","
 W !,"    fallthrough: ""basic"""
 W !,"  };"
 W !,"  // Very basic readline/emacs-style bindings, which are standard on Mac."
 W !,"  keyMap.emacsy = {"
 W !,"    ""Ctrl-F"": ""goCharRight"", ""Ctrl-B"": ""goCharLeft"", ""Ctrl-P"": ""goLineUp"", ""Ctrl-N"": ""goLineDown"","
 W !,"    ""Alt-F"": ""goWordRight"", ""Alt-B"": ""goWordLeft"", ""Ctrl-A"": ""goLineStart"", ""Ctrl-E"": ""goLineEnd"","
 W !,"    ""Ctrl-V"": ""goPageDown"", ""Shift-Ctrl-V"": ""goPageUp"", ""Ctrl-D"": ""delCharAfter"", ""Ctrl-H"": ""delCharBefore"","
 W !,"    ""Alt-D"": ""delWordAfter"", ""Alt-Backspace"": ""delWordBefore"", ""Ctrl-K"": ""killLine"", ""Ctrl-T"": ""transposeChars"""
 W !,"  };"
 W !,"  keyMap.macDefault = {"
 W !,"    ""Cmd-A"": ""selectAll"", ""Cmd-D"": ""deleteLine"", ""Cmd-Z"": ""undo"", ""Shift-Cmd-Z"": ""redo"", ""Cmd-Y"": ""redo"","
 W !,"    ""Cmd-Home"": ""goDocStart"", ""Cmd-Up"": ""goDocStart"", ""Cmd-End"": ""goDocEnd"", ""Cmd-Down"": ""goDocEnd"", ""Alt-Left"": ""goGroupLeft"","
 W !,"    ""Alt-Right"": ""goGroupRight"", ""Cmd-Left"": ""goLineLeft"", ""Cmd-Right"": ""goLineRight"", ""Alt-Backspace"": ""delGroupBefore"","
 W !,"    ""Ctrl-Alt-Backspace"": ""delGroupAfter"", ""Alt-Delete"": ""delGroupAfter"", ""Cmd-S"": ""save"", ""Cmd-F"": ""find"","
 W !,"    ""Cmd-G"": ""findNext"", ""Shift-Cmd-G"": ""findPrev"", ""Cmd-Alt-F"": ""replace"", ""Shift-Cmd-Alt-F"": ""replaceAll"","
 W !,"    ""Cmd-["": ""indentLess"", ""Cmd-]"": ""indentMore"", ""Cmd-Backspace"": ""delWrappedLineLeft"", ""Cmd-Delete"": ""delWrappedLineRight"","
 W !,"    ""Cmd-U"": ""undoSelection"", ""Shift-Cmd-U"": ""redoSelection"", ""Ctrl-Up"": ""goDocStart"", ""Ctrl-Down"": ""goDocEnd"","
 W !,"    fallthrough: [""basic"", ""emacsy""]"
 W !,"  };"
 W !,"  keyMap[""default""] = mac ? keyMap.macDefault : keyMap.pcDefault;"

 W !,"  // KEYMAP DISPATCH"

 W !,"  function normalizeKeyName(name) {"
 W !,"    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];"
 W !,"    var alt, ctrl, shift, cmd;"
 W !,"    for (var i = 0; i < parts.length - 1; i++) {"
 W !,"      var mod = parts[i];"
 W !,"      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;"
 W !,"      else if (/^a(lt)?$/i.test(mod)) alt = true;"
 W !,"      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;"
 W !,"      else if (/^s(hift)$/i.test(mod)) shift = true;"
 W !,"      else throw new Error(""Unrecognized modifier name: "" + mod);"
 W !,"    }"
 W !,"    if (alt) name = ""Alt-"" + name;"
 W !,"    if (ctrl) name = ""Ctrl-"" + name;"
 W !,"    if (cmd) name = ""Cmd-"" + name;"
 W !,"    if (shift) name = ""Shift-"" + name;"
 W !,"    return name;"
 W !,"  }"

 W !,"  // This is a kludge to keep keymaps mostly working as raw objects"
 W !,"  // (backwards compatibility) while at the same time support features"
 W !,"  // like normalization and multi-stroke key bindings. It compiles a"
 W !,"  // new normalized keymap, and then updates the old object to reflect"
 W !,"  // this."
 W !,"  CodeMirror.normalizeKeyMap = function(keymap) {"
 W !,"    var copy = {};"
 W !,"    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {"
 W !,"      var value = keymap[keyname];"
 W !,"      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;"
 W !,"      if (value == ""..."") { delete keymap[keyname]; continue; }"

 W !,"      var keys = map(keyname.split("" ""), normalizeKeyName);"
 W !,"      for (var i = 0; i < keys.length; i++) {"
 W !,"        var val, name;"
 W !,"        if (i == keys.length - 1) {"
 W !,"          name = keys.join("" "");"
 W !,"          val = value;"
 W !,"        } else {"
 W !,"          name = keys.slice(0, i + 1).join("" "");"
 W !,"          val = ""..."";"
 W !,"        }"
 W !,"        var prev = copy[name];"
 W !,"        if (!prev) copy[name] = val;"
 W !,"        else if (prev != val) throw new Error(""Inconsistent bindings for "" + name);"
 W !,"      }"
 W !,"      delete keymap[keyname];"
 W !,"    }"
 W !,"    for (var prop in copy) keymap[prop] = copy[prop];"
 W !,"    return keymap;"
 W !,"  };"

 W !,"  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {"
 W !,"    map = getKeyMap(map);"
 W !,"    var found = map.call ? map.call(key, context) : map[key];"
 W !,"    if (found === false) return ""nothing"";"
 W !,"    if (found === ""..."") return ""multi"";"
 W !,"    if (found != null && handle(found)) return ""handled"";"

 W !,"    if (map.fallthrough) {"
 W !,"      if (Object.prototype.toString.call(map.fallthrough) != ""[object Array]"")"
 W !,"        return lookupKey(key, map.fallthrough, handle, context);"
 W !,"      for (var i = 0; i < map.fallthrough.length; i++) {"
 W !,"        var result = lookupKey(key, map.fallthrough[i], handle, context);"
 W !,"        if (result) return result;"
 W !,"      }"
 W !,"    }"
 W !,"  };"

 W !,"  // Modifier key presses don't count as 'real' key presses for the"
 W !,"  // purpose of keymap fallthrough."
 W !,"  var isModifierKey = CodeMirror.isModifierKey = function(value) {"
 W !,"    var name = typeof value == ""string"" ? value : keyNames[value.keyCode];"
 W !,"    return name == ""Ctrl"" || name == ""Alt"" || name == ""Shift"" || name == ""Mod"";"
 W !,"  };"

 W !,"  // Look up the name of a key as indicated by an event object."
 W !,"  var keyName = CodeMirror.keyName = function(event, noShift) {"
 W !,"    if (presto && event.keyCode == 34 && event[""char""]) return false;"
 W !,"    var base = keyNames[event.keyCode], name = base;"
 W !,"    if (name == null || event.altGraphKey) return false;"
 W !,"    if (event.altKey && base != ""Alt"") name = ""Alt-"" + name;"
 W !,"    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != ""Ctrl"") name = ""Ctrl-"" + name;"
 W !,"    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != ""Cmd"") name = ""Cmd-"" + name;"
 W !,"    if (!noShift && event.shiftKey && base != ""Shift"") name = ""Shift-"" + name;"
 W !,"    return name;"
 W !,"  };"

 W !,"  function getKeyMap(val) {"
 W !,"    return typeof val == ""string"" ? keyMap[val] : val;"
 W !,"  }"

 W !,"  // FROMTEXTAREA"

 W !,"  CodeMirror.fromTextArea = function(textarea, options) {"
 W !,"    options = options ? copyObj(options) : {};"
 W !,"    options.value = textarea.value;"
 W !,"    if (!options.tabindex && textarea.tabIndex)"
 W !,"      options.tabindex = textarea.tabIndex;"
 W !,"    if (!options.placeholder && textarea.placeholder)"
 W !,"      options.placeholder = textarea.placeholder;"
 W !,"    // Set autofocus to true if this textarea is focused, or if it has"
 W !,"    // autofocus and no other element is focused."
 W !,"    if (options.autofocus == null) {"
 W !,"      var hasFocus = activeElt();"
 W !,"      options.autofocus = hasFocus == textarea ||"
 W !,"        textarea.getAttribute(""autofocus"") != null && hasFocus == document.body;"
 W !,"    }"

 W !,"    function save() {textarea.value = cm.getValue();}"
 W !,"    if (textarea.form) {"
 W !,"      on(textarea.form, ""submit"", save);"
 W !,"      // Deplorable hack to make the submit method do the right thing."
 W !,"      if (!options.leaveSubmitMethodAlone) {"
 W !,"        var form = textarea.form, realSubmit = form.submit;"
 W !,"        try {"
 W !,"          var wrappedSubmit = form.submit = function() {"
 W !,"            save();"
 W !,"            form.submit = realSubmit;"
 W !,"            form.submit();"
 W !,"            form.submit = wrappedSubmit;"
 W !,"          };"
 W !,"        } catch(e) {}"
 W !,"      }"
 W !,"    }"

 W !,"    options.finishInit = function(cm) {"
 W !,"      cm.save = save;"
 W !,"      cm.getTextArea = function() { return textarea; };"
 W !,"      cm.toTextArea = function() {"
 W !,"        cm.toTextArea = isNaN; // Prevent this from being ran twice"
 W !,"        save();"
 W !,"        textarea.parentNode.removeChild(cm.getWrapperElement());"
 W !,"        textarea.style.display = """";"
 W !,"        if (textarea.form) {"
 W !,"          off(textarea.form, ""submit"", save);"
 W !,"          if (typeof textarea.form.submit == ""function"")"
 W !,"            textarea.form.submit = realSubmit;"
 W !,"        }"
 W !,"      };"
 W !,"    };"

 W !,"    textarea.style.display = ""none"";"
 W !,"    var cm = CodeMirror(function(node) {"
 W !,"      textarea.parentNode.insertBefore(node, textarea.nextSibling);"
 W !,"    }, options);"
 W !,"    return cm;"
 W !,"  };"
}

ClassMethod ScriptLibCodemirror10()
{
 W !,"  // STRING STREAM"

 W !,"  // Fed to the mode parsers, provides helper functions to make"
 W !,"  // parsers more succinct."

 W !,"  var StringStream = CodeMirror.StringStream = function(string, tabSize) {"
 W !,"    this.pos = this.start = 0;"
 W !,"    this.string = string;"
 W !,"    this.tabSize = tabSize || 8;"
 W !,"    this.lastColumnPos = this.lastColumnValue = 0;"
 W !,"    this.lineStart = 0;"
 W !,"  };"

 W !,"  StringStream.prototype = {"
 W !,"    eol: function() {return this.pos >= this.string.length;},"
 W !,"    sol: function() {return this.pos == this.lineStart;},"
 W !,"    peek: function() {return this.string.charAt(this.pos) || undefined;},"
 W !,"    next: function() {"
 W !,"      if (this.pos < this.string.length)"
 W !,"        return this.string.charAt(this.pos++);"
 W !,"    },"
 W !,"    eat: function(match) {"
 W !,"      var ch = this.string.charAt(this.pos);"
 W !,"      if (typeof match == ""string"") var ok = ch == match;"
 W !,"      else var ok = ch && (match.test ? match.test(ch) : match(ch));"
 W !,"      if (ok) {++this.pos; return ch;}"
 W !,"    },"
 W !,"    eatWhile: function(match) {"
 W !,"      var start = this.pos;"
 W !,"      while (this.eat(match)){}"
 W !,"      return this.pos > start;"
 W !,"    },"
 W !,"    eatSpace: function() {"
 W !,"      var start = this.pos;"
 W !,"      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;"
 W !,"      return this.pos > start;"
 W !,"    },"
 W !,"    skipToEnd: function() {this.pos = this.string.length;},"
 W !,"    skipTo: function(ch) {"
 W !,"      var found = this.string.indexOf(ch, this.pos);"
 W !,"      if (found > -1) {this.pos = found; return true;}"
 W !,"    },"
 W !,"    backUp: function(n) {this.pos -= n;},"
 W !,"    column: function() {"
 W !,"      if (this.lastColumnPos < this.start) {"
 W !,"        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);"
 W !,"        this.lastColumnPos = this.start;"
 W !,"      }"
 W !,"      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);"
 W !,"    },"
 W !,"    indentation: function() {"
 W !,"      return countColumn(this.string, null, this.tabSize) -"
 W !,"        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);"
 W !,"    },"
 W !,"    match: function(pattern, consume, caseInsensitive) {"
 W !,"      if (typeof pattern == ""string"") {"
 W !,"        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};"
 W !,"        var substr = this.string.substr(this.pos, pattern.length);"
 W !,"        if (cased(substr) == cased(pattern)) {"
 W !,"          if (consume !== false) this.pos += pattern.length;"
 W !,"          return true;"
 W !,"        }"
 W !,"      } else {"
 W !,"        var match = this.string.slice(this.pos).match(pattern);"
 W !,"        if (match && match.index > 0) return null;"
 W !,"        if (match && consume !== false) this.pos += match[0].length;"
 W !,"        return match;"
 W !,"      }"
 W !,"    },"
 W !,"    current: function(){return this.string.slice(this.start, this.pos);},"
 W !,"    hideFirstChars: function(n, inner) {"
 W !,"      this.lineStart += n;"
 W !,"      try { return inner(); }"
 W !,"      finally { this.lineStart -= n; }"
 W !,"    }"
 W !,"  };"

 W !,"  // TEXTMARKERS"

 W !,"  // Created with markText and setBookmark methods. A TextMarker is a"
 W !,"  // handle that can be used to clear or find a marked position in the"
 W !,"  // document. Line objects hold arrays (markedSpans) containing"
 W !,"  // {from, to, marker} object pointing to such marker objects, and"
 W !,"  // indicating that such a marker is present on that line. Multiple"
 W !,"  // lines may point to the same marker when it spans across lines."
 W !,"  // The spans will have null for their from/to properties when the"
 W !,"  // marker continues beyond the start/end of the line. Markers have"
 W !,"  // links back to the lines they currently touch."

 W !,"  var nextMarkerId = 0;"

 W !,"  var TextMarker = CodeMirror.TextMarker = function(doc, type) {"
 W !,"    this.lines = [];"
 W !,"    this.type = type;"
 W !,"    this.doc = doc;"
 W !,"    this.id = ++nextMarkerId;"
 W !,"  };"
 W !,"  eventMixin(TextMarker);"

 W !,"  // Clear the marker."
 W !,"  TextMarker.prototype.clear = function() {"
 W !,"    if (this.explicitlyCleared) return;"
 W !,"    var cm = this.doc.cm, withOp = cm && !cm.curOp;"
 W !,"    if (withOp) startOperation(cm);"
 W !,"    if (hasHandler(this, ""clear"")) {"
 W !,"      var found = this.find();"
 W !,"      if (found) signalLater(this, ""clear"", found.from, found.to);"
 W !,"    }"
 W !,"    var min = null, max = null;"
 W !,"    for (var i = 0; i < this.lines.length; ++i) {"
 W !,"      var line = this.lines[i];"
 W !,"      var span = getMarkedSpanFor(line.markedSpans, this);"
 W !,"      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), ""text"");"
 W !,"      else if (cm) {"
 W !,"        if (span.to != null) max = lineNo(line);"
 W !,"        if (span.from != null) min = lineNo(line);"
 W !,"      }"
 W !,"      line.markedSpans = removeMarkedSpan(line.markedSpans, span);"
 W !,"      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)"
 W !,"        updateLineHeight(line, textHeight(cm.display));"
 W !,"    }"
 W !,"    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {"
 W !,"      var visual = visualLine(this.lines[i]), len = lineLength(visual);"
 W !,"      if (len > cm.display.maxLineLength) {"
 W !,"        cm.display.maxLine = visual;"
 W !,"        cm.display.maxLineLength = len;"
 W !,"        cm.display.maxLineChanged = true;"
 W !,"      }"
 W !,"    }"

 W !,"    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);"
 W !,"    this.lines.length = 0;"
 W !,"    this.explicitlyCleared = true;"
 W !,"    if (this.atomic && this.doc.cantEdit) {"
 W !,"      this.doc.cantEdit = false;"
 W !,"      if (cm) reCheckSelection(cm.doc);"
 W !,"    }"
 W !,"    if (cm) signalLater(cm, ""markerCleared"", cm, this);"
 W !,"    if (withOp) endOperation(cm);"
 W !,"    if (this.parent) this.parent.clear();"
 W !,"  };"

 W !,"  // Find the position of the marker in the document. Returns a {from,"
 W !,"  // to} object by default. Side can be passed to get a specific side"
 W !,"  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the"
 W !,"  // Pos objects returned contain a line object, rather than a line"
 W !,"  // number (used to prevent looking up the same line twice)."
 W !,"  TextMarker.prototype.find = function(side, lineObj) {"
 W !,"    if (side == null && this.type == ""bookmark"") side = 1;"
 W !,"    var from, to;"
 W !,"    for (var i = 0; i < this.lines.length; ++i) {"
 W !,"      var line = this.lines[i];"
 W !,"      var span = getMarkedSpanFor(line.markedSpans, this);"
 W !,"      if (span.from != null) {"
 W !,"        from = Pos(lineObj ? line : lineNo(line), span.from);"
 W !,"        if (side == -1) return from;"
 W !,"      }"
 W !,"      if (span.to != null) {"
 W !,"        to = Pos(lineObj ? line : lineNo(line), span.to);"
 W !,"        if (side == 1) return to;"
 W !,"      }"
 W !,"    }"
 W !,"    return from && {from: from, to: to};"
 W !,"  };"

 W !,"  // Signals that the marker's widget changed, and surrounding layout"
 W !,"  // should be recomputed."
 W !,"  TextMarker.prototype.changed = function() {"
 W !,"    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;"
 W !,"    if (!pos || !cm) return;"
 W !,"    runInOp(cm, function() {"
 W !,"      var line = pos.line, lineN = lineNo(pos.line);"
 W !,"      var view = findViewForLine(cm, lineN);"
 W !,"      if (view) {"
 W !,"        clearLineMeasurementCacheFor(view);"
 W !,"        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;"
 W !,"      }"
 W !,"      cm.curOp.updateMaxLine = true;"
 W !,"      if (!lineIsHidden(widget.doc, line) && widget.height != null) {"
 W !,"        var oldHeight = widget.height;"
 W !,"        widget.height = null;"
 W !,"        var dHeight = widgetHeight(widget) - oldHeight;"
 W !,"        if (dHeight)"
 W !,"          updateLineHeight(line, line.height + dHeight);"
 W !,"      }"
 W !,"    });"
 W !,"  };"

 W !,"  TextMarker.prototype.attachLine = function(line) {"
 W !,"    if (!this.lines.length && this.doc.cm) {"
 W !,"      var op = this.doc.cm.curOp;"
 W !,"      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)"
 W !,"        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);"
 W !,"    }"
 W !,"    this.lines.push(line);"
 W !,"  };"
 W !,"  TextMarker.prototype.detachLine = function(line) {"
 W !,"    this.lines.splice(indexOf(this.lines, line), 1);"
 W !,"    if (!this.lines.length && this.doc.cm) {"
 W !,"      var op = this.doc.cm.curOp;"
 W !,"      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);"
 W !,"    }"
 W !,"  };"

 W !,"  // Collapsed markers have unique ids, in order to be able to order"
 W !,"  // them, which is needed for uniquely determining an outer marker"
 W !,"  // when they overlap (they may nest, but not partially overlap)."
 W !,"  var nextMarkerId = 0;"

 W !,"  // Create a marker, wire it up to the right lines, and"
 W !,"  function markText(doc, from, to, options, type) {"
 W !,"    // Shared markers (across linked documents) are handled separately"
 W !,"    // (markTextShared will call out to this again, once per"
 W !,"    // document)."
 W !,"    if (options && options.shared) return markTextShared(doc, from, to, options, type);"
 W !,"    // Ensure we are in an operation."
 W !,"    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);"

 W !,"    var marker = new TextMarker(doc, type), diff = cmp(from, to);"
 W !,"    if (options) copyObj(options, marker, false);"
 W !,"    // Don't connect empty markers unless clearWhenEmpty is false"
 W !,"    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)"
 W !,"      return marker;"
 W !,"    if (marker.replacedWith) {"
 W !,"      // Showing up as a widget implies collapsed (widget replaces text)"
 W !,"      marker.collapsed = true;"
 W !,"      marker.widgetNode = elt(""span"", [marker.replacedWith], ""CodeMirror-widget"");"
 W !,"      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(""cm-ignore-events"", ""true"");"
 W !,"      if (options.insertLeft) marker.widgetNode.insertLeft = true;"
 W !,"    }"
 W !,"    if (marker.collapsed) {"
 W !,"      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||"
 W !,"          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))"
 W !,"        throw new Error(""Inserting collapsed marker partially overlapping an existing one"");"
 W !,"      sawCollapsedSpans = true;"
 W !,"    }"

 W !,"    if (marker.addToHistory)"
 W !,"      addChangeToHistory(doc, {from: from, to: to, origin: ""markText""}, doc.sel, NaN);"

 W !,"    var curLine = from.line, cm = doc.cm, updateMaxLine;"
 W !,"    doc.iter(curLine, to.line + 1, function(line) {"
 W !,"      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)"
 W !,"        updateMaxLine = true;"
 W !,"      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);"
 W !,"      addMarkedSpan(line, new MarkedSpan(marker,"
 W !,"                                         curLine == from.line ? from.ch : null,"
 W !,"                                         curLine == to.line ? to.ch : null));"
 W !,"      ++curLine;"
 W !,"    });"
 W !,"    // lineIsHidden depends on the presence of the spans, so needs a second pass"
 W !,"    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {"
 W !,"      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);"
 W !,"    });"

 W !,"    if (marker.clearOnEnter) on(marker, ""beforeCursorEnter"", function() { marker.clear(); });"

 W !,"    if (marker.readOnly) {"
 W !,"      sawReadOnlySpans = true;"
 W !,"      if (doc.history.done.length || doc.history.undone.length)"
 W !,"        doc.clearHistory();"
 W !,"    }"
 W !,"    if (marker.collapsed) {"
 W !,"      marker.id = ++nextMarkerId;"
 W !,"      marker.atomic = true;"
 W !,"    }"
 W !,"    if (cm) {"
 W !,"      // Sync editor state"
 W !,"      if (updateMaxLine) cm.curOp.updateMaxLine = true;"
 W !,"      if (marker.collapsed)"
 W !,"        regChange(cm, from.line, to.line + 1);"
 W !,"      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)"
 W !,"        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, ""text"");"
 W !,"      if (marker.atomic) reCheckSelection(cm.doc);"
 W !,"      signalLater(cm, ""markerAdded"", cm, marker);"
 W !,"    }"
 W !,"    return marker;"
 W !,"  }"

 W !,"  // SHARED TEXTMARKERS"

 W !,"  // A shared marker spans multiple linked documents. It is"
 W !,"  // implemented as a meta-marker-object controlling multiple normal"
 W !,"  // markers."
 W !,"  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {"
 W !,"    this.markers = markers;"
 W !,"    this.primary = primary;"
 W !,"    for (var i = 0; i < markers.length; ++i)"
 W !,"      markers[i].parent = this;"
 W !,"  };"
 W !,"  eventMixin(SharedTextMarker);"

 W !,"  SharedTextMarker.prototype.clear = function() {"
 W !,"    if (this.explicitlyCleared) return;"
 W !,"    this.explicitlyCleared = true;"
 W !,"    for (var i = 0; i < this.markers.length; ++i)"
 W !,"      this.markers[i].clear();"
 W !,"    signalLater(this, ""clear"");"
 W !,"  };"
 W !,"  SharedTextMarker.prototype.find = function(side, lineObj) {"
 W !,"    return this.primary.find(side, lineObj);"
 W !,"  };"

 W !,"  function markTextShared(doc, from, to, options, type) {"
 W !,"    options = copyObj(options);"
 W !,"    options.shared = false;"
 W !,"    var markers = [markText(doc, from, to, options, type)], primary = markers[0];"
 W !,"    var widget = options.widgetNode;"
 W !,"    linkedDocs(doc, function(doc) {"
 W !,"      if (widget) options.widgetNode = widget.cloneNode(true);"
 W !,"      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));"
 W !,"      for (var i = 0; i < doc.linked.length; ++i)"
 W !,"        if (doc.linked[i].isParent) return;"
 W !,"      primary = lst(markers);"
 W !,"    });"
 W !,"    return new SharedTextMarker(markers, primary);"
 W !,"  }"

 W !,"  function findSharedMarkers(doc) {"
 W !,"    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),"
 W !,"                         function(m) { return m.parent; });"
 W !,"  }"

 W !,"  function copySharedMarkers(doc, markers) {"
 W !,"    for (var i = 0; i < markers.length; i++) {"
 W !,"      var marker = markers[i], pos = marker.find();"
 W !,"      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);"
 W !,"      if (cmp(mFrom, mTo)) {"
 W !,"        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);"
 W !,"        marker.markers.push(subMark);"
 W !,"        subMark.parent = marker;"
 W !,"      }"
 W !,"    }"
 W !,"  }"

 W !,"  function detachSharedMarkers(markers) {"
 W !,"    for (var i = 0; i < markers.length; i++) {"
 W !,"      var marker = markers[i], linked = [marker.primary.doc];;"
 W !,"      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });"
 W !,"      for (var j = 0; j < marker.markers.length; j++) {"
 W !,"        var subMarker = marker.markers[j];"
 W !,"        if (indexOf(linked, subMarker.doc) == -1) {"
 W !,"          subMarker.parent = null;"
 W !,"          marker.markers.splice(j--, 1);"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"  }"

 W !,"  // TEXTMARKER SPANS"

 W !,"  function MarkedSpan(marker, from, to) {"
 W !,"    this.marker = marker;"
 W !,"    this.from = from; this.to = to;"
 W !,"  }"

 W !,"  // Search an array of spans for a span matching the given marker."
 W !,"  function getMarkedSpanFor(spans, marker) {"
 W !,"    if (spans) for (var i = 0; i < spans.length; ++i) {"
 W !,"      var span = spans[i];"
 W !,"      if (span.marker == marker) return span;"
 W !,"    }"
 W !,"  }"
 W !,"  // Remove a span from an array, returning undefined if no spans are"
 W !,"  // left (we don't store arrays for lines without spans)."
 W !,"  function removeMarkedSpan(spans, span) {"
 W !,"    for (var r, i = 0; i < spans.length; ++i)"
 W !,"      if (spans[i] != span) (r || (r = [])).push(spans[i]);"
 W !,"    return r;"
 W !,"  }"
 W !,"  // Add a span to a line."
 W !,"  function addMarkedSpan(line, span) {"
 W !,"    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];"
 W !,"    span.marker.attachLine(line);"
 W !,"  }"

 W !,"  // Used for the algorithm that adjusts markers for a change in the"
 W !,"  // document. These functions cut an array of spans at a given"
 W !,"  // character position, returning an array of remaining chunks (or"
 W !,"  // undefined if nothing remains)."
 W !,"  function markedSpansBefore(old, startCh, isInsert) {"
 W !,"    if (old) for (var i = 0, nw; i < old.length; ++i) {"
 W !,"      var span = old[i], marker = span.marker;"
 W !,"      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);"
 W !,"      if (startsBefore || span.from == startCh && marker.type == ""bookmark"" && (!isInsert || !span.marker.insertLeft)) {"
 W !,"        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);"
 W !,"        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));"
 W !,"      }"
 W !,"    }"
 W !,"    return nw;"
 W !,"  }"
 W !,"  function markedSpansAfter(old, endCh, isInsert) {"
 W !,"    if (old) for (var i = 0, nw; i < old.length; ++i) {"
 W !,"      var span = old[i], marker = span.marker;"
 W !,"      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);"
 W !,"      if (endsAfter || span.from == endCh && marker.type == ""bookmark"" && (!isInsert || span.marker.insertLeft)) {"
 W !,"        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);"
 W !,"        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,"
 W !,"                                              span.to == null ? null : span.to - endCh));"
 W !,"      }"
 W !,"    }"
 W !,"    return nw;"
 W !,"  }"

 W !,"  // Given a change object, compute the new set of marker spans that"
 W !,"  // cover the line in which the change took place. Removes spans"
 W !,"  // entirely within the change, reconnects spans belonging to the"
 W !,"  // same marker that appear on both sides of the change, and cuts off"
 W !,"  // spans partially within the change. Returns an array of span"
 W !,"  // arrays with one element for each line in (after) the change."
 W !,"  function stretchSpansOverChange(doc, change) {"
 W !,"    if (change.full) return null;"
 W !,"    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;"
 W !,"    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;"
 W !,"    if (!oldFirst && !oldLast) return null;"

 W !,"    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;"
 W !,"    // Get the spans that 'stick out' on both sides"
 W !,"    var first = markedSpansBefore(oldFirst, startCh, isInsert);"
 W !,"    var last = markedSpansAfter(oldLast, endCh, isInsert);"

 W !,"    // Next, merge those two ends"
 W !,"    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);"
 W !,"    if (first) {"
 W !,"      // Fix up .to properties of first"
 W !,"      for (var i = 0; i < first.length; ++i) {"
 W !,"        var span = first[i];"
 W !,"        if (span.to == null) {"
 W !,"          var found = getMarkedSpanFor(last, span.marker);"
 W !,"          if (!found) span.to = startCh;"
 W !,"          else if (sameLine) span.to = found.to == null ? null : found.to + offset;"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"    if (last) {"
 W !,"      // Fix up .from in last (or move them into first in case of sameLine)"
 W !,"      for (var i = 0; i < last.length; ++i) {"
 W !,"        var span = last[i];"
 W !,"        if (span.to != null) span.to += offset;"
 W !,"        if (span.from == null) {"
 W !,"          var found = getMarkedSpanFor(first, span.marker);"
 W !,"          if (!found) {"
 W !,"            span.from = offset;"
 W !,"            if (sameLine) (first || (first = [])).push(span);"
 W !,"          }"
 W !,"        } else {"
 W !,"          span.from += offset;"
 W !,"          if (sameLine) (first || (first = [])).push(span);"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"    // Make sure we didn't create any zero-length spans"
 W !,"    if (first) first = clearEmptySpans(first);"
 W !,"    if (last && last != first) last = clearEmptySpans(last);"

 W !,"    var newMarkers = [first];"
 W !,"    if (!sameLine) {"
 W !,"      // Fill gap with whole-line-spans"
 W !,"      var gap = change.text.length - 2, gapMarkers;"
 W !,"      if (gap > 0 && first)"
 W !,"        for (var i = 0; i < first.length; ++i)"
 W !,"          if (first[i].to == null)"
 W !,"            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));"
 W !,"      for (var i = 0; i < gap; ++i)"
 W !,"        newMarkers.push(gapMarkers);"
 W !,"      newMarkers.push(last);"
 W !,"    }"
 W !,"    return newMarkers;"
 W !,"  }"

 W !,"  // Remove spans that are empty and don't have a clearWhenEmpty"
 W !,"  // option of false."
 W !,"  function clearEmptySpans(spans) {"
 W !,"    for (var i = 0; i < spans.length; ++i) {"
 W !,"      var span = spans[i];"
 W !,"      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)"
 W !,"        spans.splice(i--, 1);"
 W !,"    }"
 W !,"    if (!spans.length) return null;"
 W !,"    return spans;"
 W !,"  }"

 W !,"  // Used for un/re-doing changes from the history. Combines the"
 W !,"  // result of computing the existing spans with the set of spans that"
 W !,"  // existed in the history (so that deleting around a span and then"
 W !,"  // undoing brings back the span)."
 W !,"  function mergeOldSpans(doc, change) {"
 W !,"    var old = getOldSpans(doc, change);"
 W !,"    var stretched = stretchSpansOverChange(doc, change);"
 W !,"    if (!old) return stretched;"
 W !,"    if (!stretched) return old;"

 W !,"    for (var i = 0; i < old.length; ++i) {"
 W !,"      var oldCur = old[i], stretchCur = stretched[i];"
 W !,"      if (oldCur && stretchCur) {"
 W !,"        spans: for (var j = 0; j < stretchCur.length; ++j) {"
 W !,"          var span = stretchCur[j];"
 W !,"          for (var k = 0; k < oldCur.length; ++k)"
 W !,"            if (oldCur[k].marker == span.marker) continue spans;"
 W !,"          oldCur.push(span);"
 W !,"        }"
 W !,"      } else if (stretchCur) {"
 W !,"        old[i] = stretchCur;"
 W !,"      }"
 W !,"    }"
 W !,"    return old;"
 W !,"  }"

 W !,"  // Used to 'clip' out readOnly ranges when making a change."
 W !,"  function removeReadOnlyRanges(doc, from, to) {"
 W !,"    var markers = null;"
 W !,"    doc.iter(from.line, to.line + 1, function(line) {"
 W !,"      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {"
 W !,"        var mark = line.markedSpans[i].marker;"
 W !,"        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))"
 W !,"          (markers || (markers = [])).push(mark);"
 W !,"      }"
 W !,"    });"
 W !,"    if (!markers) return null;"
 W !,"    var parts = [{from: from, to: to}];"
 W !,"    for (var i = 0; i < markers.length; ++i) {"
 W !,"      var mk = markers[i], m = mk.find(0);"
 W !,"      for (var j = 0; j < parts.length; ++j) {"
 W !,"        var p = parts[j];"
 W !,"        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;"
 W !,"        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);"
 W !,"        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)"
 W !,"          newParts.push({from: p.from, to: m.from});"
 W !,"        if (dto > 0 || !mk.inclusiveRight && !dto)"
 W !,"          newParts.push({from: m.to, to: p.to});"
 W !,"        parts.splice.apply(parts, newParts);"
 W !,"        j += newParts.length - 1;"
 W !,"      }"
 W !,"    }"
 W !,"    return parts;"
 W !,"  }"

 W !,"  // Connect or disconnect spans from a line."
 W !,"  function detachMarkedSpans(line) {"
 W !,"    var spans = line.markedSpans;"
 W !,"    if (!spans) return;"
 W !,"    for (var i = 0; i < spans.length; ++i)"
 W !,"      spans[i].marker.detachLine(line);"
 W !,"    line.markedSpans = null;"
 W !,"  }"
 W !,"  function attachMarkedSpans(line, spans) {"
 W !,"    if (!spans) return;"
 W !,"    for (var i = 0; i < spans.length; ++i)"
 W !,"      spans[i].marker.attachLine(line);"
 W !,"    line.markedSpans = spans;"
 W !,"  }"

 W !,"  // Helpers used when computing which overlapping collapsed span"
 W !,"  // counts as the larger one."
 W !,"  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }"
 W !,"  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }"

 W !,"  // Returns a number indicating which of two overlapping collapsed"
 W !,"  // spans is larger (and thus includes the other). Falls back to"
 W !,"  // comparing ids when the spans cover exactly the same range."
 W !,"  function compareCollapsedMarkers(a, b) {"
 W !,"    var lenDiff = a.lines.length - b.lines.length;"
 W !,"    if (lenDiff != 0) return lenDiff;"
 W !,"    var aPos = a.find(), bPos = b.find();"
 W !,"    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);"
 W !,"    if (fromCmp) return -fromCmp;"
 W !,"    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);"
 W !,"    if (toCmp) return toCmp;"
 W !,"    return b.id - a.id;"
 W !,"  }"

 W !,"  // Find out whether a line ends or starts in a collapsed span. If"
 W !,"  // so, return the marker for that span."
 W !,"  function collapsedSpanAtSide(line, start) {"
 W !,"    var sps = sawCollapsedSpans && line.markedSpans, found;"
 W !,"    if (sps) for (var sp, i = 0; i < sps.length; ++i) {"
 W !,"      sp = sps[i];"
 W !,"      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&"
 W !,"          (!found || compareCollapsedMarkers(found, sp.marker) < 0))"
 W !,"        found = sp.marker;"
 W !,"    }"
 W !,"    return found;"
 W !,"  }"
 W !,"  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }"
 W !,"  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }"

 W !,"  // Test whether there exists a collapsed span that partially"
 W !,"  // overlaps (covers the start or end, but not both) of a new span."
 W !,"  // Such overlap is not allowed."
 W !,"  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {"
 W !,"    var line = getLine(doc, lineNo);"
 W !,"    var sps = sawCollapsedSpans && line.markedSpans;"
 W !,"    if (sps) for (var i = 0; i < sps.length; ++i) {"
 W !,"      var sp = sps[i];"
 W !,"      if (!sp.marker.collapsed) continue;"
 W !,"      var found = sp.marker.find(0);"
 W !,"      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);"
 W !,"      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);"
 W !,"      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;"
 W !,"      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||"
 W !,"          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))"
 W !,"        return true;"
 W !,"    }"
 W !,"  }"

 W !,"  // A visual line is a line as drawn on the screen. Folding, for"
 W !,"  // example, can cause multiple logical lines to appear on the same"
 W !,"  // visual line. This finds the start of the visual line that the"
 W !,"  // given line is part of (usually that is the line itself)."
 W !,"  function visualLine(line) {"
 W !,"    var merged;"
 W !,"    while (merged = collapsedSpanAtStart(line))"
 W !,"      line = merged.find(-1, true).line;"
 W !,"    return line;"
 W !,"  }"

 W !,"  // Returns an array of logical lines that continue the visual line"
 W !,"  // started by the argument, or undefined if there are no such lines."
 W !,"  function visualLineContinued(line) {"
 W !,"    var merged, lines;"
 W !,"    while (merged = collapsedSpanAtEnd(line)) {"
 W !,"      line = merged.find(1, true).line;"
 W !,"      (lines || (lines = [])).push(line);"
 W !,"    }"
 W !,"    return lines;"
 W !,"  }"

 W !,"  // Get the line number of the start of the visual line that the"
 W !,"  // given line number is part of."
 W !,"  function visualLineNo(doc, lineN) {"
 W !,"    var line = getLine(doc, lineN), vis = visualLine(line);"
 W !,"    if (line == vis) return lineN;"
 W !,"    return lineNo(vis);"
 W !,"  }"
 W !,"  // Get the line number of the start of the next visual line after"
 W !,"  // the given line."
 W !,"  function visualLineEndNo(doc, lineN) {"
 W !,"    if (lineN > doc.lastLine()) return lineN;"
 W !,"    var line = getLine(doc, lineN), merged;"
 W !,"    if (!lineIsHidden(doc, line)) return lineN;"
 W !,"    while (merged = collapsedSpanAtEnd(line))"
 W !,"      line = merged.find(1, true).line;"
 W !,"    return lineNo(line) + 1;"
 W !,"  }"

 W !,"  // Compute whether a line is hidden. Lines count as hidden when they"
 W !,"  // are part of a visual line that starts with another line, or when"
 W !,"  // they are entirely covered by collapsed, non-widget span."
 W !,"  function lineIsHidden(doc, line) {"
 W !,"    var sps = sawCollapsedSpans && line.markedSpans;"
 W !,"    if (sps) for (var sp, i = 0; i < sps.length; ++i) {"
 W !,"      sp = sps[i];"
 W !,"      if (!sp.marker.collapsed) continue;"
 W !,"      if (sp.from == null) return true;"
 W !,"      if (sp.marker.widgetNode) continue;"
 W !,"      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))"
 W !,"        return true;"
 W !,"    }"
 W !,"  }"
 W !,"  function lineIsHiddenInner(doc, line, span) {"
 W !,"    if (span.to == null) {"
 W !,"      var end = span.marker.find(1, true);"
 W !,"      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));"
 W !,"    }"
 W !,"    if (span.marker.inclusiveRight && span.to == line.text.length)"
 W !,"      return true;"
 W !,"    for (var sp, i = 0; i < line.markedSpans.length; ++i) {"
 W !,"      sp = line.markedSpans[i];"
 W !,"      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&"
 W !,"          (sp.to == null || sp.to != span.from) &&"
 W !,"          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&"
 W !,"          lineIsHiddenInner(doc, line, sp)) return true;"
 W !,"    }"
 W !,"  }"

 W !,"  // LINE WIDGETS"

 W !,"  // Line widgets are block elements displayed above or below a line."

 W !,"  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {"
 W !,"    if (options) for (var opt in options) if (options.hasOwnProperty(opt))"
 W !,"      this[opt] = options[opt];"
 W !,"    this.doc = doc;"
 W !,"    this.node = node;"
 W !,"  };"
 W !,"  eventMixin(LineWidget);"
}

ClassMethod ScriptLibCodemirror11()
{
 W !,"  function adjustScrollWhenAboveVisible(cm, line, diff) {"
 W !,"    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))"
 W !,"      addToScrollPos(cm, null, diff);"
 W !,"  }"

 W !,"  LineWidget.prototype.clear = function() {"
 W !,"    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);"
 W !,"    if (no == null || !ws) return;"
 W !,"    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);"
 W !,"    if (!ws.length) line.widgets = null;"
 W !,"    var height = widgetHeight(this);"
 W !,"    updateLineHeight(line, Math.max(0, line.height - height));"
 W !,"    if (cm) runInOp(cm, function() {"
 W !,"      adjustScrollWhenAboveVisible(cm, line, -height);"
 W !,"      regLineChange(cm, no, ""widget"");"
 W !,"    });"
 W !,"  };"
 W !,"  LineWidget.prototype.changed = function() {"
 W !,"    var oldH = this.height, cm = this.doc.cm, line = this.line;"
 W !,"    this.height = null;"
 W !,"    var diff = widgetHeight(this) - oldH;"
 W !,"    if (!diff) return;"
 W !,"    updateLineHeight(line, line.height + diff);"
 W !,"    if (cm) runInOp(cm, function() {"
 W !,"      cm.curOp.forceUpdate = true;"
 W !,"      adjustScrollWhenAboveVisible(cm, line, diff);"
 W !,"    });"
 W !,"  };"

 W !,"  function widgetHeight(widget) {"
 W !,"    if (widget.height != null) return widget.height;"
 W !,"    var cm = widget.doc.cm;"
 W !,"    if (!cm) return 0;"
 W !,"    if (!contains(document.body, widget.node)) {"
 W !,"      var parentStyle = ""position: relative;"";"
 W !,"      if (widget.coverGutter)"
 W !,"        parentStyle += ""margin-left: -"" + cm.display.gutters.offsetWidth + ""px;"";"
 W !,"      if (widget.noHScroll)"
 W !,"        parentStyle += ""width: "" + cm.display.wrapper.clientWidth + ""px;"";"
 W !,"      removeChildrenAndAdd(cm.display.measure, elt(""div"", [widget.node], null, parentStyle));"
 W !,"    }"
 W !,"    return widget.height = widget.node.parentNode.offsetHeight;"
 W !,"  }"

 W !,"  function addLineWidget(doc, handle, node, options) {"
 W !,"    var widget = new LineWidget(doc, node, options);"
 W !,"    var cm = doc.cm;"
 W !,"    if (cm && widget.noHScroll) cm.display.alignWidgets = true;"
 W !,"    changeLine(doc, handle, ""widget"", function(line) {"
 W !,"      var widgets = line.widgets || (line.widgets = []);"
 W !,"      if (widget.insertAt == null) widgets.push(widget);"
 W !,"      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);"
 W !,"      widget.line = line;"
 W !,"      if (cm && !lineIsHidden(doc, line)) {"
 W !,"        var aboveVisible = heightAtLine(line) < doc.scrollTop;"
 W !,"        updateLineHeight(line, line.height + widgetHeight(widget));"
 W !,"        if (aboveVisible) addToScrollPos(cm, null, widget.height);"
 W !,"        cm.curOp.forceUpdate = true;"
 W !,"      }"
 W !,"      return true;"
 W !,"    });"
 W !,"    return widget;"
 W !,"  }"

 W !,"  // LINE DATA STRUCTURE"

 W !,"  // Line objects. These hold state related to a line, including"
 W !,"  // highlighting info (the styles array)."
 W !,"  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {"
 W !,"    this.text = text;"
 W !,"    attachMarkedSpans(this, markedSpans);"
 W !,"    this.height = estimateHeight ? estimateHeight(this) : 1;"
 W !,"  };"
 W !,"  eventMixin(Line);"
 W !,"  Line.prototype.lineNo = function() { return lineNo(this); };"

 W !,"  // Change the content (text, markers) of a line. Automatically"
 W !,"  // invalidates cached information and tries to re-estimate the"
 W !,"  // line's height."
 W !,"  function updateLine(line, text, markedSpans, estimateHeight) {"
 W !,"    line.text = text;"
 W !,"    if (line.stateAfter) line.stateAfter = null;"
 W !,"    if (line.styles) line.styles = null;"
 W !,"    if (line.order != null) line.order = null;"
 W !,"    detachMarkedSpans(line);"
 W !,"    attachMarkedSpans(line, markedSpans);"
 W !,"    var estHeight = estimateHeight ? estimateHeight(line) : 1;"
 W !,"    if (estHeight != line.height) updateLineHeight(line, estHeight);"
 W !,"  }"

 W !,"  // Detach a line from the document tree and its markers."
 W !,"  function cleanUpLine(line) {"
 W !,"    line.parent = null;"
 W !,"    detachMarkedSpans(line);"
 W !,"  }"

 W !,"  function extractLineClasses(type, output) {"
 W !,"    if (type) for (;;) {"
 W !,"      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);"
 W !,"      if (!lineClass) break;"
 W !,"      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);"
 W !,"      var prop = lineClass[1] ? ""bgClass"" : ""textClass"";"
 W !,"      if (output[prop] == null)"
 W !,"        output[prop] = lineClass[2];"
 W !,"      else if (!(new RegExp(""(?:^|\s)"" + lineClass[2] + ""(?:$|\s)"")).test(output[prop]))"
 W !,"        output[prop] += "" "" + lineClass[2];"
 W !,"    }"
 W !,"    return type;"
 W !,"  }"

 W !,"  function callBlankLine(mode, state) {"
 W !,"    if (mode.blankLine) return mode.blankLine(state);"
 W !,"    if (!mode.innerMode) return;"
 W !,"    var inner = CodeMirror.innerMode(mode, state);"
 W !,"    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);"
 W !,"  }"

 W !,"  function readToken(mode, stream, state, inner) {"
 W !,"    for (var i = 0; i < 10; i++) {"
 W !,"      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;"
 W !,"      var style = mode.token(stream, state);"
 W !,"      if (stream.pos > stream.start) return style;"
 W !,"    }"
 W !,"    throw new Error(""Mode "" + mode.name + "" failed to advance stream."");"
 W !,"  }"

 W !,"  // Utility for getTokenAt and getLineTokens"
 W !,"  function takeToken(cm, pos, precise, asArray) {"
 W !,"    function getObj(copy) {"
 W !,"      return {start: stream.start, end: stream.pos,"
 W !,"              string: stream.current(),"
 W !,"              type: style || null,"
 W !,"              state: copy ? copyState(doc.mode, state) : state};"
 W !,"    }"

 W !,"    var doc = cm.doc, mode = doc.mode, style;"
 W !,"    pos = clipPos(doc, pos);"
 W !,"    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);"
 W !,"    var stream = new StringStream(line.text, cm.options.tabSize), tokens;"
 W !,"    if (asArray) tokens = [];"
 W !,"    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {"
 W !,"      stream.start = stream.pos;"
 W !,"      style = readToken(mode, stream, state);"
 W !,"      if (asArray) tokens.push(getObj(true));"
 W !,"    }"
 W !,"    return asArray ? tokens : getObj();"
 W !,"  }"

 W !,"  // Run the given mode's parser over a line, calling f for each token."
 W !,"  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {"
 W !,"    var flattenSpans = mode.flattenSpans;"
 W !,"    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;"
 W !,"    var curStart = 0, curStyle = null;"
 W !,"    var stream = new StringStream(text, cm.options.tabSize), style;"
 W !,"    var inner = cm.options.addModeClass && [null];"
 W !,"    if (text == """") extractLineClasses(callBlankLine(mode, state), lineClasses);"
 W !,"    while (!stream.eol()) {"
 W !,"      if (stream.pos > cm.options.maxHighlightLength) {"
 W !,"        flattenSpans = false;"
 W !,"        if (forceToEnd) processLine(cm, text, state, stream.pos);"
 W !,"        stream.pos = text.length;"
 W !,"        style = null;"
 W !,"      } else {"
 W !,"        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);"
 W !,"      }"
 W !,"      if (inner) {"
 W !,"        var mName = inner[0].name;"
 W !,"        if (mName) style = ""m-"" + (style ? mName + "" "" + style : mName);"
 W !,"      }"
 W !,"      if (!flattenSpans || curStyle != style) {"
 W !,"        while (curStart < stream.start) {"
 W !,"          curStart = Math.min(stream.start, curStart + 50000);"
 W !,"          f(curStart, curStyle);"
 W !,"        }"
 W !,"        curStyle = style;"
 W !,"      }"
 W !,"      stream.start = stream.pos;"
 W !,"    }"
 W !,"    while (curStart < stream.pos) {"
 W !,"      // Webkit seems to refuse to render text nodes longer than 57444 characters"
 W !,"      var pos = Math.min(stream.pos, curStart + 50000);"
 W !,"      f(pos, curStyle);"
 W !,"      curStart = pos;"
 W !,"    }"
 W !,"  }"

 W !,"  // Compute a style array (an array starting with a mode generation"
 W !,"  // -- for invalidation -- followed by pairs of end positions and"
 W !,"  // style strings), which is used to highlight the tokens on the"
 W !,"  // line."
 W !,"  function highlightLine(cm, line, state, forceToEnd) {"
 W !,"    // A styles array always starts with a number identifying the"
 W !,"    // mode/overlays that it is based on (for easy invalidation)."
 W !,"    var st = [cm.state.modeGen], lineClasses = {};"
 W !,"    // Compute the base array of styles"
 W !,"    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {"
 W !,"      st.push(end, style);"
 W !,"    }, lineClasses, forceToEnd);"

 W !,"    // Run overlays, adjust style array."
 W !,"    for (var o = 0; o < cm.state.overlays.length; ++o) {"
 W !,"      var overlay = cm.state.overlays[o], i = 1, at = 0;"
 W !,"      runMode(cm, line.text, overlay.mode, true, function(end, style) {"
 W !,"        var start = i;"
 W !,"        // Ensure there's a token end at the current position, and that i points at it"
 W !,"        while (at < end) {"
 W !,"          var i_end = st[i];"
 W !,"          if (i_end > end)"
 W !,"            st.splice(i, 1, end, st[i+1], i_end);"
 W !,"          i += 2;"
 W !,"          at = Math.min(end, i_end);"
 W !,"        }"
 W !,"        if (!style) return;"
 W !,"        if (overlay.opaque) {"
 W !,"          st.splice(start, i - start, end, ""cm-overlay "" + style);"
 W !,"          i = start + 2;"
 W !,"        } else {"
 W !,"          for (; start < i; start += 2) {"
 W !,"            var cur = st[start+1];"
 W !,"            st[start+1] = (cur ? cur + "" "" : """") + ""cm-overlay "" + style;"
 W !,"          }"
 W !,"        }"
 W !,"      }, lineClasses);"
 W !,"    }"

 W !,"    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};"
 W !,"  }"

 W !,"  function getLineStyles(cm, line, updateFrontier) {"
 W !,"    if (!line.styles || line.styles[0] != cm.state.modeGen) {"
 W !,"      var state = getStateBefore(cm, lineNo(line));"
 W !,"      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);"
 W !,"      line.stateAfter = state;"
 W !,"      line.styles = result.styles;"
 W !,"      if (result.classes) line.styleClasses = result.classes;"
 W !,"      else if (line.styleClasses) line.styleClasses = null;"
 W !,"      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;"
 W !,"    }"
 W !,"    return line.styles;"
 W !,"  }"

 W !,"  // Lightweight form of highlight -- proceed over this line and"
 W !,"  // update state, but don't save a style array. Used for lines that"
 W !,"  // aren't currently visible."
 W !,"  function processLine(cm, text, state, startAt) {"
 W !,"    var mode = cm.doc.mode;"
 W !,"    var stream = new StringStream(text, cm.options.tabSize);"
 W !,"    stream.start = stream.pos = startAt || 0;"
 W !,"    if (text == """") callBlankLine(mode, state);"
 W !,"    while (!stream.eol()) {"
 W !,"      readToken(mode, stream, state);"
 W !,"      stream.start = stream.pos;"
 W !,"    }"
 W !,"  }"

 W !,"  // Convert a style as returned by a mode (either null, or a string"
 W !,"  // containing one or more styles) to a CSS style. This is cached,"
 W !,"  // and also looks for line-wide styles."
 W !,"  var styleToClassCache = {}, styleToClassCacheWithMode = {};"
 W !,"  function interpretTokenStyle(style, options) {"
 W !,"    if (!style || /^\s*$/.test(style)) return null;"
 W !,"    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;"
 W !,"    return cache[style] ||"
 W !,"      (cache[style] = style.replace(/\S+/g, ""cm-$&""));"
 W !,"  }"

 W !,"  // Render the DOM representation of the text of a line. Also builds"
 W !,"  // up a 'line map', which points at the DOM nodes that represent"
 W !,"  // specific stretches of text, and is used by the measuring code."
 W !,"  // The returned object contains the DOM node, this map, and"
 W !,"  // information about line-wide styles that were set by the mode."
 W !,"  function buildLineContent(cm, lineView) {"
 W !,"    // The padding-right forces the element to have a 'border', which"
 W !,"    // is needed on Webkit to be able to get line-level bounding"
 W !,"    // rectangles for it (in measureChar)."
 W !,"    var content = elt(""span"", null, null, webkit ? ""padding-right: .1px"" : null);"
 W !,"    var builder = {pre: elt(""pre"", [content], ""CodeMirror-line""), content: content,"
 W !,"                   col: 0, pos: 0, cm: cm,"
 W !,"                   splitSpaces: (ie || webkit) && cm.getOption(""lineWrapping"")};"
 W !,"    lineView.measure = {};"

 W !,"    // Iterate over the logical lines that make up this visual line."
 W !,"    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {"
 W !,"      var line = i ? lineView.rest[i - 1] : lineView.line, order;"
 W !,"      builder.pos = 0;"
 W !,"      builder.addToken = buildToken;"
 W !,"      // Optionally wire in some hacks into the token-rendering"
 W !,"      // algorithm, to deal with browser quirks."
 W !,"      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))"
 W !,"        builder.addToken = buildTokenBadBidi(builder.addToken, order);"
 W !,"      builder.map = [];"
 W !,"      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);"
 W !,"      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));"
 W !,"      if (line.styleClasses) {"
 W !,"        if (line.styleClasses.bgClass)"
 W !,"          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || """");"
 W !,"        if (line.styleClasses.textClass)"
 W !,"          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || """");"
 W !,"      }"

 W !,"      // Ensure at least a single node is present, for measuring."
 W !,"      if (builder.map.length == 0)"
 W !,"        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));"

 W !,"      // Store the map and a cache object for the current logical line"
 W !,"      if (i == 0) {"
 W !,"        lineView.measure.map = builder.map;"
 W !,"        lineView.measure.cache = {};"
 W !,"      } else {"
 W !,"        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);"
 W !,"        (lineView.measure.caches || (lineView.measure.caches = [])).push({});"
 W !,"      }"
 W !,"    }"

 W !,"    // See issue #2901"
 W !,"    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))"
 W !,"      builder.content.className = ""cm-tab-wrap-hack"";"

 W !,"    signal(cm, ""renderLine"", cm, lineView.line, builder.pre);"
 W !,"    if (builder.pre.className)"
 W !,"      builder.textClass = joinClasses(builder.pre.className, builder.textClass || """");"

 W !,"    return builder;"
 W !,"  }"

 W !,"  function defaultSpecialCharPlaceholder(ch) {"
 W !,"    var token = elt(""span"", ""\u2022"", ""cm-invalidchar"");"
 W !,"    token.title = ""\\u"" + ch.charCodeAt(0).toString(16);"
 W !,"    token.setAttribute(""aria-label"", token.title);"
 W !,"    return token;"
 W !,"  }"

 W !,"  // Build up the DOM representation for a single token, and add it to"
 W !,"  // the line map. Takes care to render special characters separately."
 W !,"  function buildToken(builder, text, style, startStyle, endStyle, title, css) {"
 W !,"    if (!text) return;"
 W !,"    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;"
 W !,"    var special = builder.cm.state.specialChars, mustWrap = false;"
 W !,"    if (!special.test(text)) {"
 W !,"      builder.col += text.length;"
 W !,"      var content = document.createTextNode(displayText);"
 W !,"      builder.map.push(builder.pos, builder.pos + text.length, content);"
 W !,"      if (ie && ie_version < 9) mustWrap = true;"
 W !,"      builder.pos += text.length;"
 W !,"    } else {"
 W !,"      var content = document.createDocumentFragment(), pos = 0;"
 W !,"      while (true) {"
 W !,"        special.lastIndex = pos;"
 W !,"        var m = special.exec(text);"
 W !,"        var skipped = m ? m.index - pos : text.length - pos;"
 W !,"        if (skipped) {"
 W !,"          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));"
 W !,"          if (ie && ie_version < 9) content.appendChild(elt(""span"", [txt]));"
 W !,"          else content.appendChild(txt);"
 W !,"          builder.map.push(builder.pos, builder.pos + skipped, txt);"
 W !,"          builder.col += skipped;"
 W !,"          builder.pos += skipped;"
 W !,"        }"
 W !,"        if (!m) break;"
 W !,"        pos += skipped + 1;"
 W !,"        if (m[0] == ""\t"") {"
 W !,"          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;"
 W !,"          var txt = content.appendChild(elt(""span"", spaceStr(tabWidth), ""cm-tab""));"
 W !,"          txt.setAttribute(""role"", ""presentation"");"
 W !,"          txt.setAttribute(""cm-text"", ""\t"");"
 W !,"          builder.col += tabWidth;"
 W !,"        } else if (m[0] == ""\r"" || m[0] == ""\n"") {"
 W !,"          var txt = content.appendChild(elt(""span"", m[0] == ""\r"" ? ""\u240d"" : ""\u2424"", ""cm-invalidchar""));"
 W !,"          txt.setAttribute(""cm-text"", m[0]);"
 W !,"          builder.col += 1;"
 W !,"        } else {"
 W !,"          var txt = builder.cm.options.specialCharPlaceholder(m[0]);"
 W !,"          txt.setAttribute(""cm-text"", m[0]);"
 W !,"          if (ie && ie_version < 9) content.appendChild(elt(""span"", [txt]));"
 W !,"          else content.appendChild(txt);"
 W !,"          builder.col += 1;"
 W !,"        }"
 W !,"        builder.map.push(builder.pos, builder.pos + 1, txt);"
 W !,"        builder.pos++;"
 W !,"      }"
 W !,"    }"
 W !,"    if (style || startStyle || endStyle || mustWrap || css) {"
 W !,"      var fullStyle = style || """";"
 W !,"      if (startStyle) fullStyle += startStyle;"
 W !,"      if (endStyle) fullStyle += endStyle;"
 W !,"      var token = elt(""span"", [content], fullStyle, css);"
 W !,"      if (title) token.title = title;"
 W !,"      return builder.content.appendChild(token);"
 W !,"    }"
 W !,"    builder.content.appendChild(content);"
 W !,"  }"

 W !,"  function splitSpaces(old) {"
 W !,"    var out = "" "";"
 W !,"    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? "" "" : ""\u00a0"";"
 W !,"    out += "" "";"
 W !,"    return out;"
 W !,"  }"

 W !,"  // Work around nonsense dimensions being reported for stretches of"
 W !,"  // right-to-left text."
 W !,"  function buildTokenBadBidi(inner, order) {"
 W !,"    return function(builder, text, style, startStyle, endStyle, title, css) {"
 W !,"      style = style ? style + "" cm-force-border"" : ""cm-force-border"";"
 W !,"      var start = builder.pos, end = start + text.length;"
 W !,"      for (;;) {"
 W !,"        // Find the part that overlaps with the start of this text"
 W !,"        for (var i = 0; i < order.length; i++) {"
 W !,"          var part = order[i];"
 W !,"          if (part.to > start && part.from <= start) break;"
 W !,"        }"
 W !,"        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);"
 W !,"        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);"
 W !,"        startStyle = null;"
 W !,"        text = text.slice(part.to - start);"
 W !,"        start = part.to;"
 W !,"      }"
 W !,"    };"
 W !,"  }"

 W !,"  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {"
 W !,"    var widget = !ignoreWidget && marker.widgetNode;"
 W !,"    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);"
 W !,"    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {"
 W !,"      if (!widget)"
 W !,"        widget = builder.content.appendChild(document.createElement(""span""));"
 W !,"      widget.setAttribute(""cm-marker"", marker.id);"
 W !,"    }"
 W !,"    if (widget) {"
 W !,"      builder.cm.display.input.setUneditable(widget);"
 W !,"      builder.content.appendChild(widget);"
 W !,"    }"
 W !,"    builder.pos += size;"
 W !,"  }"

 W !,"  // Outputs a number of spans to make up a line, taking highlighting"
 W !,"  // and marked text into account."
 W !,"  function insertLineContent(line, builder, styles) {"
 W !,"    var spans = line.markedSpans, allText = line.text, at = 0;"
 W !,"    if (!spans) {"
 W !,"      for (var i = 1; i < styles.length; i+=2)"
 W !,"        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));"
 W !,"      return;"
 W !,"    }"

 W !,"    var len = allText.length, pos = 0, i = 1, text = """", style, css;"
 W !,"    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;"
 W !,"    for (;;) {"
 W !,"      if (nextChange == pos) { // Update current marker set"
 W !,"        spanStyle = spanEndStyle = spanStartStyle = title = css = """";"
 W !,"        collapsed = null; nextChange = Infinity;"
 W !,"        var foundBookmarks = [], endStyles"
 W !,"        for (var j = 0; j < spans.length; ++j) {"
 W !,"          var sp = spans[j], m = sp.marker;"
 W !,"          if (m.type == ""bookmark"" && sp.from == pos && m.widgetNode) {"
 W !,"            foundBookmarks.push(m);"
 W !,"          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {"
 W !,"            if (sp.to != null && sp.to != pos && nextChange > sp.to) {"
 W !,"              nextChange = sp.to;"
 W !,"              spanEndStyle = """";"
 W !,"            }"
 W !,"            if (m.className) spanStyle += "" "" + m.className;"
 W !,"            if (m.css) css = (css ? css + "";"" : """") + m.css;"
 W !,"            if (m.startStyle && sp.from == pos) spanStartStyle += "" "" + m.startStyle;"
 W !,"            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)"
 W !,"            if (m.title && !title) title = m.title;"
 W !,"            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))"
 W !,"              collapsed = sp;"
 W !,"          } else if (sp.from > pos && nextChange > sp.from) {"
 W !,"            nextChange = sp.from;"
 W !,"          }"
 W !,"        }"
 W !,"        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)"
 W !,"          if (endStyles[j + 1] == nextChange) spanEndStyle += "" "" + endStyles[j]"

 W !,"        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)"
 W !,"          buildCollapsedSpan(builder, 0, foundBookmarks[j]);"
 W !,"        if (collapsed && (collapsed.from || 0) == pos) {"
 W !,"          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,"
 W !,"                             collapsed.marker, collapsed.from == null);"
 W !,"          if (collapsed.to == null) return;"
 W !,"          if (collapsed.to == pos) collapsed = false;"
 W !,"        }"
 W !,"      }"
 W !,"      if (pos >= len) break;"

 W !,"      var upto = Math.min(len, nextChange);"
 W !,"      while (true) {"
 W !,"        if (text) {"
 W !,"          var end = pos + text.length;"
 W !,"          if (!collapsed) {"
 W !,"            var tokenText = end > upto ? text.slice(0, upto - pos) : text;"
 W !,"            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,"
 W !,"                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : """", title, css);"
 W !,"          }"
 W !,"          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}"
 W !,"          pos = end;"
 W !,"          spanStartStyle = """";"
 W !,"        }"
 W !,"        text = allText.slice(at, at = styles[i++]);"
 W !,"        style = interpretTokenStyle(styles[i++], builder.cm.options);"
 W !,"      }"
 W !,"    }"
 W !,"  }"

 W !,"  // DOCUMENT DATA STRUCTURE"

 W !,"  // By default, updates that start and end at the beginning of a line"
 W !,"  // are treated specially, in order to make the association of line"
 W !,"  // widgets and marker elements with the text behave more intuitive."
 W !,"  function isWholeLineUpdate(doc, change) {"
 W !,"    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == """" &&"
 W !,"      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);"
 W !,"  }"

 W !,"  // Perform a change on the document data structure."
 W !,"  function updateDoc(doc, change, markedSpans, estimateHeight) {"
 W !,"    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}"
 W !,"    function update(line, text, spans) {"
 W !,"      updateLine(line, text, spans, estimateHeight);"
 W !,"      signalLater(line, ""change"", line, change);"
 W !,"    }"
 W !,"    function linesFor(start, end) {"
 W !,"      for (var i = start, result = []; i < end; ++i)"
 W !,"        result.push(new Line(text[i], spansFor(i), estimateHeight));"
 W !,"      return result;"
 W !,"    }"

 W !,"    var from = change.from, to = change.to, text = change.text;"
 W !,"    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);"
 W !,"    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;"

 W !,"    // Adjust the line structure"
 W !,"    if (change.full) {"
 W !,"      doc.insert(0, linesFor(0, text.length));"
 W !,"      doc.remove(text.length, doc.size - text.length);"
 W !,"    } else if (isWholeLineUpdate(doc, change)) {"
 W !,"      // This is a whole-line replace. Treated specially to make"
 W !,"      // sure line objects move the way they are supposed to."
 W !,"      var added = linesFor(0, text.length - 1);"
 W !,"      update(lastLine, lastLine.text, lastSpans);"
 W !,"      if (nlines) doc.remove(from.line, nlines);"
 W !,"      if (added.length) doc.insert(from.line, added);"
 W !,"    } else if (firstLine == lastLine) {"
 W !,"      if (text.length == 1) {"
 W !,"        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);"
 W !,"      } else {"
 W !,"        var added = linesFor(1, text.length - 1);"
 W !,"        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));"
 W !,"        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));"
 W !,"        doc.insert(from.line + 1, added);"
 W !,"      }"
 W !,"    } else if (text.length == 1) {"
 W !,"      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));"
 W !,"      doc.remove(from.line + 1, nlines);"
 W !,"    } else {"
 W !,"      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));"
 W !,"      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);"
 W !,"      var added = linesFor(1, text.length - 1);"
 W !,"      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);"
 W !,"      doc.insert(from.line + 1, added);"
 W !,"    }"

 W !,"    signalLater(doc, ""change"", doc, change);"
 W !,"  }"

 W !,"  // The document is represented as a BTree consisting of leaves, with"
 W !,"  // chunk of lines in them, and branches, with up to ten leaves or"
 W !,"  // other branch nodes below them. The top node is always a branch"
 W !,"  // node, and is the document object itself (meaning it has"
 W !,"  // additional methods and properties)."
 W !,"  //"
 W !,"  // All nodes have parent links. The tree is used both to go from"
 W !,"  // line numbers to line objects, and to go from objects to numbers."
 W !,"  // It also indexes by height, and is used to convert between height"
 W !,"  // and line object, and to find the total height of the document."
 W !,"  //"
 W !,"  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html"

 W !,"  function LeafChunk(lines) {"
 W !,"    this.lines = lines;"
 W !,"    this.parent = null;"
 W !,"    for (var i = 0, height = 0; i < lines.length; ++i) {"
 W !,"      lines[i].parent = this;"
 W !,"      height += lines[i].height;"
 W !,"    }"
 W !,"    this.height = height;"
 W !,"  }"

 W !,"  LeafChunk.prototype = {"
 W !,"    chunkSize: function() { return this.lines.length; },"
 W !,"    // Remove the n lines at offset 'at'."
 W !,"    removeInner: function(at, n) {"
 W !,"      for (var i = at, e = at + n; i < e; ++i) {"
 W !,"        var line = this.lines[i];"
 W !,"        this.height -= line.height;"
 W !,"        cleanUpLine(line);"
 W !,"        signalLater(line, ""delete"");"
 W !,"      }"
 W !,"      this.lines.splice(at, n);"
 W !,"    },"
 W !,"    // Helper used to collapse a small branch into a single leaf."
 W !,"    collapse: function(lines) {"
 W !,"      lines.push.apply(lines, this.lines);"
 W !,"    },"
 W !,"    // Insert the given array of lines at offset 'at', count them as"
 W !,"    // having the given height."
 W !,"    insertInner: function(at, lines, height) {"
 W !,"      this.height += height;"
 W !,"      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));"
 W !,"      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;"
 W !,"    },"
 W !,"    // Used to iterate over a part of the tree."
 W !,"    iterN: function(at, n, op) {"
 W !,"      for (var e = at + n; at < e; ++at)"
 W !,"        if (op(this.lines[at])) return true;"
 W !,"    }"
 W !,"  };"
}

ClassMethod ScriptLibCodemirror12()
{
 W !,"  function BranchChunk(children) {"
 W !,"    this.children = children;"
 W !,"    var size = 0, height = 0;"
 W !,"    for (var i = 0; i < children.length; ++i) {"
 W !,"      var ch = children[i];"
 W !,"      size += ch.chunkSize(); height += ch.height;"
 W !,"      ch.parent = this;"
 W !,"    }"
 W !,"    this.size = size;"
 W !,"    this.height = height;"
 W !,"    this.parent = null;"
 W !,"  }"

 W !,"  BranchChunk.prototype = {"
 W !,"    chunkSize: function() { return this.size; },"
 W !,"    removeInner: function(at, n) {"
 W !,"      this.size -= n;"
 W !,"      for (var i = 0; i < this.children.length; ++i) {"
 W !,"        var child = this.children[i], sz = child.chunkSize();"
 W !,"        if (at < sz) {"
 W !,"          var rm = Math.min(n, sz - at), oldHeight = child.height;"
 W !,"          child.removeInner(at, rm);"
 W !,"          this.height -= oldHeight - child.height;"
 W !,"          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }"
 W !,"          if ((n -= rm) == 0) break;"
 W !,"          at = 0;"
 W !,"        } else at -= sz;"
 W !,"      }"
 W !,"      // If the result is smaller than 25 lines, ensure that it is a"
 W !,"      // single leaf node."
 W !,"      if (this.size - n < 25 &&"
 W !,"          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {"
 W !,"        var lines = [];"
 W !,"        this.collapse(lines);"
 W !,"        this.children = [new LeafChunk(lines)];"
 W !,"        this.children[0].parent = this;"
 W !,"      }"
 W !,"    },"
 W !,"    collapse: function(lines) {"
 W !,"      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);"
 W !,"    },"
 W !,"    insertInner: function(at, lines, height) {"
 W !,"      this.size += lines.length;"
 W !,"      this.height += height;"
 W !,"      for (var i = 0; i < this.children.length; ++i) {"
 W !,"        var child = this.children[i], sz = child.chunkSize();"
 W !,"        if (at <= sz) {"
 W !,"          child.insertInner(at, lines, height);"
 W !,"          if (child.lines && child.lines.length > 50) {"
 W !,"            while (child.lines.length > 50) {"
 W !,"              var spilled = child.lines.splice(child.lines.length - 25, 25);"
 W !,"              var newleaf = new LeafChunk(spilled);"
 W !,"              child.height -= newleaf.height;"
 W !,"              this.children.splice(i + 1, 0, newleaf);"
 W !,"              newleaf.parent = this;"
 W !,"            }"
 W !,"            this.maybeSpill();"
 W !,"          }"
 W !,"          break;"
 W !,"        }"
 W !,"        at -= sz;"
 W !,"      }"
 W !,"    },"
 W !,"    // When a node has grown, check whether it should be split."
 W !,"    maybeSpill: function() {"
 W !,"      if (this.children.length <= 10) return;"
 W !,"      var me = this;"
 W !,"      do {"
 W !,"        var spilled = me.children.splice(me.children.length - 5, 5);"
 W !,"        var sibling = new BranchChunk(spilled);"
 W !,"        if (!me.parent) { // Become the parent node"
 W !,"          var copy = new BranchChunk(me.children);"
 W !,"          copy.parent = me;"
 W !,"          me.children = [copy, sibling];"
 W !,"          me = copy;"
 W !,"        } else {"
 W !,"          me.size -= sibling.size;"
 W !,"          me.height -= sibling.height;"
 W !,"          var myIndex = indexOf(me.parent.children, me);"
 W !,"          me.parent.children.splice(myIndex + 1, 0, sibling);"
 W !,"        }"
 W !,"        sibling.parent = me.parent;"
 W !,"      } while (me.children.length > 10);"
 W !,"      me.parent.maybeSpill();"
 W !,"    },"
 W !,"    iterN: function(at, n, op) {"
 W !,"      for (var i = 0; i < this.children.length; ++i) {"
 W !,"        var child = this.children[i], sz = child.chunkSize();"
 W !,"        if (at < sz) {"
 W !,"          var used = Math.min(n, sz - at);"
 W !,"          if (child.iterN(at, used, op)) return true;"
 W !,"          if ((n -= used) == 0) break;"
 W !,"          at = 0;"
 W !,"        } else at -= sz;"
 W !,"      }"
 W !,"    }"
 W !,"  };"

 W !,"  var nextDocId = 0;"
 W !,"  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {"
 W !,"    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);"
 W !,"    if (firstLine == null) firstLine = 0;"

 W !,"    BranchChunk.call(this, [new LeafChunk([new Line("""", null)])]);"
 W !,"    this.first = firstLine;"
 W !,"    this.scrollTop = this.scrollLeft = 0;"
 W !,"    this.cantEdit = false;"
 W !,"    this.cleanGeneration = 1;"
 W !,"    this.frontier = firstLine;"
 W !,"    var start = Pos(firstLine, 0);"
 W !,"    this.sel = simpleSelection(start);"
 W !,"    this.history = new History(null);"
 W !,"    this.id = ++nextDocId;"
 W !,"    this.modeOption = mode;"
 W !,"    this.lineSep = lineSep;"
 W !,"    this.extend = false;"

 W !,"    if (typeof text == ""string"") text = this.splitLines(text);"
 W !,"    updateDoc(this, {from: start, to: start, text: text});"
 W !,"    setSelection(this, simpleSelection(start), sel_dontScroll);"
 W !,"  };"

 W !,"  Doc.prototype = createObj(BranchChunk.prototype, {"
 W !,"    constructor: Doc,"
 W !,"    // Iterate over the document. Supports two forms -- with only one"
 W !,"    // argument, it calls that for each line in the document. With"
 W !,"    // three, it iterates over the range given by the first two (with"
 W !,"    // the second being non-inclusive)."
 W !,"    iter: function(from, to, op) {"
 W !,"      if (op) this.iterN(from - this.first, to - from, op);"
 W !,"      else this.iterN(this.first, this.first + this.size, from);"
 W !,"    },"

 W !,"    // Non-public interface for adding and removing lines."
 W !,"    insert: function(at, lines) {"
 W !,"      var height = 0;"
 W !,"      for (var i = 0; i < lines.length; ++i) height += lines[i].height;"
 W !,"      this.insertInner(at - this.first, lines, height);"
 W !,"    },"
 W !,"    remove: function(at, n) { this.removeInner(at - this.first, n); },"

 W !,"    // From here, the methods are part of the public interface. Most"
 W !,"    // are also available from CodeMirror (editor) instances."

 W !,"    getValue: function(lineSep) {"
 W !,"      var lines = getLines(this, this.first, this.first + this.size);"
 W !,"      if (lineSep === false) return lines;"
 W !,"      return lines.join(lineSep || this.lineSeparator());"
 W !,"    },"
 W !,"    setValue: docMethodOp(function(code) {"
 W !,"      var top = Pos(this.first, 0), last = this.first + this.size - 1;"
 W !,"      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),"
 W !,"                        text: this.splitLines(code), origin: ""setValue"", full: true}, true);"
 W !,"      setSelection(this, simpleSelection(top));"
 W !,"    }),"
 W !,"    replaceRange: function(code, from, to, origin) {"
 W !,"      from = clipPos(this, from);"
 W !,"      to = to ? clipPos(this, to) : from;"
 W !,"      replaceRange(this, code, from, to, origin);"
 W !,"    },"
 W !,"    getRange: function(from, to, lineSep) {"
 W !,"      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));"
 W !,"      if (lineSep === false) return lines;"
 W !,"      return lines.join(lineSep || this.lineSeparator());"
 W !,"    },"

 W !,"    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},"

 W !,"    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},"
 W !,"    getLineNumber: function(line) {return lineNo(line);},"

 W !,"    getLineHandleVisualStart: function(line) {"
 W !,"      if (typeof line == ""number"") line = getLine(this, line);"
 W !,"      return visualLine(line);"
 W !,"    },"

 W !,"    lineCount: function() {return this.size;},"
 W !,"    firstLine: function() {return this.first;},"
 W !,"    lastLine: function() {return this.first + this.size - 1;},"

 W !,"    clipPos: function(pos) {return clipPos(this, pos);},"

 W !,"    getCursor: function(start) {"
 W !,"      var range = this.sel.primary(), pos;"
 W !,"      if (start == null || start == ""head"") pos = range.head;"
 W !,"      else if (start == ""anchor"") pos = range.anchor;"
 W !,"      else if (start == ""end"" || start == ""to"" || start === false) pos = range.to();"
 W !,"      else pos = range.from();"
 W !,"      return pos;"
 W !,"    },"
 W !,"    listSelections: function() { return this.sel.ranges; },"
 W !,"    somethingSelected: function() {return this.sel.somethingSelected();},"

 W !,"    setCursor: docMethodOp(function(line, ch, options) {"
 W !,"      setSimpleSelection(this, clipPos(this, typeof line == ""number"" ? Pos(line, ch || 0) : line), null, options);"
 W !,"    }),"
 W !,"    setSelection: docMethodOp(function(anchor, head, options) {"
 W !,"      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);"
 W !,"    }),"
 W !,"    extendSelection: docMethodOp(function(head, other, options) {"
 W !,"      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);"
 W !,"    }),"
 W !,"    extendSelections: docMethodOp(function(heads, options) {"
 W !,"      extendSelections(this, clipPosArray(this, heads), options);"
 W !,"    }),"
 W !,"    extendSelectionsBy: docMethodOp(function(f, options) {"
 W !,"      var heads = map(this.sel.ranges, f);"
 W !,"      extendSelections(this, clipPosArray(this, heads), options);"
 W !,"    }),"
 W !,"    setSelections: docMethodOp(function(ranges, primary, options) {"
 W !,"      if (!ranges.length) return;"
 W !,"      for (var i = 0, out = []; i < ranges.length; i++)"
 W !,"        out[i] = new Range(clipPos(this, ranges[i].anchor),"
 W !,"                           clipPos(this, ranges[i].head));"
 W !,"      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);"
 W !,"      setSelection(this, normalizeSelection(out, primary), options);"
 W !,"    }),"
 W !,"    addSelection: docMethodOp(function(anchor, head, options) {"
 W !,"      var ranges = this.sel.ranges.slice(0);"
 W !,"      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));"
 W !,"      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);"
 W !,"    }),"

 W !,"    getSelection: function(lineSep) {"
 W !,"      var ranges = this.sel.ranges, lines;"
 W !,"      for (var i = 0; i < ranges.length; i++) {"
 W !,"        var sel = getBetween(this, ranges[i].from(), ranges[i].to());"
 W !,"        lines = lines ? lines.concat(sel) : sel;"
 W !,"      }"
 W !,"      if (lineSep === false) return lines;"
 W !,"      else return lines.join(lineSep || this.lineSeparator());"
 W !,"    },"
 W !,"    getSelections: function(lineSep) {"
 W !,"      var parts = [], ranges = this.sel.ranges;"
 W !,"      for (var i = 0; i < ranges.length; i++) {"
 W !,"        var sel = getBetween(this, ranges[i].from(), ranges[i].to());"
 W !,"        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());"
 W !,"        parts[i] = sel;"
 W !,"      }"
 W !,"      return parts;"
 W !,"    },"
 W !,"    replaceSelection: function(code, collapse, origin) {"
 W !,"      var dup = [];"
 W !,"      for (var i = 0; i < this.sel.ranges.length; i++)"
 W !,"        dup[i] = code;"
 W !,"      this.replaceSelections(dup, collapse, origin || ""+input"");"
 W !,"    },"
 W !,"    replaceSelections: docMethodOp(function(code, collapse, origin) {"
 W !,"      var changes = [], sel = this.sel;"
 W !,"      for (var i = 0; i < sel.ranges.length; i++) {"
 W !,"        var range = sel.ranges[i];"
 W !,"        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};"
 W !,"      }"
 W !,"      var newSel = collapse && collapse != ""end"" && computeReplacedSel(this, changes, collapse);"
 W !,"      for (var i = changes.length - 1; i >= 0; i--)"
 W !,"        makeChange(this, changes[i]);"
 W !,"      if (newSel) setSelectionReplaceHistory(this, newSel);"
 W !,"      else if (this.cm) ensureCursorVisible(this.cm);"
 W !,"    }),"
 W !,"    undo: docMethodOp(function() {makeChangeFromHistory(this, ""undo"");}),"
 W !,"    redo: docMethodOp(function() {makeChangeFromHistory(this, ""redo"");}),"
 W !,"    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, ""undo"", true);}),"
 W !,"    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, ""redo"", true);}),"

 W !,"    setExtending: function(val) {this.extend = val;},"
 W !,"    getExtending: function() {return this.extend;},"

 W !,"    historySize: function() {"
 W !,"      var hist = this.history, done = 0, undone = 0;"
 W !,"      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;"
 W !,"      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;"
 W !,"      return {undo: done, redo: undone};"
 W !,"    },"
 W !,"    clearHistory: function() {this.history = new History(this.history.maxGeneration);},"

 W !,"    markClean: function() {"
 W !,"      this.cleanGeneration = this.changeGeneration(true);"
 W !,"    },"
 W !,"    changeGeneration: function(forceSplit) {"
 W !,"      if (forceSplit)"
 W !,"        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;"
 W !,"      return this.history.generation;"
 W !,"    },"
 W !,"    isClean: function (gen) {"
 W !,"      return this.history.generation == (gen || this.cleanGeneration);"
 W !,"    },"

 W !,"    getHistory: function() {"
 W !,"      return {done: copyHistoryArray(this.history.done),"
 W !,"              undone: copyHistoryArray(this.history.undone)};"
 W !,"    },"
 W !,"    setHistory: function(histData) {"
 W !,"      var hist = this.history = new History(this.history.maxGeneration);"
 W !,"      hist.done = copyHistoryArray(histData.done.slice(0), null, true);"
 W !,"      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);"
 W !,"    },"

 W !,"    addLineClass: docMethodOp(function(handle, where, cls) {"
 W !,"      return changeLine(this, handle, where == ""gutter"" ? ""gutter"" : ""class"", function(line) {"
 W !,"        var prop = where == ""text"" ? ""textClass"""
 W !,"                 : where == ""background"" ? ""bgClass"""
 W !,"                 : where == ""gutter"" ? ""gutterClass"" : ""wrapClass"";"
 W !,"        if (!line[prop]) line[prop] = cls;"
 W !,"        else if (classTest(cls).test(line[prop])) return false;"
 W !,"        else line[prop] += "" "" + cls;"
 W !,"        return true;"
 W !,"      });"
 W !,"    }),"
 W !,"    removeLineClass: docMethodOp(function(handle, where, cls) {"
 W !,"      return changeLine(this, handle, where == ""gutter"" ? ""gutter"" : ""class"", function(line) {"
 W !,"        var prop = where == ""text"" ? ""textClass"""
 W !,"                 : where == ""background"" ? ""bgClass"""
 W !,"                 : where == ""gutter"" ? ""gutterClass"" : ""wrapClass"";"
 W !,"        var cur = line[prop];"
 W !,"        if (!cur) return false;"
 W !,"        else if (cls == null) line[prop] = null;"
 W !,"        else {"
 W !,"          var found = cur.match(classTest(cls));"
 W !,"          if (!found) return false;"
 W !,"          var end = found.index + found[0].length;"
 W !,"          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? """" : "" "") + cur.slice(end) || null;"
 W !,"        }"
 W !,"        return true;"
 W !,"      });"
 W !,"    }),"

 W !,"    addLineWidget: docMethodOp(function(handle, node, options) {"
 W !,"      return addLineWidget(this, handle, node, options);"
 W !,"    }),"
 W !,"    removeLineWidget: function(widget) { widget.clear(); },"

 W !,"    markText: function(from, to, options) {"
 W !,"      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || ""range"");"
 W !,"    },"
 W !,"    setBookmark: function(pos, options) {"
 W !,"      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),"
 W !,"                      insertLeft: options && options.insertLeft,"
 W !,"                      clearWhenEmpty: false, shared: options && options.shared,"
 W !,"                      handleMouseEvents: options && options.handleMouseEvents};"
 W !,"      pos = clipPos(this, pos);"
 W !,"      return markText(this, pos, pos, realOpts, ""bookmark"");"
 W !,"    },"
 W !,"    findMarksAt: function(pos) {"
 W !,"      pos = clipPos(this, pos);"
 W !,"      var markers = [], spans = getLine(this, pos.line).markedSpans;"
 W !,"      if (spans) for (var i = 0; i < spans.length; ++i) {"
 W !,"        var span = spans[i];"
 W !,"        if ((span.from == null || span.from <= pos.ch) &&"
 W !,"            (span.to == null || span.to >= pos.ch))"
 W !,"          markers.push(span.marker.parent || span.marker);"
 W !,"      }"
 W !,"      return markers;"
 W !,"    },"
 W !,"    findMarks: function(from, to, filter) {"
 W !,"      from = clipPos(this, from); to = clipPos(this, to);"
 W !,"      var found = [], lineNo = from.line;"
 W !,"      this.iter(from.line, to.line + 1, function(line) {"
 W !,"        var spans = line.markedSpans;"
 W !,"        if (spans) for (var i = 0; i < spans.length; i++) {"
 W !,"          var span = spans[i];"
 W !,"          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||"
 W !,"                span.from == null && lineNo != from.line ||"
 W !,"                span.from != null && lineNo == to.line && span.from >= to.ch) &&"
 W !,"              (!filter || filter(span.marker)))"
 W !,"            found.push(span.marker.parent || span.marker);"
 W !,"        }"
 W !,"        ++lineNo;"
 W !,"      });"
 W !,"      return found;"
 W !,"    },"
 W !,"    getAllMarks: function() {"
 W !,"      var markers = [];"
 W !,"      this.iter(function(line) {"
 W !,"        var sps = line.markedSpans;"
 W !,"        if (sps) for (var i = 0; i < sps.length; ++i)"
 W !,"          if (sps[i].from != null) markers.push(sps[i].marker);"
 W !,"      });"
 W !,"      return markers;"
 W !,"    },"

 W !,"    posFromIndex: function(off) {"
 W !,"      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;"
 W !,"      this.iter(function(line) {"
 W !,"        var sz = line.text.length + sepSize;"
 W !,"        if (sz > off) { ch = off; return true; }"
 W !,"        off -= sz;"
 W !,"        ++lineNo;"
 W !,"      });"
 W !,"      return clipPos(this, Pos(lineNo, ch));"
 W !,"    },"
 W !,"    indexFromPos: function (coords) {"
 W !,"      coords = clipPos(this, coords);"
 W !,"      var index = coords.ch;"
 W !,"      if (coords.line < this.first || coords.ch < 0) return 0;"
 W !,"      var sepSize = this.lineSeparator().length;"
 W !,"      this.iter(this.first, coords.line, function (line) {"
 W !,"        index += line.text.length + sepSize;"
 W !,"      });"
 W !,"      return index;"
 W !,"    },"

 W !,"    copy: function(copyHistory) {"
 W !,"      var doc = new Doc(getLines(this, this.first, this.first + this.size),"
 W !,"                        this.modeOption, this.first, this.lineSep);"
 W !,"      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;"
 W !,"      doc.sel = this.sel;"
 W !,"      doc.extend = false;"
 W !,"      if (copyHistory) {"
 W !,"        doc.history.undoDepth = this.history.undoDepth;"
 W !,"        doc.setHistory(this.getHistory());"
 W !,"      }"
 W !,"      return doc;"
 W !,"    },"

 W !,"    linkedDoc: function(options) {"
 W !,"      if (!options) options = {};"
 W !,"      var from = this.first, to = this.first + this.size;"
 W !,"      if (options.from != null && options.from > from) from = options.from;"
 W !,"      if (options.to != null && options.to < to) to = options.to;"
 W !,"      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);"
 W !,"      if (options.sharedHist) copy.history = this.history;"
 W !,"      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});"
 W !,"      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];"
 W !,"      copySharedMarkers(copy, findSharedMarkers(this));"
 W !,"      return copy;"
 W !,"    },"
 W !,"    unlinkDoc: function(other) {"
 W !,"      if (other instanceof CodeMirror) other = other.doc;"
 W !,"      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {"
 W !,"        var link = this.linked[i];"
 W !,"        if (link.doc != other) continue;"
 W !,"        this.linked.splice(i, 1);"
 W !,"        other.unlinkDoc(this);"
 W !,"        detachSharedMarkers(findSharedMarkers(this));"
 W !,"        break;"
 W !,"      }"
 W !,"      // If the histories were shared, split them again"
 W !,"      if (other.history == this.history) {"
 W !,"        var splitIds = [other.id];"
 W !,"        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);"
 W !,"        other.history = new History(null);"
 W !,"        other.history.done = copyHistoryArray(this.history.done, splitIds);"
 W !,"        other.history.undone = copyHistoryArray(this.history.undone, splitIds);"
 W !,"      }"
 W !,"    },"
 W !,"    iterLinkedDocs: function(f) {linkedDocs(this, f);},"

 W !,"    getMode: function() {return this.mode;},"
 W !,"    getEditor: function() {return this.cm;},"

 W !,"    splitLines: function(str) {"
 W !,"      if (this.lineSep) return str.split(this.lineSep);"
 W !,"      return splitLinesAuto(str);"
 W !,"    },"
 W !,"    lineSeparator: function() { return this.lineSep || ""\n""; }"
 W !,"  });"

 W !,"  // Public alias."
 W !,"  Doc.prototype.eachLine = Doc.prototype.iter;"

 W !,"  // Set up methods on CodeMirror's prototype to redirect to the editor's document."
 W !,"  var dontDelegate = ""iter insert remove copy getEditor constructor"".split("" "");"
 W !,"  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)"
 W !,"    CodeMirror.prototype[prop] = (function(method) {"
 W !,"      return function() {return method.apply(this.doc, arguments);};"
 W !,"    })(Doc.prototype[prop]);"

 W !,"  eventMixin(Doc);"

 W !,"  // Call f for all linked documents."
 W !,"  function linkedDocs(doc, f, sharedHistOnly) {"
 W !,"    function propagate(doc, skip, sharedHist) {"
 W !,"      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {"
 W !,"        var rel = doc.linked[i];"
 W !,"        if (rel.doc == skip) continue;"
 W !,"        var shared = sharedHist && rel.sharedHist;"
 W !,"        if (sharedHistOnly && !shared) continue;"
 W !,"        f(rel.doc, shared);"
 W !,"        propagate(rel.doc, doc, shared);"
 W !,"      }"
 W !,"    }"
 W !,"    propagate(doc, null, true);"
 W !,"  }"

 W !,"  // Attach a document to an editor."
 W !,"  function attachDoc(cm, doc) {"
 W !,"    if (doc.cm) throw new Error(""This document is already in use."");"
 W !,"    cm.doc = doc;"
 W !,"    doc.cm = cm;"
 W !,"    estimateLineHeights(cm);"
 W !,"    loadMode(cm);"
 W !,"    if (!cm.options.lineWrapping) findMaxLine(cm);"
 W !,"    cm.options.mode = doc.modeOption;"
 W !,"    regChange(cm);"
 W !,"  }"

 W !,"  // LINE UTILITIES"

 W !,"  // Find the line object corresponding to the given line number."
 W !,"  function getLine(doc, n) {"
 W !,"    n -= doc.first;"
 W !,"    if (n < 0 || n >= doc.size) throw new Error(""There is no line "" + (n + doc.first) + "" in the document."");"
 W !,"    for (var chunk = doc; !chunk.lines;) {"
 W !,"      for (var i = 0;; ++i) {"
 W !,"        var child = chunk.children[i], sz = child.chunkSize();"
 W !,"        if (n < sz) { chunk = child; break; }"
 W !,"        n -= sz;"
 W !,"      }"
 W !,"    }"
 W !,"    return chunk.lines[n];"
 W !,"  }"

 W !,"  // Get the part of a document between two positions, as an array of"
 W !,"  // strings."
 W !,"  function getBetween(doc, start, end) {"
 W !,"    var out = [], n = start.line;"
 W !,"    doc.iter(start.line, end.line + 1, function(line) {"
 W !,"      var text = line.text;"
 W !,"      if (n == end.line) text = text.slice(0, end.ch);"
 W !,"      if (n == start.line) text = text.slice(start.ch);"
 W !,"      out.push(text);"
 W !,"      ++n;"
 W !,"    });"
 W !,"    return out;"
 W !,"  }"
 W !,"  // Get the lines between from and to, as array of strings."
 W !,"  function getLines(doc, from, to) {"
 W !,"    var out = [];"
 W !,"    doc.iter(from, to, function(line) { out.push(line.text); });"
 W !,"    return out;"
 W !,"  }"

 W !,"  // Update the height of a line, propagating the height change"
 W !,"  // upwards to parent nodes."
 W !,"  function updateLineHeight(line, height) {"
 W !,"    var diff = height - line.height;"
 W !,"    if (diff) for (var n = line; n; n = n.parent) n.height += diff;"
 W !,"  }"

 W !,"  // Given a line object, find its line number by walking up through"
 W !,"  // its parent links."
 W !,"  function lineNo(line) {"
 W !,"    if (line.parent == null) return null;"
 W !,"    var cur = line.parent, no = indexOf(cur.lines, line);"
 W !,"    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {"
 W !,"      for (var i = 0;; ++i) {"
 W !,"        if (chunk.children[i] == cur) break;"
 W !,"        no += chunk.children[i].chunkSize();"
 W !,"      }"
 W !,"    }"
 W !,"    return no + cur.first;"
 W !,"  }"

 W !,"  // Find the line at the given vertical position, using the height"
 W !,"  // information in the document tree."
 W !,"  function lineAtHeight(chunk, h) {"
 W !,"    var n = chunk.first;"
 W !,"    outer: do {"
 W !,"      for (var i = 0; i < chunk.children.length; ++i) {"
 W !,"        var child = chunk.children[i], ch = child.height;"
 W !,"        if (h < ch) { chunk = child; continue outer; }"
 W !,"        h -= ch;"
 W !,"        n += child.chunkSize();"
 W !,"      }"
 W !,"      return n;"
 W !,"    } while (!chunk.lines);"
 W !,"    for (var i = 0; i < chunk.lines.length; ++i) {"
 W !,"      var line = chunk.lines[i], lh = line.height;"
 W !,"      if (h < lh) break;"
 W !,"      h -= lh;"
 W !,"    }"
 W !,"    return n + i;"
 W !,"  }"


 W !,"  // Find the height above the given line."
 W !,"  function heightAtLine(lineObj) {"
 W !,"    lineObj = visualLine(lineObj);"

 W !,"    var h = 0, chunk = lineObj.parent;"
 W !,"    for (var i = 0; i < chunk.lines.length; ++i) {"
 W !,"      var line = chunk.lines[i];"
 W !,"      if (line == lineObj) break;"
 W !,"      else h += line.height;"
 W !,"    }"
 W !,"    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {"
 W !,"      for (var i = 0; i < p.children.length; ++i) {"
 W !,"        var cur = p.children[i];"
 W !,"        if (cur == chunk) break;"
 W !,"        else h += cur.height;"
 W !,"      }"
 W !,"    }"
 W !,"    return h;"
 W !,"  }"

 W !,"  // Get the bidi ordering for the given line (and cache it). Returns"
 W !,"  // false for lines that are fully left-to-right, and an array of"
 W !,"  // BidiSpan objects otherwise."
 W !,"  function getOrder(line) {"
 W !,"    var order = line.order;"
 W !,"    if (order == null) order = line.order = bidiOrdering(line.text);"
 W !,"    return order;"
 W !,"  }"

 W !,"  // HISTORY"

 W !,"  function History(startGen) {"
 W !,"    // Arrays of change events and selections. Doing something adds an"
 W !,"    // event to done and clears undo. Undoing moves events from done"
 W !,"    // to undone, redoing moves them in the other direction."
 W !,"    this.done = []; this.undone = [];"
 W !,"    this.undoDepth = Infinity;"
 W !,"    // Used to track when changes can be merged into a single undo"
 W !,"    // event"
 W !,"    this.lastModTime = this.lastSelTime = 0;"
 W !,"    this.lastOp = this.lastSelOp = null;"
 W !,"    this.lastOrigin = this.lastSelOrigin = null;"
 W !,"    // Used by the isClean() method"
 W !,"    this.generation = this.maxGeneration = startGen || 1;"
 W !,"  }"

 W !,"  // Create a history change event from an updateDoc-style change"
 W !,"  // object."
 W !,"  function historyChangeFromChange(doc, change) {"
 W !,"    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};"
 W !,"    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);"
 W !,"    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);"
 W !,"    return histChange;"
 W !,"  }"

 W !,"  // Pop all selection events off the end of a history array. Stop at"
 W !,"  // a change event."
 W !,"  function clearSelectionEvents(array) {"
 W !,"    while (array.length) {"
 W !,"      var last = lst(array);"
 W !,"      if (last.ranges) array.pop();"
 W !,"      else break;"
 W !,"    }"
 W !,"  }"

 W !,"  // Find the top change event in the history. Pop off selection"
 W !,"  // events that are in the way."
 W !,"  function lastChangeEvent(hist, force) {"
 W !,"    if (force) {"
 W !,"      clearSelectionEvents(hist.done);"
 W !,"      return lst(hist.done);"
 W !,"    } else if (hist.done.length && !lst(hist.done).ranges) {"
 W !,"      return lst(hist.done);"
 W !,"    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {"
 W !,"      hist.done.pop();"
 W !,"      return lst(hist.done);"
 W !,"    }"
 W !,"  }"

 W !,"  // Register a change in the history. Merges changes that are within"
 W !,"  // a single operation, ore are close together with an origin that"
 W !,"  // allows merging (starting with ""+"") into a single event."
 W !,"  function addChangeToHistory(doc, change, selAfter, opId) {"
 W !,"    var hist = doc.history;"
 W !,"    hist.undone.length = 0;"
 W !,"    var time = +new Date, cur;"

 W !,"    if ((hist.lastOp == opId ||"
 W !,"         hist.lastOrigin == change.origin && change.origin &&"
 W !,"         ((change.origin.charAt(0) == ""+"" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||"
 W !,"          change.origin.charAt(0) == ""*"")) &&"
 W !,"        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {"
 W !,"      // Merge this change into the last event"
 W !,"      var last = lst(cur.changes);"
 W !,"      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {"
 W !,"        // Optimized case for simple insertion -- don't want to add"
 W !,"        // new changesets for every character typed"
 W !,"        last.to = changeEnd(change);"
 W !,"      } else {"
 W !,"        // Add new sub-event"
 W !,"        cur.changes.push(historyChangeFromChange(doc, change));"
 W !,"      }"
 W !,"    } else {"
 W !,"      // Can not be merged, start a new event."
 W !,"      var before = lst(hist.done);"
 W !,"      if (!before || !before.ranges)"
 W !,"        pushSelectionToHistory(doc.sel, hist.done);"
 W !,"      cur = {changes: [historyChangeFromChange(doc, change)],"
 W !,"             generation: hist.generation};"
 W !,"      hist.done.push(cur);"
 W !,"      while (hist.done.length > hist.undoDepth) {"
 W !,"        hist.done.shift();"
 W !,"        if (!hist.done[0].ranges) hist.done.shift();"
 W !,"      }"
 W !,"    }"
 W !,"    hist.done.push(selAfter);"
 W !,"    hist.generation = ++hist.maxGeneration;"
 W !,"    hist.lastModTime = hist.lastSelTime = time;"
 W !,"    hist.lastOp = hist.lastSelOp = opId;"
 W !,"    hist.lastOrigin = hist.lastSelOrigin = change.origin;"

 W !,"    if (!last) signal(doc, ""historyAdded"");"
 W !,"  }"

 W !,"  function selectionEventCanBeMerged(doc, origin, prev, sel) {"
 W !,"    var ch = origin.charAt(0);"
 W !,"    return ch == ""*"" ||"
 W !,"      ch == ""+"" &&"
 W !,"      prev.ranges.length == sel.ranges.length &&"
 W !,"      prev.somethingSelected() == sel.somethingSelected() &&"
 W !,"      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);"
 W !,"  }"
}

ClassMethod ScriptLibCodemirror13()
{
 W !,"  // Called whenever the selection changes, sets the new selection as"
 W !,"  // the pending selection in the history, and pushes the old pending"
 W !,"  // selection into the 'done' array when it was significantly"
 W !,"  // different (in number of selected ranges, emptiness, or time)."
 W !,"  function addSelectionToHistory(doc, sel, opId, options) {"
 W !,"    var hist = doc.history, origin = options && options.origin;"

 W !,"    // A new event is started when the previous origin does not match"
 W !,"    // the current, or the origins don't allow matching. Origins"
 W !,"    // starting with * are always merged, those starting with + are"
 W !,"    // merged when similar and close together in time."
 W !,"    if (opId == hist.lastSelOp ||"
 W !,"        (origin && hist.lastSelOrigin == origin &&"
 W !,"         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||"
 W !,"          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))"
 W !,"      hist.done[hist.done.length - 1] = sel;"
 W !,"    else"
 W !,"      pushSelectionToHistory(sel, hist.done);"

 W !,"    hist.lastSelTime = +new Date;"
 W !,"    hist.lastSelOrigin = origin;"
 W !,"    hist.lastSelOp = opId;"
 W !,"    if (options && options.clearRedo !== false)"
 W !,"      clearSelectionEvents(hist.undone);"
 W !,"  }"

 W !,"  function pushSelectionToHistory(sel, dest) {"
 W !,"    var top = lst(dest);"
 W !,"    if (!(top && top.ranges && top.equals(sel)))"
 W !,"      dest.push(sel);"
 W !,"  }"

 W !,"  // Used to store marked span information in the history."
 W !,"  function attachLocalSpans(doc, change, from, to) {"
 W !,"    var existing = change[""spans_"" + doc.id], n = 0;"
 W !,"    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {"
 W !,"      if (line.markedSpans)"
 W !,"        (existing || (existing = change[""spans_"" + doc.id] = {}))[n] = line.markedSpans;"
 W !,"      ++n;"
 W !,"    });"
 W !,"  }"

 W !,"  // When un/re-doing restores text containing marked spans, those"
 W !,"  // that have been explicitly cleared should not be restored."
 W !,"  function removeClearedSpans(spans) {"
 W !,"    if (!spans) return null;"
 W !,"    for (var i = 0, out; i < spans.length; ++i) {"
 W !,"      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }"
 W !,"      else if (out) out.push(spans[i]);"
 W !,"    }"
 W !,"    return !out ? spans : out.length ? out : null;"
 W !,"  }"

 W !,"  // Retrieve and filter the old marked spans stored in a change event."
 W !,"  function getOldSpans(doc, change) {"
 W !,"    var found = change[""spans_"" + doc.id];"
 W !,"    if (!found) return null;"
 W !,"    for (var i = 0, nw = []; i < change.text.length; ++i)"
 W !,"      nw.push(removeClearedSpans(found[i]));"
 W !,"    return nw;"
 W !,"  }"

 W !,"  // Used both to provide a JSON-safe object in .getHistory, and, when"
 W !,"  // detaching a document, to split the history in two"
 W !,"  function copyHistoryArray(events, newGroup, instantiateSel) {"
 W !,"    for (var i = 0, copy = []; i < events.length; ++i) {"
 W !,"      var event = events[i];"
 W !,"      if (event.ranges) {"
 W !,"        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);"
 W !,"        continue;"
 W !,"      }"
 W !,"      var changes = event.changes, newChanges = [];"
 W !,"      copy.push({changes: newChanges});"
 W !,"      for (var j = 0; j < changes.length; ++j) {"
 W !,"        var change = changes[j], m;"
 W !,"        newChanges.push({from: change.from, to: change.to, text: change.text});"
 W !,"        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {"
 W !,"          if (indexOf(newGroup, Number(m[1])) > -1) {"
 W !,"            lst(newChanges)[prop] = change[prop];"
 W !,"            delete change[prop];"
 W !,"          }"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"    return copy;"
 W !,"  }"

 W !,"  // Rebasing/resetting history to deal with externally-sourced changes"

 W !,"  function rebaseHistSelSingle(pos, from, to, diff) {"
 W !,"    if (to < pos.line) {"
 W !,"      pos.line += diff;"
 W !,"    } else if (from < pos.line) {"
 W !,"      pos.line = from;"
 W !,"      pos.ch = 0;"
 W !,"    }"
 W !,"  }"

 W !,"  // Tries to rebase an array of history events given a change in the"
 W !,"  // document. If the change touches the same lines as the event, the"
 W !,"  // event, and everything 'behind' it, is discarded. If the change is"
 W !,"  // before the event, the event's positions are updated. Uses a"
 W !,"  // copy-on-write scheme for the positions, to avoid having to"
 W !,"  // reallocate them all on every rebase, but also avoid problems with"
 W !,"  // shared position objects being unsafely updated."
 W !,"  function rebaseHistArray(array, from, to, diff) {"
 W !,"    for (var i = 0; i < array.length; ++i) {"
 W !,"      var sub = array[i], ok = true;"
 W !,"      if (sub.ranges) {"
 W !,"        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }"
 W !,"        for (var j = 0; j < sub.ranges.length; j++) {"
 W !,"          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);"
 W !,"          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);"
 W !,"        }"
 W !,"        continue;"
 W !,"      }"
 W !,"      for (var j = 0; j < sub.changes.length; ++j) {"
 W !,"        var cur = sub.changes[j];"
 W !,"        if (to < cur.from.line) {"
 W !,"          cur.from = Pos(cur.from.line + diff, cur.from.ch);"
 W !,"          cur.to = Pos(cur.to.line + diff, cur.to.ch);"
 W !,"        } else if (from <= cur.to.line) {"
 W !,"          ok = false;"
 W !,"          break;"
 W !,"        }"
 W !,"      }"
 W !,"      if (!ok) {"
 W !,"        array.splice(0, i + 1);"
 W !,"        i = 0;"
 W !,"      }"
 W !,"    }"
 W !,"  }"

 W !,"  function rebaseHist(hist, change) {"
 W !,"    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;"
 W !,"    rebaseHistArray(hist.done, from, to, diff);"
 W !,"    rebaseHistArray(hist.undone, from, to, diff);"
 W !,"  }"

 W !,"  // EVENT UTILITIES"

 W !,"  // Due to the fact that we still support jurassic IE versions, some"
 W !,"  // compatibility wrappers are needed."

 W !,"  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {"
 W !,"    if (e.preventDefault) e.preventDefault();"
 W !,"    else e.returnValue = false;"
 W !,"  };"
 W !,"  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {"
 W !,"    if (e.stopPropagation) e.stopPropagation();"
 W !,"    else e.cancelBubble = true;"
 W !,"  };"
 W !,"  function e_defaultPrevented(e) {"
 W !,"    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;"
 W !,"  }"
 W !,"  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};"

 W !,"  function e_target(e) {return e.target || e.srcElement;}"
 W !,"  function e_button(e) {"
 W !,"    var b = e.which;"
 W !,"    if (b == null) {"
 W !,"      if (e.button & 1) b = 1;"
 W !,"      else if (e.button & 2) b = 3;"
 W !,"      else if (e.button & 4) b = 2;"
 W !,"    }"
 W !,"    if (mac && e.ctrlKey && b == 1) b = 3;"
 W !,"    return b;"
 W !,"  }"

 W !,"  // EVENT HANDLING"

 W !,"  // Lightweight event framework. on/off also work on DOM nodes,"
 W !,"  // registering native DOM handlers."

 W !,"  var on = CodeMirror.on = function(emitter, type, f) {"
 W !,"    if (emitter.addEventListener)"
 W !,"      emitter.addEventListener(type, f, false);"
 W !,"    else if (emitter.attachEvent)"
 W !,"      emitter.attachEvent(""on"" + type, f);"
 W !,"    else {"
 W !,"      var map = emitter._handlers || (emitter._handlers = {});"
 W !,"      var arr = map[type] || (map[type] = []);"
 W !,"      arr.push(f);"
 W !,"    }"
 W !,"  };"

 W !,"  var noHandlers = []"
 W !,"  function getHandlers(emitter, type, copy) {"
 W !,"    var arr = emitter._handlers && emitter._handlers[type]"
 W !,"    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers"
 W !,"    else return arr || noHandlers"
 W !,"  }"

 W !,"  var off = CodeMirror.off = function(emitter, type, f) {"
 W !,"    if (emitter.removeEventListener)"
 W !,"      emitter.removeEventListener(type, f, false);"
 W !,"    else if (emitter.detachEvent)"
 W !,"      emitter.detachEvent(""on"" + type, f);"
 W !,"    else {"
 W !,"      var handlers = getHandlers(emitter, type, false)"
 W !,"      for (var i = 0; i < handlers.length; ++i)"
 W !,"        if (handlers[i] == f) { handlers.splice(i, 1); break; }"
 W !,"    }"
 W !,"  };"

 W !,"  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {"
 W !,"    var handlers = getHandlers(emitter, type, true)"
 W !,"    if (!handlers.length) return;"
 W !,"    var args = Array.prototype.slice.call(arguments, 2);"
 W !,"    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);"
 W !,"  };"

 W !,"  var orphanDelayedCallbacks = null;"

 W !,"  // Often, we want to signal events at a point where we are in the"
 W !,"  // middle of some work, but don't want the handler to start calling"
 W !,"  // other methods on the editor, which might be in an inconsistent"
 W !,"  // state or simply not expect any other events to happen."
 W !,"  // signalLater looks whether there are any handlers, and schedules"
 W !,"  // them to be executed when the last operation ends, or, if no"
 W !,"  // operation is active, when a timeout fires."
 W !,"  function signalLater(emitter, type /*, values...*/) {"
 W !,"    var arr = getHandlers(emitter, type, false)"
 W !,"    if (!arr.length) return;"
 W !,"    var args = Array.prototype.slice.call(arguments, 2), list;"
 W !,"    if (operationGroup) {"
 W !,"      list = operationGroup.delayedCallbacks;"
 W !,"    } else if (orphanDelayedCallbacks) {"
 W !,"      list = orphanDelayedCallbacks;"
 W !,"    } else {"
 W !,"      list = orphanDelayedCallbacks = [];"
 W !,"      setTimeout(fireOrphanDelayed, 0);"
 W !,"    }"
 W !,"    function bnd(f) {return function(){f.apply(null, args);};};"
 W !,"    for (var i = 0; i < arr.length; ++i)"
 W !,"      list.push(bnd(arr[i]));"
 W !,"  }"

 W !,"  function fireOrphanDelayed() {"
 W !,"    var delayed = orphanDelayedCallbacks;"
 W !,"    orphanDelayedCallbacks = null;"
 W !,"    for (var i = 0; i < delayed.length; ++i) delayed[i]();"
 W !,"  }"

 W !,"  // The DOM events that CodeMirror handles can be overridden by"
 W !,"  // registering a (non-DOM) handler on the editor for the event name,"
 W !,"  // and preventDefault-ing the event in that handler."
 W !,"  function signalDOMEvent(cm, e, override) {"
 W !,"    if (typeof e == ""string"")"
 W !,"      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};"
 W !,"    signal(cm, override || e.type, cm, e);"
 W !,"    return e_defaultPrevented(e) || e.codemirrorIgnore;"
 W !,"  }"

 W !,"  function signalCursorActivity(cm) {"
 W !,"    var arr = cm._handlers && cm._handlers.cursorActivity;"
 W !,"    if (!arr) return;"
 W !,"    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);"
 W !,"    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)"
 W !,"      set.push(arr[i]);"
 W !,"  }"

 W !,"  function hasHandler(emitter, type) {"
 W !,"    return getHandlers(emitter, type).length > 0"
 W !,"  }"

 W !,"  // Add on and off methods to a constructor's prototype, to make"
 W !,"  // registering events on such objects more convenient."
 W !,"  function eventMixin(ctor) {"
 W !,"    ctor.prototype.on = function(type, f) {on(this, type, f);};"
 W !,"    ctor.prototype.off = function(type, f) {off(this, type, f);};"
 W !,"  }"

 W !,"  // MISC UTILITIES"

 W !,"  // Number of pixels added to scroller and sizer to hide scrollbar"
 W !,"  var scrollerGap = 30;"

 W !,"  // Returned or thrown by various protocols to signal 'I'm not"
 W !,"  // handling this'."
 W !,"  var Pass = CodeMirror.Pass = {toString: function(){return ""CodeMirror.Pass"";}};"

 W !,"  // Reused option objects for setSelection & friends"
 W !,"  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: ""*mouse""}, sel_move = {origin: ""+move""};"

 W !,"  function Delayed() {this.id = null;}"
 W !,"  Delayed.prototype.set = function(ms, f) {"
 W !,"    clearTimeout(this.id);"
 W !,"    this.id = setTimeout(f, ms);"
 W !,"  };"

 W !,"  // Counts the column offset in a string, taking tabs into account."
 W !,"  // Used mostly to find indentation."
 W !,"  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {"
 W !,"    if (end == null) {"
 W !,"      end = string.search(/[^\s\u00a0]/);"
 W !,"      if (end == -1) end = string.length;"
 W !,"    }"
 W !,"    for (var i = startIndex || 0, n = startValue || 0;;) {"
 W !,"      var nextTab = string.indexOf(""\t"", i);"
 W !,"      if (nextTab < 0 || nextTab >= end)"
 W !,"        return n + (end - i);"
 W !,"      n += nextTab - i;"
 W !,"      n += tabSize - (n % tabSize);"
 W !,"      i = nextTab + 1;"
 W !,"    }"
 W !,"  };"

 W !,"  // The inverse of countColumn -- find the offset that corresponds to"
 W !,"  // a particular column."
 W !,"  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {"
 W !,"    for (var pos = 0, col = 0;;) {"
 W !,"      var nextTab = string.indexOf(""\t"", pos);"
 W !,"      if (nextTab == -1) nextTab = string.length;"
 W !,"      var skipped = nextTab - pos;"
 W !,"      if (nextTab == string.length || col + skipped >= goal)"
 W !,"        return pos + Math.min(skipped, goal - col);"
 W !,"      col += nextTab - pos;"
 W !,"      col += tabSize - (col % tabSize);"
 W !,"      pos = nextTab + 1;"
 W !,"      if (col >= goal) return pos;"
 W !,"    }"
 W !,"  }"

 W !,"  var spaceStrs = [""""];"
 W !,"  function spaceStr(n) {"
 W !,"    while (spaceStrs.length <= n)"
 W !,"      spaceStrs.push(lst(spaceStrs) + "" "");"
 W !,"    return spaceStrs[n];"
 W !,"  }"

 W !,"  function lst(arr) { return arr[arr.length-1]; }"

 W !,"  var selectInput = function(node) { node.select(); };"
 W !,"  if (ios) // Mobile Safari apparently has a bug where select() is broken."
 W !,"    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };"
 W !,"  else if (ie) // Suppress mysterious IE10 errors"
 W !,"    selectInput = function(node) { try { node.select(); } catch(_e) {} };"

 W !,"  function indexOf(array, elt) {"
 W !,"    for (var i = 0; i < array.length; ++i)"
 W !,"      if (array[i] == elt) return i;"
 W !,"    return -1;"
 W !,"  }"
 W !,"  function map(array, f) {"
 W !,"    var out = [];"
 W !,"    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);"
 W !,"    return out;"
 W !,"  }"

 W !,"  function nothing() {}"

 W !,"  function createObj(base, props) {"
 W !,"    var inst;"
 W !,"    if (Object.create) {"
 W !,"      inst = Object.create(base);"
 W !,"    } else {"
 W !,"      nothing.prototype = base;"
 W !,"      inst = new nothing();"
 W !,"    }"
 W !,"    if (props) copyObj(props, inst);"
 W !,"    return inst;"
 W !,"  };"

 W !,"  function copyObj(obj, target, overwrite) {"
 W !,"    if (!target) target = {};"
 W !,"    for (var prop in obj)"
 W !,"      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))"
 W !,"        target[prop] = obj[prop];"
 W !,"    return target;"
 W !,"  }"

 W !,"  function bind(f) {"
 W !,"    var args = Array.prototype.slice.call(arguments, 1);"
 W !,"    return function(){return f.apply(null, args);};"
 W !,"  }"

 W !,"  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;"
 W !,"  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {"
 W !,"    return /\w/.test(ch) || ch > ""\x80"" &&"
 W !,"      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));"
 W !,"  };"
 W !,"  function isWordChar(ch, helper) {"
 W !,"    if (!helper) return isWordCharBasic(ch);"
 W !,"    if (helper.source.indexOf(""\\w"") > -1 && isWordCharBasic(ch)) return true;"
 W !,"    return helper.test(ch);"
 W !,"  }"

 W !,"  function isEmpty(obj) {"
 W !,"    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;"
 W !,"    return true;"
 W !,"  }"

 W !,"  // Extending unicode characters. A series of a non-extending char +"
 W !,"  // any number of extending chars is treated as a single unit as far"
 W !,"  // as editing and measuring is concerned. This is not fully correct,"
 W !,"  // since some scripts/fonts/browsers also treat other configurations"
 W !,"  // of code points as a group."
 W !,"  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;"
 W !,"  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }"

 W !,"  // DOM UTILITIES"

 W !,"  function elt(tag, content, className, style) {"
 W !,"    var e = document.createElement(tag);"
 W !,"    if (className) e.className = className;"
 W !,"    if (style) e.style.cssText = style;"
 W !,"    if (typeof content == ""string"") e.appendChild(document.createTextNode(content));"
 W !,"    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);"
 W !,"    return e;"
 W !,"  }"

 W !,"  var range;"
 W !,"  if (document.createRange) range = function(node, start, end, endNode) {"
 W !,"    var r = document.createRange();"
 W !,"    r.setEnd(endNode || node, end);"
 W !,"    r.setStart(node, start);"
 W !,"    return r;"
 W !,"  };"
 W !,"  else range = function(node, start, end) {"
 W !,"    var r = document.body.createTextRange();"
 W !,"    try { r.moveToElementText(node.parentNode); }"
 W !,"    catch(e) { return r; }"
 W !,"    r.collapse(true);"
 W !,"    r.moveEnd(""character"", end);"
 W !,"    r.moveStart(""character"", start);"
 W !,"    return r;"
 W !,"  };"

 W !,"  function removeChildren(e) {"
 W !,"    for (var count = e.childNodes.length; count > 0; --count)"
 W !,"      e.removeChild(e.firstChild);"
 W !,"    return e;"
 W !,"  }"

 W !,"  function removeChildrenAndAdd(parent, e) {"
 W !,"    return removeChildren(parent).appendChild(e);"
 W !,"  }"

 W !,"  var contains = CodeMirror.contains = function(parent, child) {"
 W !,"    if (child.nodeType == 3) // Android browser always returns false when child is a textnode"
 W !,"      child = child.parentNode;"
 W !,"    if (parent.contains)"
 W !,"      return parent.contains(child);"
 W !,"    do {"
 W !,"      if (child.nodeType == 11) child = child.host;"
 W !,"      if (child == parent) return true;"
 W !,"    } while (child = child.parentNode);"
 W !,"  };"

 W !,"  function activeElt() {"
 W !,"    var activeElement = document.activeElement;"
 W !,"    while (activeElement && activeElement.root && activeElement.root.activeElement)"
 W !,"      activeElement = activeElement.root.activeElement;"
 W !,"    return activeElement;"
 W !,"  }"
 W !,"  // Older versions of IE throws unspecified error when touching"
 W !,"  // document.activeElement in some cases (during loading, in iframe)"
 W !,"  if (ie && ie_version < 11) activeElt = function() {"
 W !,"    try { return document.activeElement; }"
 W !,"    catch(e) { return document.body; }"
 W !,"  };"

 W !,"  function classTest(cls) { return new RegExp(""(^|\\s)"" + cls + ""(?:$|\\s)\\s*""); }"
 W !,"  var rmClass = CodeMirror.rmClass = function(node, cls) {"
 W !,"    var current = node.className;"
 W !,"    var match = classTest(cls).exec(current);"
 W !,"    if (match) {"
 W !,"      var after = current.slice(match.index + match[0].length);"
 W !,"      node.className = current.slice(0, match.index) + (after ? match[1] + after : """");"
 W !,"    }"
 W !,"  };"
 W !,"  var addClass = CodeMirror.addClass = function(node, cls) {"
 W !,"    var current = node.className;"
 W !,"    if (!classTest(cls).test(current)) node.className += (current ? "" "" : """") + cls;"
 W !,"  };"
 W !,"  function joinClasses(a, b) {"
 W !,"    var as = a.split("" "");"
 W !,"    for (var i = 0; i < as.length; i++)"
 W !,"      if (as[i] && !classTest(as[i]).test(b)) b += "" "" + as[i];"
 W !,"    return b;"
 W !,"  }"

 W !,"  // WINDOW-WIDE EVENTS"

 W !,"  // These must be handled carefully, because naively registering a"
 W !,"  // handler for each editor will cause the editors to never be"
 W !,"  // garbage collected."

 W !,"  function forEachCodeMirror(f) {"
 W !,"    if (!document.body.getElementsByClassName) return;"
 W !,"    var byClass = document.body.getElementsByClassName(""CodeMirror"");"
 W !,"    for (var i = 0; i < byClass.length; i++) {"
 W !,"      var cm = byClass[i].CodeMirror;"
 W !,"      if (cm) f(cm);"
 W !,"    }"
 W !,"  }"

 W !,"  var globalsRegistered = false;"
 W !,"  function ensureGlobalHandlers() {"
 W !,"    if (globalsRegistered) return;"
 W !,"    registerGlobalHandlers();"
 W !,"    globalsRegistered = true;"
 W !,"  }"
 W !,"  function registerGlobalHandlers() {"
 W !,"    // When the window resizes, we need to refresh active editors."
 W !,"    var resizeTimer;"
 W !,"    on(window, ""resize"", function() {"
 W !,"      if (resizeTimer == null) resizeTimer = setTimeout(function() {"
 W !,"        resizeTimer = null;"
 W !,"        forEachCodeMirror(onResize);"
 W !,"      }, 100);"
 W !,"    });"
 W !,"    // When the window loses focus, we want to show the editor as blurred"
 W !,"    on(window, ""blur"", function() {"
 W !,"      forEachCodeMirror(onBlur);"
 W !,"    });"
 W !,"  }"

 W !,"  // FEATURE DETECTION"

 W !,"  // Detect drag-and-drop"
 W !,"  var dragAndDrop = function() {"
 W !,"    // There is *some* kind of drag-and-drop support in IE6-8, but I"
 W !,"    // couldn't get it to work yet."
 W !,"    if (ie && ie_version < 9) return false;"
 W !,"    var div = elt('div');"
 W !,"    return ""draggable"" in div || ""dragDrop"" in div;"
 W !,"  }();"

 W !,"  var zwspSupported;"
 W !,"  function zeroWidthElement(measure) {"
 W !,"    if (zwspSupported == null) {"
 W !,"      var test = elt(""span"", ""\u200b"");"
 W !,"      removeChildrenAndAdd(measure, elt(""span"", [test, document.createTextNode(""x"")]));"
 W !,"      if (measure.firstChild.offsetHeight != 0)"
 W !,"        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);"
 W !,"    }"
 W !,"    var node = zwspSupported ? elt(""span"", ""\u200b"") :"
 W !,"      elt(""span"", ""\u00a0"", null, ""display: inline-block; width: 1px; margin-right: -1px"");"
 W !,"    node.setAttribute(""cm-text"", """");"
 W !,"    return node;"
 W !,"  }"

 W !,"  // Feature-detect IE's crummy client rect reporting for bidi text"
 W !,"  var badBidiRects;"
 W !,"  function hasBadBidiRects(measure) {"
 W !,"    if (badBidiRects != null) return badBidiRects;"
 W !,"    var txt = removeChildrenAndAdd(measure, document.createTextNode(""A\u062eA""));"
 W !,"    var r0 = range(txt, 0, 1).getBoundingClientRect();"
 W !,"    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)"
 W !,"    var r1 = range(txt, 1, 2).getBoundingClientRect();"
 W !,"    return badBidiRects = (r1.right - r0.right < 3);"
 W !,"  }"

 W !,"  // See if """".split is the broken IE version, if so, provide an"
 W !,"  // alternative way to split lines."
 W !,"  var splitLinesAuto = CodeMirror.splitLines = ""\n\nb"".split(/\n/).length != 3 ? function(string) {"
 W !,"    var pos = 0, result = [], l = string.length;"
 W !,"    while (pos <= l) {"
 W !,"      var nl = string.indexOf(""\n"", pos);"
 W !,"      if (nl == -1) nl = string.length;"
 W !,"      var line = string.slice(pos, string.charAt(nl - 1) == ""\r"" ? nl - 1 : nl);"
 W !,"      var rt = line.indexOf(""\r"");"
 W !,"      if (rt != -1) {"
 W !,"        result.push(line.slice(0, rt));"
 W !,"        pos += rt + 1;"
 W !,"      } else {"
 W !,"        result.push(line);"
 W !,"        pos = nl + 1;"
 W !,"      }"
 W !,"    }"
 W !,"    return result;"
 W !,"  } : function(string){return string.split(/\r\n?|\n/);};"

 W !,"  var hasSelection = window.getSelection ? function(te) {"
 W !,"    try { return te.selectionStart != te.selectionEnd; }"
 W !,"    catch(e) { return false; }"
 W !,"  } : function(te) {"
 W !,"    try {var range = te.ownerDocument.selection.createRange();}"
 W !,"    catch(e) {}"
 W !,"    if (!range || range.parentElement() != te) return false;"
 W !,"    return range.compareEndPoints(""StartToEnd"", range) != 0;"
 W !,"  };"

 W !,"  var hasCopyEvent = (function() {"
 W !,"    var e = elt(""div"");"
 W !,"    if (""oncopy"" in e) return true;"
 W !,"    e.setAttribute(""oncopy"", ""return;"");"
 W !,"    return typeof e.oncopy == ""function"";"
 W !,"  })();"

 W !,"  var badZoomedRects = null;"
 W !,"  function hasBadZoomedRects(measure) {"
 W !,"    if (badZoomedRects != null) return badZoomedRects;"
 W !,"    var node = removeChildrenAndAdd(measure, elt(""span"", ""x""));"
 W !,"    var normal = node.getBoundingClientRect();"
 W !,"    var fromRange = range(node, 0, 1).getBoundingClientRect();"
 W !,"    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;"
 W !,"  }"

 W !,"  // KEY NAMES"

 W !,"  var keyNames = CodeMirror.keyNames = {"
 W !,"    3: ""Enter"", 8: ""Backspace"", 9: ""Tab"", 13: ""Enter"", 16: ""Shift"", 17: ""Ctrl"", 18: ""Alt"","
 W !,"    19: ""Pause"", 20: ""CapsLock"", 27: ""Esc"", 32: ""Space"", 33: ""PageUp"", 34: ""PageDown"", 35: ""End"","
 W !,"    36: ""Home"", 37: ""Left"", 38: ""Up"", 39: ""Right"", 40: ""Down"", 44: ""PrintScrn"", 45: ""Insert"","
 W !,"    46: ""Delete"", 59: "";"", 61: ""="", 91: ""Mod"", 92: ""Mod"", 93: ""Mod"","
 W !,"    106: ""*"", 107: ""="", 109: ""-"", 110: ""."", 111: ""/"", 127: ""Delete"","
 W !,"    173: ""-"", 186: "";"", 187: ""="", 188: "","", 189: ""-"", 190: ""."", 191: ""/"", 192: ""`"", 219: ""["", 220: ""\\"","
 W !,"    221: ""]"", 222: ""'"", 63232: ""Up"", 63233: ""Down"", 63234: ""Left"", 63235: ""Right"", 63272: ""Delete"","
 W !,"    63273: ""Home"", 63275: ""End"", 63276: ""PageUp"", 63277: ""PageDown"", 63302: ""Insert"""
 W !,"  };"
 W !,"  (function() {"
 W !,"    // Number keys"
 W !,"    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);"
 W !,"    // Alphabetic keys"
 W !,"    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);"
 W !,"    // Function keys"
 W !,"    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = ""F"" + i;"
 W !,"  })();"

 W !,"  // BIDI HELPERS"

 W !,"  function iterateBidiSections(order, from, to, f) {"
 W !,"    if (!order) return f(from, to, ""ltr"");"
 W !,"    var found = false;"
 W !,"    for (var i = 0; i < order.length; ++i) {"
 W !,"      var part = order[i];"
 W !,"      if (part.from < to && part.to > from || from == to && part.to == from) {"
 W !,"        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? ""rtl"" : ""ltr"");"
 W !,"        found = true;"
 W !,"      }"
 W !,"    }"
 W !,"    if (!found) f(from, to, ""ltr"");"
 W !,"  }"

 W !,"  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }"
 W !,"  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }"

 W !,"  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }"
 W !,"  function lineRight(line) {"
 W !,"    var order = getOrder(line);"
 W !,"    if (!order) return line.text.length;"
 W !,"    return bidiRight(lst(order));"
 W !,"  }"

 W !,"  function lineStart(cm, lineN) {"
 W !,"    var line = getLine(cm.doc, lineN);"
 W !,"    var visual = visualLine(line);"
 W !,"    if (visual != line) lineN = lineNo(visual);"
 W !,"    var order = getOrder(visual);"
 W !,"    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);"
 W !,"    return Pos(lineN, ch);"
 W !,"  }"
 W !,"  function lineEnd(cm, lineN) {"
 W !,"    var merged, line = getLine(cm.doc, lineN);"
 W !,"    while (merged = collapsedSpanAtEnd(line)) {"
 W !,"      line = merged.find(1, true).line;"
 W !,"      lineN = null;"
 W !,"    }"
 W !,"    var order = getOrder(line);"
 W !,"    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);"
 W !,"    return Pos(lineN == null ? lineNo(line) : lineN, ch);"
 W !,"  }"
 W !,"  function lineStartSmart(cm, pos) {"
 W !,"    var start = lineStart(cm, pos.line);"
 W !,"    var line = getLine(cm.doc, start.line);"
 W !,"    var order = getOrder(line);"
 W !,"    if (!order || order[0].level == 0) {"
 W !,"      var firstNonWS = Math.max(0, line.text.search(/\S/));"
 W !,"      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;"
 W !,"      return Pos(start.line, inWS ? 0 : firstNonWS);"
 W !,"    }"
 W !,"    return start;"
 W !,"  }"

 W !,"  function compareBidiLevel(order, a, b) {"
 W !,"    var linedir = order[0].level;"
 W !,"    if (a == linedir) return true;"
 W !,"    if (b == linedir) return false;"
 W !,"    return a < b;"
 W !,"  }"
 W !,"  var bidiOther;"
 W !,"  function getBidiPartAt(order, pos) {"
 W !,"    bidiOther = null;"
 W !,"    for (var i = 0, found; i < order.length; ++i) {"
 W !,"      var cur = order[i];"
 W !,"      if (cur.from < pos && cur.to > pos) return i;"
 W !,"      if ((cur.from == pos || cur.to == pos)) {"
 W !,"        if (found == null) {"
 W !,"          found = i;"
 W !,"        } else if (compareBidiLevel(order, cur.level, order[found].level)) {"
 W !,"          if (cur.from != cur.to) bidiOther = found;"
 W !,"          return i;"
 W !,"        } else {"
 W !,"          if (cur.from != cur.to) bidiOther = i;"
 W !,"          return found;"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"    return found;"
 W !,"  }"
}

ClassMethod ScriptLibCodemirror14()
{
 W !,"  function moveInLine(line, pos, dir, byUnit) {"
 W !,"    if (!byUnit) return pos + dir;"
 W !,"    do pos += dir;"
 W !,"    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));"
 W !,"    return pos;"
 W !,"  }"

 W !,"  // This is needed in order to move 'visually' through bi-directional"
 W !,"  // text -- i.e., pressing left should make the cursor go left, even"
 W !,"  // when in RTL text. The tricky part is the 'jumps', where RTL and"
 W !,"  // LTR text touch each other. This often requires the cursor offset"
 W !,"  // to move more than one unit, in order to visually move one unit."
 W !,"  function moveVisually(line, start, dir, byUnit) {"
 W !,"    var bidi = getOrder(line);"
 W !,"    if (!bidi) return moveLogically(line, start, dir, byUnit);"
 W !,"    var pos = getBidiPartAt(bidi, start), part = bidi[pos];"
 W !,"    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);"

 W !,"    for (;;) {"
 W !,"      if (target > part.from && target < part.to) return target;"
 W !,"      if (target == part.from || target == part.to) {"
 W !,"        if (getBidiPartAt(bidi, target) == pos) return target;"
 W !,"        part = bidi[pos += dir];"
 W !,"        return (dir > 0) == part.level % 2 ? part.to : part.from;"
 W !,"      } else {"
 W !,"        part = bidi[pos += dir];"
 W !,"        if (!part) return null;"
 W !,"        if ((dir > 0) == part.level % 2)"
 W !,"          target = moveInLine(line, part.to, -1, byUnit);"
 W !,"        else"
 W !,"          target = moveInLine(line, part.from, 1, byUnit);"
 W !,"      }"
 W !,"    }"
 W !,"  }"

 W !,"  function moveLogically(line, start, dir, byUnit) {"
 W !,"    var target = start + dir;"
 W !,"    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;"
 W !,"    return target < 0 || target > line.text.length ? null : target;"
 W !,"  }"

 W !,"  // Bidirectional ordering algorithm"
 W !,"  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm"
 W !,"  // that this (partially) implements."

 W !,"  // One-char codes used for character types:"
 W !,"  // L (L):   Left-to-Right"
 W !,"  // R (R):   Right-to-Left"
 W !,"  // r (AL):  Right-to-Left Arabic"
 W !,"  // 1 (EN):  European Number"
 W !,"  // + (ES):  European Number Separator"
 W !,"  // % (ET):  European Number Terminator"
 W !,"  // n (AN):  Arabic Number"
 W !,"  // , (CS):  Common Number Separator"
 W !,"  // m (NSM): Non-Spacing Mark"
 W !,"  // b (BN):  Boundary Neutral"
 W !,"  // s (B):   Paragraph Separator"
 W !,"  // t (S):   Segment Separator"
 W !,"  // w (WS):  Whitespace"
 W !,"  // N (ON):  Other Neutrals"

 W !,"  // Returns null if characters are ordered as they appear"
 W !,"  // (left-to-right), or an array of sections ({from, to, level}"
 W !,"  // objects) in the order in which they occur visually."
 W !,"  var bidiOrdering = (function() {"
 W !,"    // Character types for codepoints 0 to 0xff"
 W !,"    var lowTypes = ""bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"";"
 W !,"    // Character types for codepoints 0x600 to 0x6ff"
 W !,"    var arabicTypes = ""rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm"";"
 W !,"    function charType(code) {"
 W !,"      if (code <= 0xf7) return lowTypes.charAt(code);"
 W !,"      else if (0x590 <= code && code <= 0x5f4) return ""R"";"
 W !,"      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);"
 W !,"      else if (0x6ee <= code && code <= 0x8ac) return ""r"";"
 W !,"      else if (0x2000 <= code && code <= 0x200b) return ""w"";"
 W !,"      else if (code == 0x200c) return ""b"";"
 W !,"      else return ""L"";"
 W !,"    }"

 W !,"    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;"
 W !,"    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;"
 W !,"    // Browsers seem to always treat the boundaries of block elements as being L."
 W !,"    var outerType = ""L"";"

 W !,"    function BidiSpan(level, from, to) {"
 W !,"      this.level = level;"
 W !,"      this.from = from; this.to = to;"
 W !,"    }"

 W !,"    return function(str) {"
 W !,"      if (!bidiRE.test(str)) return false;"
 W !,"      var len = str.length, types = [];"
 W !,"      for (var i = 0, type; i < len; ++i)"
 W !,"        types.push(type = charType(str.charCodeAt(i)));"

 W !,"      // W1. Examine each non-spacing mark (NSM) in the level run, and"
 W !,"      // change the type of the NSM to the type of the previous"
 W !,"      // character. If the NSM is at the start of the level run, it will"
 W !,"      // get the type of sor."
 W !,"      for (var i = 0, prev = outerType; i < len; ++i) {"
 W !,"        var type = types[i];"
 W !,"        if (type == ""m"") types[i] = prev;"
 W !,"        else prev = type;"
 W !,"      }"

 W !,"      // W2. Search backwards from each instance of a European number"
 W !,"      // until the first strong type (R, L, AL, or sor) is found. If an"
 W !,"      // AL is found, change the type of the European number to Arabic"
 W !,"      // number."
 W !,"      // W3. Change all ALs to R."
 W !,"      for (var i = 0, cur = outerType; i < len; ++i) {"
 W !,"        var type = types[i];"
 W !,"        if (type == ""1"" && cur == ""r"") types[i] = ""n"";"
 W !,"        else if (isStrong.test(type)) { cur = type; if (type == ""r"") types[i] = ""R""; }"
 W !,"      }"

 W !,"      // W4. A single European separator between two European numbers"
 W !,"      // changes to a European number. A single common separator between"
 W !,"      // two numbers of the same type changes to that type."
 W !,"      for (var i = 1, prev = types[0]; i < len - 1; ++i) {"
 W !,"        var type = types[i];"
 W !,"        if (type == ""+"" && prev == ""1"" && types[i+1] == ""1"") types[i] = ""1"";"
 W !,"        else if (type == "","" && prev == types[i+1] &&"
 W !,"                 (prev == ""1"" || prev == ""n"")) types[i] = prev;"
 W !,"        prev = type;"
 W !,"      }"

 W !,"      // W5. A sequence of European terminators adjacent to European"
 W !,"      // numbers changes to all European numbers."
 W !,"      // W6. Otherwise, separators and terminators change to Other"
 W !,"      // Neutral."
 W !,"      for (var i = 0; i < len; ++i) {"
 W !,"        var type = types[i];"
 W !,"        if (type == "","") types[i] = ""N"";"
 W !,"        else if (type == ""%"") {"
 W !,"          for (var end = i + 1; end < len && types[end] == ""%""; ++end) {}"
 W !,"          var replace = (i && types[i-1] == ""!"") || (end < len && types[end] == ""1"") ? ""1"" : ""N"";"
 W !,"          for (var j = i; j < end; ++j) types[j] = replace;"
 W !,"          i = end - 1;"
 W !,"        }"
 W !,"      }"

 W !,"      // W7. Search backwards from each instance of a European number"
 W !,"      // until the first strong type (R, L, or sor) is found. If an L is"
 W !,"      // found, then change the type of the European number to L."
 W !,"      for (var i = 0, cur = outerType; i < len; ++i) {"
 W !,"        var type = types[i];"
 W !,"        if (cur == ""L"" && type == ""1"") types[i] = ""L"";"
 W !,"        else if (isStrong.test(type)) cur = type;"
 W !,"      }"

 W !,"      // N1. A sequence of neutrals takes the direction of the"
 W !,"      // surrounding strong text if the text on both sides has the same"
 W !,"      // direction. European and Arabic numbers act as if they were R in"
 W !,"      // terms of their influence on neutrals. Start-of-level-run (sor)"
 W !,"      // and end-of-level-run (eor) are used at level run boundaries."
 W !,"      // N2. Any remaining neutrals take the embedding direction."
 W !,"      for (var i = 0; i < len; ++i) {"
 W !,"        if (isNeutral.test(types[i])) {"
 W !,"          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}"
 W !,"          var before = (i ? types[i-1] : outerType) == ""L"";"
 W !,"          var after = (end < len ? types[end] : outerType) == ""L"";"
 W !,"          var replace = before || after ? ""L"" : ""R"";"
 W !,"          for (var j = i; j < end; ++j) types[j] = replace;"
 W !,"          i = end - 1;"
 W !,"        }"
 W !,"      }"

 W !,"      // Here we depart from the documented algorithm, in order to avoid"
 W !,"      // building up an actual levels array. Since there are only three"
 W !,"      // levels (0, 1, 2) in an implementation that doesn't take"
 W !,"      // explicit embedding into account, we can build up the order on"
 W !,"      // the fly, without following the level-based algorithm."
 W !,"      var order = [], m;"
 W !,"      for (var i = 0; i < len;) {"
 W !,"        if (countsAsLeft.test(types[i])) {"
 W !,"          var start = i;"
 W !,"          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}"
 W !,"          order.push(new BidiSpan(0, start, i));"
 W !,"        } else {"
 W !,"          var pos = i, at = order.length;"
 W !,"          for (++i; i < len && types[i] != ""L""; ++i) {}"
 W !,"          for (var j = pos; j < i;) {"
 W !,"            if (countsAsNum.test(types[j])) {"
 W !,"              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));"
 W !,"              var nstart = j;"
 W !,"              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}"
 W !,"              order.splice(at, 0, new BidiSpan(2, nstart, j));"
 W !,"              pos = j;"
 W !,"            } else ++j;"
 W !,"          }"
 W !,"          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));"
 W !,"        }"
 W !,"      }"
 W !,"      if (order[0].level == 1 && (m = str.match(/^\s+/))) {"
 W !,"        order[0].from = m[0].length;"
 W !,"        order.unshift(new BidiSpan(0, 0, m[0].length));"
 W !,"      }"
 W !,"      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {"
 W !,"        lst(order).to -= m[0].length;"
 W !,"        order.push(new BidiSpan(0, len - m[0].length, len));"
 W !,"      }"
 W !,"      if (order[0].level == 2)"
 W !,"        order.unshift(new BidiSpan(1, order[0].to, order[0].to));"
 W !,"      if (order[0].level != lst(order).level)"
 W !,"        order.push(new BidiSpan(order[0].level, len, len));"

 W !,"      return order;"
 W !,"    };"
 W !,"  })();"

 W !,"  // THE END"

 W !,"  CodeMirror.version = ""5.14.3"";"

 W !,"  return CodeMirror;"
 W !,"});",!
}

ClassMethod ScriptModeXml()
{
	Do ..ScriptModeXml1()
	Do ..ScriptModeXml2()
	Do ..ScriptModeXml3()
}

ClassMethod ScriptModeXml1()
{
 W !,"// CodeMirror, copyright (c) by Marijn Haverbeke and others"
 W !,"// Distributed under an MIT license: http://codemirror.net/LICENSE"

 W !,"(function(mod) {"
 W !,"  if (typeof exports == ""object"" && typeof module == ""object"") // CommonJS"
 //W !,"    mod(require(""../../lib/codemirror""));"
 W !,"    mod(require(""ompare.Report.SourceView.cls?Script=ScriptLibCodemirror""));"
 W !,"  else if (typeof define == ""function"" && define.amd) // AMD"
 W !,"    define([""ompare.Report.SourceView.cls?Script=ScriptLibCodemirror""], mod);"
 W !,"  else // Plain browser env"
 W !,"    mod(CodeMirror);"
 W !,"})(function(CodeMirror) {"
 W !,"""use strict"";"

 W !,"var htmlConfig = {"
 W !,"  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,"
 W !,"                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,"
 W !,"                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,"
 W !,"                    'track': true, 'wbr': true, 'menuitem': true},"
 W !,"  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,"
 W !,"                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,"
 W !,"                     'th': true, 'tr': true},"
 W !,"  contextGrabbers: {"
 W !,"    'dd': {'dd': true, 'dt': true},"
 W !,"    'dt': {'dd': true, 'dt': true},"
 W !,"    'li': {'li': true},"
 W !,"    'option': {'option': true, 'optgroup': true},"
 W !,"    'optgroup': {'optgroup': true},"
 W !,"    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,"
 W !,"          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,"
 W !,"          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,"
 W !,"          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,"
 W !,"          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},"
 W !,"    'rp': {'rp': true, 'rt': true},"
 W !,"    'rt': {'rp': true, 'rt': true},"
 W !,"    'tbody': {'tbody': true, 'tfoot': true},"
 W !,"    'td': {'td': true, 'th': true},"
 W !,"    'tfoot': {'tbody': true},"
 W !,"    'th': {'td': true, 'th': true},"
 W !,"    'thead': {'tbody': true, 'tfoot': true},"
 W !,"    'tr': {'tr': true}"
 W !,"  },"
 W !,"  doNotIndent: {""pre"": true},"
 W !,"  allowUnquoted: true,"
 W !,"  allowMissing: true,"
 W !,"  caseFold: true"
 W !,"}"

 W !,"var xmlConfig = {"
 W !,"  autoSelfClosers: {},"
 W !,"  implicitlyClosed: {},"
 W !,"  contextGrabbers: {},"
 W !,"  doNotIndent: {},"
 W !,"  allowUnquoted: false,"
 W !,"  allowMissing: false,"
 W !,"  caseFold: false"
 W !,"}"

 W !,"CodeMirror.defineMode(""xml"", function(editorConf, config_) {"
 W !,"  var indentUnit = editorConf.indentUnit"
 W !,"  var config = {}"
 W !,"  var defaults = config_.htmlMode ? htmlConfig : xmlConfig"
 W !,"  for (var prop in defaults) config[prop] = defaults[prop]"
 W !,"  for (var prop in config_) config[prop] = config_[prop]"

 W !,"  // Return variables for tokenizers"
 W !,"  var type, setStyle;"

 W !,"  function inText(stream, state) {"
 W !,"    function chain(parser) {"
 W !,"      state.tokenize = parser;"
 W !,"      return parser(stream, state);"
 W !,"    }"

 W !,"    var ch = stream.next();"
 W !,"    if (ch == ""<"") {"
 W !,"      if (stream.eat(""!"")) {"
 W !,"        if (stream.eat(""["")) {"
 W !,"          if (stream.match(""CDATA["")) return chain(inBlock(""atom"", ""]]>""));"
 W !,"          else return null;"
 W !,"        } else if (stream.match(""--"")) {"
 W !,"          return chain(inBlock(""comment"", ""-->""));"
 W !,"        } else if (stream.match(""DOCTYPE"", true, true)) {"
 W !,"          stream.eatWhile(/[\w\._\-]/);"
 W !,"          return chain(doctype(1));"
 W !,"        } else {"
 W !,"          return null;"
 W !,"        }"
 W !,"      } else if (stream.eat(""?"")) {"
 W !,"        stream.eatWhile(/[\w\._\-]/);"
 W !,"        state.tokenize = inBlock(""meta"", ""?>"");"
 W !,"        return ""meta"";"
 W !,"      } else {"
 W !,"        type = stream.eat(""/"") ? ""closeTag"" : ""openTag"";"
 W !,"        state.tokenize = inTag;"
 W !,"        return ""tag bracket"";"
 W !,"      }"
 W !,"    } else if (ch == ""&"") {"
 W !,"      var ok;"
 W !,"      if (stream.eat(""#"")) {"
 W !,"        if (stream.eat(""x"")) {"
 W !,"          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat("";"");"
 W !,"        } else {"
 W !,"          ok = stream.eatWhile(/[\d]/) && stream.eat("";"");"
 W !,"        }"
 W !,"      } else {"
 W !,"        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat("";"");"
 W !,"      }"
 W !,"      return ok ? ""atom"" : ""error"";"
 W !,"    } else {"
 W !,"      stream.eatWhile(/[^&<]/);"
 W !,"      return null;"
 W !,"    }"
 W !,"  }"
 W !,"  inText.isInText = true;"

 W !,"  function inTag(stream, state) {"
 W !,"    var ch = stream.next();"
 W !,"    if (ch == "">"" || (ch == ""/"" && stream.eat("">""))) {"
 W !,"      state.tokenize = inText;"
 W !,"      type = ch == "">"" ? ""endTag"" : ""selfcloseTag"";"
 W !,"      return ""tag bracket"";"
 W !,"    } else if (ch == ""="") {"
 W !,"      type = ""equals"";"
 W !,"      return null;"
 W !,"    } else if (ch == ""<"") {"
 W !,"      state.tokenize = inText;"
 W !,"      state.state = baseState;"
 W !,"      state.tagName = state.tagStart = null;"
 W !,"      var next = state.tokenize(stream, state);"
 W !,"      return next ? next + "" tag error"" : ""tag error"";"
 W !,"    } else if (/[\'\""]/.test(ch)) {"
 W !,"      state.tokenize = inAttribute(ch);"
 W !,"      state.stringStartCol = stream.column();"
 W !,"      return state.tokenize(stream, state);"
 W !,"    } else {"
 W !,"      stream.match(/^[^\s\u00a0=<>\""\']*[^\s\u00a0=<>\""\'\/]/);"
 W !,"      return ""word"";"
 W !,"    }"
 W !,"  }"

 W !,"  function inAttribute(quote) {"
 W !,"    var closure = function(stream, state) {"
 W !,"      while (!stream.eol()) {"
 W !,"        if (stream.next() == quote) {"
 W !,"          state.tokenize = inTag;"
 W !,"          break;"
 W !,"        }"
 W !,"      }"
 W !,"      return ""string"";"
 W !,"    };"
 W !,"    closure.isInAttribute = true;"
 W !,"    return closure;"
 W !,"  }"

 W !,"  function inBlock(style, terminator) {"
 W !,"    return function(stream, state) {"
 W !,"      while (!stream.eol()) {"
 W !,"        if (stream.match(terminator)) {"
 W !,"          state.tokenize = inText;"
 W !,"          break;"
 W !,"        }"
 W !,"        stream.next();"
 W !,"      }"
 W !,"      return style;"
 W !,"    };"
 W !,"  }"
 W !,"  function doctype(depth) {"
 W !,"    return function(stream, state) {"
 W !,"      var ch;"
 W !,"      while ((ch = stream.next()) != null) {"
 W !,"        if (ch == ""<"") {"
 W !,"          state.tokenize = doctype(depth + 1);"
 W !,"          return state.tokenize(stream, state);"
 W !,"        } else if (ch == "">"") {"
 W !,"          if (depth == 1) {"
 W !,"            state.tokenize = inText;"
 W !,"            break;"
 W !,"          } else {"
 W !,"            state.tokenize = doctype(depth - 1);"
 W !,"            return state.tokenize(stream, state);"
 W !,"          }"
 W !,"        }"
 W !,"      }"
 W !,"      return ""meta"";"
 W !,"    };"
 W !,"  }"
}

ClassMethod ScriptModeXml2()
{
 W !,"  function Context(state, tagName, startOfLine) {"
 W !,"    this.prev = state.context;"
 W !,"    this.tagName = tagName;"
 W !,"    this.indent = state.indented;"
 W !,"    this.startOfLine = startOfLine;"
 W !,"    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))"
 W !,"      this.noIndent = true;"
 W !,"  }"
 W !,"  function popContext(state) {"
 W !,"    if (state.context) state.context = state.context.prev;"
 W !,"  }"
 W !,"  function maybePopContext(state, nextTagName) {"
 W !,"    var parentTagName;"
 W !,"    while (true) {"
 W !,"      if (!state.context) {"
 W !,"        return;"
 W !,"      }"
 W !,"      parentTagName = state.context.tagName;"
 W !,"      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||"
 W !,"          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {"
 W !,"        return;"
 W !,"      }"
 W !,"      popContext(state);"
 W !,"    }"
 W !,"  }"

 W !,"  function baseState(type, stream, state) {"
 W !,"    if (type == ""openTag"") {"
 W !,"      state.tagStart = stream.column();"
 W !,"      return tagNameState;"
 W !,"    } else if (type == ""closeTag"") {"
 W !,"      return closeTagNameState;"
 W !,"    } else {"
 W !,"      return baseState;"
 W !,"    }"
 W !,"  }"
 W !,"  function tagNameState(type, stream, state) {"
 W !,"    if (type == ""word"") {"
 W !,"      state.tagName = stream.current();"
 W !,"      setStyle = ""tag"";"
 W !,"      return attrState;"
 W !,"    } else {"
 W !,"      setStyle = ""error"";"
 W !,"      return tagNameState;"
 W !,"    }"
 W !,"  }"
 W !,"  function closeTagNameState(type, stream, state) {"
 W !,"    if (type == ""word"") {"
 W !,"      var tagName = stream.current();"
 W !,"      if (state.context && state.context.tagName != tagName &&"
 W !,"          config.implicitlyClosed.hasOwnProperty(state.context.tagName))"
 W !,"        popContext(state);"
 W !,"      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {"
 W !,"        setStyle = ""tag"";"
 W !,"        return closeState;"
 W !,"      } else {"
 W !,"        setStyle = ""tag error"";"
 W !,"        return closeStateErr;"
 W !,"      }"
 W !,"    } else {"
 W !,"      setStyle = ""error"";"
 W !,"      return closeStateErr;"
 W !,"    }"
 W !,"  }"

 W !,"  function closeState(type, _stream, state) {"
 W !,"    if (type != ""endTag"") {"
 W !,"      setStyle = ""error"";"
 W !,"      return closeState;"
 W !,"    }"
 W !,"    popContext(state);"
 W !,"    return baseState;"
 W !,"  }"
 W !,"  function closeStateErr(type, stream, state) {"
 W !,"    setStyle = ""error"";"
 W !,"    return closeState(type, stream, state);"
 W !,"  }"

 W !,"  function attrState(type, _stream, state) {"
 W !,"    if (type == ""word"") {"
 W !,"      setStyle = ""attribute"";"
 W !,"      return attrEqState;"
 W !,"    } else if (type == ""endTag"" || type == ""selfcloseTag"") {"
 W !,"      var tagName = state.tagName, tagStart = state.tagStart;"
 W !,"      state.tagName = state.tagStart = null;"
 W !,"      if (type == ""selfcloseTag"" ||"
 W !,"          config.autoSelfClosers.hasOwnProperty(tagName)) {"
 W !,"        maybePopContext(state, tagName);"
 W !,"      } else {"
 W !,"        maybePopContext(state, tagName);"
 W !,"        state.context = new Context(state, tagName, tagStart == state.indented);"
 W !,"      }"
 W !,"      return baseState;"
 W !,"    }"
 W !,"    setStyle = ""error"";"
 W !,"    return attrState;"
 W !,"  }"
 W !,"  function attrEqState(type, stream, state) {"
 W !,"    if (type == ""equals"") return attrValueState;"
 W !,"    if (!config.allowMissing) setStyle = ""error"";"
 W !,"    return attrState(type, stream, state);"
 W !,"  }"
 W !,"  function attrValueState(type, stream, state) {"
 W !,"    if (type == ""string"") return attrContinuedState;"
 W !,"    if (type == ""word"" && config.allowUnquoted) {setStyle = ""string""; return attrState;}"
 W !,"    setStyle = ""error"";"
 W !,"    return attrState(type, stream, state);"
 W !,"  }"
 W !,"  function attrContinuedState(type, stream, state) {"
 W !,"    if (type == ""string"") return attrContinuedState;"
 W !,"    return attrState(type, stream, state);"
 W !,"  }"
}

ClassMethod ScriptModeXml3()
{
 W !,"  return {"
 W !,"    startState: function(baseIndent) {"
 W !,"      var state = {tokenize: inText,"
 W !,"                   state: baseState,"
 W !,"                   indented: baseIndent || 0,"
 W !,"                   tagName: null, tagStart: null,"
 W !,"                   context: null}"
 W !,"      if (baseIndent != null) state.baseIndent = baseIndent"
 W !,"      return state"
 W !,"    },"

 W !,"    token: function(stream, state) {"
 W !,"      if (!state.tagName && stream.sol())"
 W !,"        state.indented = stream.indentation();"

 W !,"      if (stream.eatSpace()) return null;"
 W !,"      type = null;"
 W !,"      var style = state.tokenize(stream, state);"
 W !,"      if ((style || type) && style != ""comment"") {"
 W !,"        setStyle = null;"
 W !,"        state.state = state.state(type || style, stream, state);"
 W !,"        if (setStyle)"
 W !,"          style = setStyle == ""error"" ? style + "" error"" : setStyle;"
 W !,"      }"
 W !,"      return style;"
 W !,"    },"

 W !,"    indent: function(state, textAfter, fullLine) {"
 W !,"      var context = state.context;"
 W !,"      // Indent multi-line strings (e.g. css)."
 W !,"      if (state.tokenize.isInAttribute) {"
 W !,"        if (state.tagStart == state.indented)"
 W !,"          return state.stringStartCol + 1;"
 W !,"        else"
 W !,"          return state.indented + indentUnit;"
 W !,"      }"
 W !,"      if (context && context.noIndent) return CodeMirror.Pass;"
 W !,"      if (state.tokenize != inTag && state.tokenize != inText)"
 W !,"        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;"
 W !,"      // Indent the starts of attribute names."
 W !,"      if (state.tagName) {"
 W !,"        if (config.multilineTagIndentPastTag !== false)"
 W !,"          return state.tagStart + state.tagName.length + 2;"
 W !,"        else"
 W !,"          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);"
 W !,"      }"
 W !,"      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;"
 W !,"      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);"
 W !,"      if (tagAfter && tagAfter[1]) { // Closing tag spotted"
 W !,"        while (context) {"
 W !,"          if (context.tagName == tagAfter[2]) {"
 W !,"            context = context.prev;"
 W !,"            break;"
 W !,"          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {"
 W !,"            context = context.prev;"
 W !,"          } else {"
 W !,"            break;"
 W !,"          }"
 W !,"        }"
 W !,"      } else if (tagAfter) { // Opening tag spotted"
 W !,"        while (context) {"
 W !,"          var grabbers = config.contextGrabbers[context.tagName];"
 W !,"          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))"
 W !,"            context = context.prev;"
 W !,"          else"
 W !,"            break;"
 W !,"        }"
 W !,"      }"
 W !,"      while (context && context.prev && !context.startOfLine)"
 W !,"        context = context.prev;"
 W !,"      if (context) return context.indent + indentUnit;"
 W !,"      else return state.baseIndent || 0;"
 W !,"    },"

 W !,"    electricInput: /<\/[\s\w:]+>$/,"
 W !,"    blockCommentStart: ""<!--"","
 W !,"    blockCommentEnd: ""-->"","

 W !,"    configuration: config.htmlMode ? ""html"" : ""xml"","
 W !,"    helperType: config.htmlMode ? ""html"" : ""xml"","

 W !,"    skipAttribute: function(state) {"
 W !,"      if (state.state == attrValueState)"
 W !,"        state.state = attrState"
 W !,"    }"
 W !,"  };"
 W !,"});"

 W !,"CodeMirror.defineMIME(""text/xml"", ""xml"");"
 W !,"CodeMirror.defineMIME(""application/xml"", ""xml"");"
 W !,"if (!CodeMirror.mimeModes.hasOwnProperty(""text/html""))"
 W !,"  CodeMirror.defineMIME(""text/html"", {name: ""xml"", htmlMode: true});"

 W !,"});"
}

ClassMethod ScriptAddonMerge()
{
	Do ..ScriptAddonMerge1()
	Do ..ScriptAddonMerge2()
}

ClassMethod ScriptAddonMerge1()
{
   W !,"// CodeMirror, copyright (c) by Marijn Haverbeke and others"
 W !,"// Distributed under an MIT license: http://codemirror.net/LICENSE"
 W !,""
 W !,"// declare global: diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL"
 W !,""
 W !,"(function(mod) {"
 W !,"  if (typeof exports == ""object"" && typeof module == ""object"") // CommonJS"
 W !,"    mod(require(""ompare.Report.SourceView.cls?Script=ScriptLibCodemirror"")); // Note non-packaged dependency diff_match_patch"
 W !,"  else if (typeof define == ""function"" && define.amd) // AMD"
 W !,"    define([""ompare.Report.SourceView.cls?Script=ScriptLibCodemirror"", ""diff_match_patch""], mod);"
 W !,"  else // Plain browser env"
 W !,"    mod(CodeMirror);"
 W !,"})(function(CodeMirror) {"
 W !,"  ""use strict"";"
 W !,"  var Pos = CodeMirror.Pos;"
 W !,"  var svgNS = ""http://www.w3.org/2000/svg"";"
 W !,""
 W !,"  function DiffView(mv, type) {"
 W !,"    this.mv = mv;"
 W !,"    this.type = type;"
 W !,"    this.classes = type == ""left"""
 W !,"      ? {chunk: ""CodeMirror-merge-l-chunk"","
 W !,"         start: ""CodeMirror-merge-l-chunk-start"","
 W !,"         end: ""CodeMirror-merge-l-chunk-end"","
 W !,"         insert: ""CodeMirror-merge-l-inserted"","
 W !,"         del: ""CodeMirror-merge-l-deleted"","
 W !,"         connect: ""CodeMirror-merge-l-connect""}"
 W !,"      : {chunk: ""CodeMirror-merge-r-chunk"","
 W !,"         start: ""CodeMirror-merge-r-chunk-start"","
 W !,"         end: ""CodeMirror-merge-r-chunk-end"","
 W !,"         insert: ""CodeMirror-merge-r-inserted"","
 W !,"         del: ""CodeMirror-merge-r-deleted"","
 W !,"         connect: ""CodeMirror-merge-r-connect""};"
 W !,"  }"
 W !,""
 W !,"  DiffView.prototype = {"
 W !,"    constructor: DiffView,"
 W !,"    init: function(pane, orig, options) {"
 W !,"      this.edit = this.mv.edit;"
 W !,"      (this.edit.state.diffViews || (this.edit.state.diffViews = [])).push(this);"
 W !,"      this.orig = CodeMirror(pane, copyObj({value: orig, readOnly: !this.mv.options.allowEditingOriginals}, copyObj(options)));"
 W !,"      this.orig.state.diffViews = [this];"
 W !,""
 W !,"      this.diff = getDiff(asString(orig), asString(options.value));"
 W !,"      this.chunks = getChunks(this.diff);"
 W !,"      this.diffOutOfDate = this.dealigned = false;"
 W !,""
 W !,"      this.showDifferences = options.showDifferences !== false;"
 W !,"      this.forceUpdate = registerUpdate(this);"
 W !,"      setScrollLock(this, true, false);"
 W !,"      registerScroll(this);"
 W !,"    },"
 W !,"    setShowDifferences: function(val) {"
 W !,"      val = val !== false;"
 W !,"      if (val != this.showDifferences) {"
 W !,"        this.showDifferences = val;"
 W !,"        this.forceUpdate(""full"");"
 W !,"      }"
 W !,"    }"
 W !,"  };"
 W !,""
 W !,"  function ensureDiff(dv) {"
 W !,"    if (dv.diffOutOfDate) {"
 W !,"      dv.diff = getDiff(dv.orig.getValue(), dv.edit.getValue());"
 W !,"      dv.chunks = getChunks(dv.diff);"
 W !,"      dv.diffOutOfDate = false;"
 W !,"      CodeMirror.signal(dv.edit, ""updateDiff"", dv.diff);"
 W !,"    }"
 W !,"  }"
 W !,""
 W !,"  var updating = false;"
 W !,"  function registerUpdate(dv) {"
 W !,"    var edit = {from: 0, to: 0, marked: []};"
 W !,"    var orig = {from: 0, to: 0, marked: []};"
 W !,"    var debounceChange, updatingFast = false;"
 W !,"    function update(mode) {"
 W !,"      updating = true;"
 W !,"      updatingFast = false;"
 W !,"      if (mode == ""full"") {"
 W !,"        if (dv.svg) clear(dv.svg);"
 W !,"        if (dv.copyButtons) clear(dv.copyButtons);"
 W !,"        clearMarks(dv.edit, edit.marked, dv.classes);"
 W !,"        clearMarks(dv.orig, orig.marked, dv.classes);"
 W !,"        edit.from = edit.to = orig.from = orig.to = 0;"
 W !,"      }"
 W !,"      ensureDiff(dv);"
 W !,"      if (dv.showDifferences) {"
 W !,"        updateMarks(dv.edit, dv.diff, edit, DIFF_INSERT, dv.classes);"
 W !,"        updateMarks(dv.orig, dv.diff, orig, DIFF_DELETE, dv.classes);"
 W !,"      }"
 W !,"      makeConnections(dv);"
 W !,""
 W !,"      if (dv.mv.options.connect == ""align"")"
 W !,"        alignChunks(dv);"
 W !,"      updating = false;"
 W !,"    }"
 W !,"    function setDealign(fast) {"
 W !,"      if (updating) return;"
 W !,"      dv.dealigned = true;"
 W !,"      set(fast);"
 W !,"    }"
 W !,"    function set(fast) {"
 W !,"      if (updating || updatingFast) return;"
 W !,"      clearTimeout(debounceChange);"
 W !,"      if (fast === true) updatingFast = true;"
 W !,"      debounceChange = setTimeout(update, fast === true ? 20 : 250);"
 W !,"    }"
 W !,"    function change(_cm, change) {"
 W !,"      if (!dv.diffOutOfDate) {"
 W !,"        dv.diffOutOfDate = true;"
 W !,"        edit.from = edit.to = orig.from = orig.to = 0;"
 W !,"      }"
 W !,"      // Update faster when a line was added/removed"
 W !,"      setDealign(change.text.length - 1 != change.to.line - change.from.line);"
 W !,"    }"
 W !,"    dv.edit.on(""change"", change);"
 W !,"    dv.orig.on(""change"", change);"
 W !,"    dv.edit.on(""markerAdded"", setDealign);"
 W !,"    dv.edit.on(""markerCleared"", setDealign);"
 W !,"    dv.orig.on(""markerAdded"", setDealign);"
 W !,"    dv.orig.on(""markerCleared"", setDealign);"
 W !,"    dv.edit.on(""viewportChange"", function() { set(false); });"
 W !,"    dv.orig.on(""viewportChange"", function() { set(false); });"
 W !,"    update();"
 W !,"    return update;"
 W !,"  }"
 W !,""
 W !,"  function registerScroll(dv) {"
 W !,"    dv.edit.on(""scroll"", function() {"
 W !,"      syncScroll(dv, DIFF_INSERT) && makeConnections(dv);"
 W !,"    });"
 W !,"    dv.orig.on(""scroll"", function() {"
 W !,"      syncScroll(dv, DIFF_DELETE) && makeConnections(dv);"
 W !,"    });"
 W !,"  }"
 W !,""
 W !,"  function syncScroll(dv, type) {"
 W !,"    // Change handler will do a refresh after a timeout when diff is out of date"
 W !,"    if (dv.diffOutOfDate) return false;"
 W !,"    if (!dv.lockScroll) return true;"
 W !,"    var editor, other, now = +new Date;"
 W !,"    if (type == DIFF_INSERT) { editor = dv.edit; other = dv.orig; }"
 W !,"    else { editor = dv.orig; other = dv.edit; }"
 W !,"    // Don't take action if the position of this editor was recently set"
 W !,"    // (to prevent feedback loops)"
 W !,"    if (editor.state.scrollSetBy == dv && (editor.state.scrollSetAt || 0) + 50 > now) return false;"
 W !,""
 W !,"    var sInfo = editor.getScrollInfo();"
 W !,"    if (dv.mv.options.connect == ""align"") {"
 W !,"      targetPos = sInfo.top;"
 W !,"    } else {"
 W !,"      var halfScreen = .5 * sInfo.clientHeight, midY = sInfo.top + halfScreen;"
 W !,"      var mid = editor.lineAtHeight(midY, ""local"");"
 W !,"      var around = chunkBoundariesAround(dv.chunks, mid, type == DIFF_INSERT);"
 W !,"      var off = getOffsets(editor, type == DIFF_INSERT ? around.edit : around.orig);"
 W !,"      var offOther = getOffsets(other, type == DIFF_INSERT ? around.orig : around.edit);"
 W !,"      var ratio = (midY - off.top) / (off.bot - off.top);"
 W !,"      var targetPos = (offOther.top - halfScreen) + ratio * (offOther.bot - offOther.top);"
 W !,""
 W !,"      var botDist, mix;"
 W !,"      // Some careful tweaking to make sure no space is left out of view"
 W !,"      // when scrolling to top or bottom."
 W !,"      if (targetPos > sInfo.top && (mix = sInfo.top / halfScreen) < 1) {"
 W !,"        targetPos = targetPos * mix + sInfo.top * (1 - mix);"
 W !,"      } else if ((botDist = sInfo.height - sInfo.clientHeight - sInfo.top) < halfScreen) {"
 W !,"        var otherInfo = other.getScrollInfo();"
 W !,"        var botDistOther = otherInfo.height - otherInfo.clientHeight - targetPos;"
 W !,"        if (botDistOther > botDist && (mix = botDist / halfScreen) < 1)"
 W !,"          targetPos = targetPos * mix + (otherInfo.height - otherInfo.clientHeight - botDist) * (1 - mix);"
 W !,"      }"
 W !,"    }"
 W !,""
 W !,"    other.scrollTo(sInfo.left, targetPos);"
 W !,"    other.state.scrollSetAt = now;"
 W !,"    other.state.scrollSetBy = dv;"
 W !,"    return true;"
 W !,"  }"
 W !,""
 W !,"  function getOffsets(editor, around) {"
 W !,"    var bot = around.after;"
 W !,"    if (bot == null) bot = editor.lastLine() + 1;"
 W !,"    return {top: editor.heightAtLine(around.before || 0, ""local""),"
 W !,"            bot: editor.heightAtLine(bot, ""local"")};"
 W !,"  }"
 W !,""
 W !,"  function setScrollLock(dv, val, action) {"
 W !,"    dv.lockScroll = val;"
 W !,"    if (val && action != false) syncScroll(dv, DIFF_INSERT) && makeConnections(dv);"
 W !,"    dv.lockButton.innerHTML = val ? ""\u21db\u21da"" : ""\u21db&nbsp;&nbsp;\u21da"";"
 W !,"  }"
 W !,""
 W !,"  // Updating the marks for editor content"
 W !,""
 W !,"  function clearMarks(editor, arr, classes) {"
 W !,"    for (var i = 0; i < arr.length; ++i) {"
 W !,"      var mark = arr[i];"
 W !,"      if (mark instanceof CodeMirror.TextMarker) {"
 W !,"        mark.clear();"
 W !,"      } else if (mark.parent) {"
 W !,"        editor.removeLineClass(mark, ""background"", classes.chunk);"
 W !,"        editor.removeLineClass(mark, ""background"", classes.start);"
 W !,"        editor.removeLineClass(mark, ""background"", classes.end);"
 W !,"      }"
 W !,"    }"
 W !,"    arr.length = 0;"
 W !,"  }"
 W !,""
 W !,"  // FIXME maybe add a margin around viewport to prevent too many updates"
 W !,"  function updateMarks(editor, diff, state, type, classes) {"
 W !,"    var vp = editor.getViewport();"
 W !,"    editor.operation(function() {"
 W !,"      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {"
 W !,"        clearMarks(editor, state.marked, classes);"
 W !,"        markChanges(editor, diff, type, state.marked, vp.from, vp.to, classes);"
 W !,"        state.from = vp.from; state.to = vp.to;"
 W !,"      } else {"
 W !,"        if (vp.from < state.from) {"
 W !,"          markChanges(editor, diff, type, state.marked, vp.from, state.from, classes);"
 W !,"          state.from = vp.from;"
 W !,"        }"
 W !,"        if (vp.to > state.to) {"
 W !,"          markChanges(editor, diff, type, state.marked, state.to, vp.to, classes);"
 W !,"          state.to = vp.to;"
 W !,"        }"
 W !,"      }"
 W !,"    });"
 W !,"  }"
 W !,""
 W !,"  function markChanges(editor, diff, type, marks, from, to, classes) {"
 W !,"    var pos = Pos(0, 0);"
 W !,"    var top = Pos(from, 0), bot = editor.clipPos(Pos(to - 1));"
 W !,"    var cls = type == DIFF_DELETE ? classes.del : classes.insert;"
 W !,"    function markChunk(start, end) {"
 W !,"      var bfrom = Math.max(from, start), bto = Math.min(to, end);"
 W !,"      for (var i = bfrom; i < bto; ++i) {"
 W !,"        var line = editor.addLineClass(i, ""background"", classes.chunk);"
 W !,"        if (i == start) editor.addLineClass(line, ""background"", classes.start);"
 W !,"        if (i == end - 1) editor.addLineClass(line, ""background"", classes.end);"
 W !,"        marks.push(line);"
 W !,"      }"
 W !,"      // When the chunk is empty, make sure a horizontal line shows up"
 W !,"      if (start == end && bfrom == end && bto == end) {"
 W !,"        if (bfrom)"
 W !,"          marks.push(editor.addLineClass(bfrom - 1, ""background"", classes.end));"
 W !,"        else"
 W !,"          marks.push(editor.addLineClass(bfrom, ""background"", classes.start));"
 W !,"      }"
 W !,"    }"
 W !,""
 W !,"    var chunkStart = 0;"
 W !,"    for (var i = 0; i < diff.length; ++i) {"
 W !,"      var part = diff[i], tp = part[0], str = part[1];"
 W !,"      if (tp == DIFF_EQUAL) {"
 W !,"        var cleanFrom = pos.line + (startOfLineClean(diff, i) ? 0 : 1);"
 W !,"        moveOver(pos, str);"
 W !,"        var cleanTo = pos.line + (endOfLineClean(diff, i) ? 1 : 0);"
 W !,"        if (cleanTo > cleanFrom) {"
 W !,"          if (i) markChunk(chunkStart, cleanFrom);"
 W !,"          chunkStart = cleanTo;"
 W !,"        }"
 W !,"      } else {"
 W !,"        if (tp == type) {"
 W !,"          var end = moveOver(pos, str, true);"
 W !,"          var a = posMax(top, pos), b = posMin(bot, end);"
 W !,"          if (!posEq(a, b))"
 W !,"            marks.push(editor.markText(a, b, {className: cls}));"
 W !,"          pos = end;"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"    if (chunkStart <= pos.line) markChunk(chunkStart, pos.line + 1);"
 W !,"  }"
 W !,""
 W !,"  // Updating the gap between editor and original"
 W !,""
 W !,"  function makeConnections(dv) {"
 W !,"    if (!dv.showDifferences) return;"
 W !,""
 W !,"    if (dv.svg) {"
 W !,"      clear(dv.svg);"
 W !,"      var w = dv.gap.offsetWidth;"
 W !,"      attrs(dv.svg, ""width"", w, ""height"", dv.gap.offsetHeight);"
 W !,"    }"
 W !,"    if (dv.copyButtons) clear(dv.copyButtons);"
 W !,""
 W !,"    var vpEdit = dv.edit.getViewport(), vpOrig = dv.orig.getViewport();"
 W !,"    var sTopEdit = dv.edit.getScrollInfo().top, sTopOrig = dv.orig.getScrollInfo().top;"
 W !,"    for (var i = 0; i < dv.chunks.length; i++) {"
 W !,"      var ch = dv.chunks[i];"
 W !,"      if (ch.editFrom <= vpEdit.to && ch.editTo >= vpEdit.from &&"
 W !,"          ch.origFrom <= vpOrig.to && ch.origTo >= vpOrig.from)"
 W !,"        drawConnectorsForChunk(dv, ch, sTopOrig, sTopEdit, w);"
 W !,"    }"
 W !,"  }"
 W !,""
 W !,"  function getMatchingOrigLine(editLine, chunks) {"
 W !,"    var editStart = 0, origStart = 0;"
 W !,"    for (var i = 0; i < chunks.length; i++) {"
 W !,"      var chunk = chunks[i];"
 W !,"      if (chunk.editTo > editLine && chunk.editFrom <= editLine) return null;"
 W !,"      if (chunk.editFrom > editLine) break;"
 W !,"      editStart = chunk.editTo;"
 W !,"      origStart = chunk.origTo;"
 W !,"    }"
 W !,"    return origStart + (editLine - editStart);"
 W !,"  }"
 W !,""
 W !,"  function findAlignedLines(dv, other) {"
 W !,"    var linesToAlign = [];"
 W !,"    for (var i = 0; i < dv.chunks.length; i++) {"
 W !,"      var chunk = dv.chunks[i];"
 W !,"      linesToAlign.push([chunk.origTo, chunk.editTo, other ? getMatchingOrigLine(chunk.editTo, other.chunks) : null]);"
 W !,"    }"
 W !,"    if (other) {"
 W !,"      for (var i = 0; i < other.chunks.length; i++) {"
 W !,"        var chunk = other.chunks[i];"
 W !,"        for (var j = 0; j < linesToAlign.length; j++) {"
 W !,"          var align = linesToAlign[j];"
 W !,"          if (align[1] == chunk.editTo) {"
 W !,"            j = -1;"
 W !,"            break;"
 W !,"          } else if (align[1] > chunk.editTo) {"
 W !,"            break;"
 W !,"          }"
 W !,"        }"
 W !,"        if (j > -1)"
 W !,"          linesToAlign.splice(j - 1, 0, [getMatchingOrigLine(chunk.editTo, dv.chunks), chunk.editTo, chunk.origTo]);"
 W !,"      }"
 W !,"    }"
 W !,"    return linesToAlign;"
 W !,"  }"
 W !,""
 W !,"  function alignChunks(dv, force) {"
 W !,"    if (!dv.dealigned && !force) return;"
 W !,"    if (!dv.orig.curOp) return dv.orig.operation(function() {"
 W !,"      alignChunks(dv, force);"
 W !,"    });"
 W !,""
 W !,"    dv.dealigned = false;"
 W !,"    var other = dv.mv.left == dv ? dv.mv.right : dv.mv.left;"
 W !,"    if (other) {"
 W !,"      ensureDiff(other);"
 W !,"      other.dealigned = false;"
 W !,"    }"
 W !,"    var linesToAlign = findAlignedLines(dv, other);"
 W !,""
 W !,"    // Clear old aligners"
 W !,"    var aligners = dv.mv.aligners;"
 W !,"    for (var i = 0; i < aligners.length; i++)"
 W !,"      aligners[i].clear();"
 W !,"    aligners.length = 0;"
 W !,""
 W !,"    var cm = [dv.orig, dv.edit], scroll = [];"
 W !,"    if (other) cm.push(other.orig);"
 W !,"    for (var i = 0; i < cm.length; i++)"
 W !,"      scroll.push(cm[i].getScrollInfo().top);"
 W !,""
 W !,"    for (var ln = 0; ln < linesToAlign.length; ln++)"
 W !,"      alignLines(cm, linesToAlign[ln], aligners);"
 W !,""
 W !,"    for (var i = 0; i < cm.length; i++)"
 W !,"      cm[i].scrollTo(null, scroll[i]);"
 W !,"  }"
 W !,""
 W !,"  function alignLines(cm, lines, aligners) {"
 W !,"    var maxOffset = 0, offset = [];"
 W !,"    for (var i = 0; i < cm.length; i++) if (lines[i] != null) {"
 W !,"      var off = cm[i].heightAtLine(lines[i], ""local"");"
 W !,"      offset[i] = off;"
 W !,"      maxOffset = Math.max(maxOffset, off);"
 W !,"    }"
 W !,"    for (var i = 0; i < cm.length; i++) if (lines[i] != null) {"
 W !,"      var diff = maxOffset - offset[i];"
 W !,"      if (diff > 1)"
 W !,"        aligners.push(padAbove(cm[i], lines[i], diff));"
 W !,"    }"
 W !,"  }"
 W !,""
 W !,"  function padAbove(cm, line, size) {"
 W !,"    var above = true;"
 W !,"    if (line > cm.lastLine()) {"
 W !,"      line--;"
 W !,"      above = false;"
 W !,"    }"
 W !,"    var elt = document.createElement(""div"");"
 W !,"    elt.className = ""CodeMirror-merge-spacer"";"
 W !,"    elt.style.height = size + ""px""; elt.style.minWidth = ""1px"";"
 W !,"    return cm.addLineWidget(line, elt, {height: size, above: above});"
 W !,"  }"
 W !,""
 W !,"  function drawConnectorsForChunk(dv, chunk, sTopOrig, sTopEdit, w) {"
 W !,"    var flip = dv.type == ""left"";"
 W !,"    var top = dv.orig.heightAtLine(chunk.origFrom, ""local"") - sTopOrig;"
 W !,"    if (dv.svg) {"
 W !,"      var topLpx = top;"
 W !,"      var topRpx = dv.edit.heightAtLine(chunk.editFrom, ""local"") - sTopEdit;"
 W !,"      if (flip) { var tmp = topLpx; topLpx = topRpx; topRpx = tmp; }"
 W !,"      var botLpx = dv.orig.heightAtLine(chunk.origTo, ""local"") - sTopOrig;"
 W !,"      var botRpx = dv.edit.heightAtLine(chunk.editTo, ""local"") - sTopEdit;"
 W !,"      if (flip) { var tmp = botLpx; botLpx = botRpx; botRpx = tmp; }"
 W !,"      var curveTop = "" C "" + w/2 + "" "" + topRpx + "" "" + w/2 + "" "" + topLpx + "" "" + (w + 2) + "" "" + topLpx;"
 W !,"      var curveBot = "" C "" + w/2 + "" "" + botLpx + "" "" + w/2 + "" "" + botRpx + "" -1 "" + botRpx;"
 W !,"      attrs(dv.svg.appendChild(document.createElementNS(svgNS, ""path"")),"
 W !,"            ""d"", ""M -1 "" + topRpx + curveTop + "" L "" + (w + 2) + "" "" + botLpx + curveBot + "" z"","
 W !,"            ""class"", dv.classes.connect);"
 W !,"    }"
 W !,"    if (dv.copyButtons) {"
 W !,"      var copy = dv.copyButtons.appendChild(elt(""div"", dv.type == ""left"" ? ""\u21dd"" : ""\u21dc"","
 W !,"                                                ""CodeMirror-merge-copy""));"
 W !,"      var editOriginals = dv.mv.options.allowEditingOriginals;"
 W !,"      copy.title = editOriginals ? ""Push to left"" : ""Revert chunk"";"
 W !,"      copy.chunk = chunk;"
 W !,"      copy.style.top = top + ""px"";"
 W !,""
 W !,"      if (editOriginals) {"
 W !,"        var topReverse = dv.orig.heightAtLine(chunk.editFrom, ""local"") - sTopEdit;"
 W !,"        var copyReverse = dv.copyButtons.appendChild(elt(""div"", dv.type == ""right"" ? ""\u21dd"" : ""\u21dc"","
 W !,"                                                         ""CodeMirror-merge-copy-reverse""));"
 W !,"        copyReverse.title = ""Push to right"";"
 W !,"        copyReverse.chunk = {editFrom: chunk.origFrom, editTo: chunk.origTo,"
 W !,"                             origFrom: chunk.editFrom, origTo: chunk.editTo};"
 W !,"        copyReverse.style.top = topReverse + ""px"";"
 W !,"        dv.type == ""right"" ? copyReverse.style.left = ""2px"" : copyReverse.style.right = ""2px"";"
 W !,"      }"
 W !,"    }"
 W !,"  }"
 W !,""
 W !,"  function copyChunk(dv, to, from, chunk) {"
 W !,"    if (dv.diffOutOfDate) return;"
 W !,"    var editStart = chunk.editTo > to.lastLine() ? Pos(chunk.editFrom - 1) : Pos(chunk.editFrom, 0)"
 W !,"    var origStart = chunk.origTo > from.lastLine() ? Pos(chunk.origFrom - 1) : Pos(chunk.origFrom, 0)"
 W !,"    to.replaceRange(from.getRange(origStart, Pos(chunk.origTo, 0)), editStart, Pos(chunk.editTo, 0))"
 W !,"  }"
 W !,""
 W !,"  // Merge view, containing 0, 1, or 2 diff views."
 W !,""
 W !,"  var MergeView = CodeMirror.MergeView = function(node, options) {"
 W !,"    if (!(this instanceof MergeView)) return new MergeView(node, options);"
 W !,""
 W !,"    this.options = options;"
 W !,"    var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;"
 W !,""
 W !,"    var hasLeft = origLeft != null, hasRight = origRight != null;"
 W !,"    var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);"
 W !,"    var wrap = [], left = this.left = null, right = this.right = null;"
 W !,"    var self = this;"
 W !,""
 W !,"    if (hasLeft) {"
 W !,"      left = this.left = new DiffView(this, ""left"");"
 W !,"      var leftPane = elt(""div"", null, ""CodeMirror-merge-pane"");"
 W !,"      wrap.push(leftPane);"
 W !,"      wrap.push(buildGap(left));"
 W !,"    }"
 W !,""
 W !,"    var editPane = elt(""div"", null, ""CodeMirror-merge-pane"");"
 W !,"    wrap.push(editPane);"
 W !,""
 W !,"    if (hasRight) {"
 W !,"      right = this.right = new DiffView(this, ""right"");"
 W !,"      wrap.push(buildGap(right));"
 W !,"      var rightPane = elt(""div"", null, ""CodeMirror-merge-pane"");"
 W !,"      wrap.push(rightPane);"
 W !,"    }"
 W !,""
 W !,"    (hasRight ? rightPane : editPane).className += "" CodeMirror-merge-pane-rightmost"";"
 W !,""
 W !,"    wrap.push(elt(""div"", null, null, ""height: 0; clear: both;""));"
 W !,""
 W !,"    var wrapElt = this.wrap = node.appendChild(elt(""div"", wrap, ""CodeMirror-merge CodeMirror-merge-"" + panes + ""pane""));"
 W !,"    this.edit = CodeMirror(editPane, copyObj(options));"
 W !,""
 W !,"    if (left) left.init(leftPane, origLeft, options);"
 W !,"    if (right) right.init(rightPane, origRight, options);"
 W !,""
 W !,"    if (options.collapseIdentical)"
 W !,"      this.editor().operation(function() {"
 W !,"        collapseIdenticalStretches(self, options.collapseIdentical);"
 W !,"      });"
 W !,"    if (options.connect == ""align"") {"
 W !,"      this.aligners = [];"
 W !,"      alignChunks(this.left || this.right, true);"
 W !,"    }"
 W !,""
 W !,"    var onResize = function() {"
 W !,"      if (left) makeConnections(left);"
 W !,"      if (right) makeConnections(right);"
 W !,"    };"
 W !,"    CodeMirror.on(window, ""resize"", onResize);"
 W !,"    var resizeInterval = setInterval(function() {"
 W !,"      for (var p = wrapElt.parentNode; p && p != document.body; p = p.parentNode) {}"
 W !,"      if (!p) { clearInterval(resizeInterval); CodeMirror.off(window, ""resize"", onResize); }"
 W !,"    }, 5000);"
 W !,"  };"
 W !,""
 W !,"  function buildGap(dv) {"
 W !,"    var lock = dv.lockButton = elt(""div"", null, ""CodeMirror-merge-scrolllock"");"
 W !,"    lock.title = ""Toggle locked scrolling"";"
 W !,"    var lockWrap = elt(""div"", [lock], ""CodeMirror-merge-scrolllock-wrap"");"
 W !,"    CodeMirror.on(lock, ""click"", function() { setScrollLock(dv, !dv.lockScroll); });"
 W !,"    var gapElts = [lockWrap];"
 W !,"    if (dv.mv.options.revertButtons !== false) {"
 W !,"      dv.copyButtons = elt(""div"", null, ""CodeMirror-merge-copybuttons-"" + dv.type);"
 W !,"      CodeMirror.on(dv.copyButtons, ""click"", function(e) {"
 W !,"        var node = e.target || e.srcElement;"
 W !,"        if (!node.chunk) return;"
 W !,"        if (node.className == ""CodeMirror-merge-copy-reverse"") {"
 W !,"          copyChunk(dv, dv.orig, dv.edit, node.chunk);"
 W !,"          return;"
 W !,"        }"
 W !,"        copyChunk(dv, dv.edit, dv.orig, node.chunk);"
 W !,"      });"
 W !,"      gapElts.unshift(dv.copyButtons);"
 W !,"    }"
 W !,"    if (dv.mv.options.connect != ""align"") {"
 W !,"      var svg = document.createElementNS && document.createElementNS(svgNS, ""svg"");"
 W !,"      if (svg && !svg.createSVGRect) svg = null;"
 W !,"      dv.svg = svg;"
 W !,"      if (svg) gapElts.push(svg);"
 W !,"    }"
 W !,""
 W !,"    return dv.gap = elt(""div"", gapElts, ""CodeMirror-merge-gap"");"
 W !,"  }"
 W !,""
 W !,"  MergeView.prototype = {"
 W !,"    constuctor: MergeView,"
 W !,"    editor: function() { return this.edit; },"
 W !,"    rightOriginal: function() { return this.right && this.right.orig; },"
 W !,"    leftOriginal: function() { return this.left && this.left.orig; },"
 W !,"    setShowDifferences: function(val) {"
 W !,"      if (this.right) this.right.setShowDifferences(val);"
 W !,"      if (this.left) this.left.setShowDifferences(val);"
 W !,"    },"
 W !,"    rightChunks: function() {"
 W !,"      if (this.right) { ensureDiff(this.right); return this.right.chunks; }"
 W !,"    },"
 W !,"    leftChunks: function() {"
 W !,"      if (this.left) { ensureDiff(this.left); return this.left.chunks; }"
 W !,"    }"
 W !,"  };"
 W !,""
 W !,"  function asString(obj) {"
 W !,"    if (typeof obj == ""string"") return obj;"
 W !,"    else return obj.getValue();"
 W !,"  }"
 W !,""
 W !,"  // Operations on diffs"
 W !,""
 W !,"  var dmp = new diff_match_patch();"
 W !,"  function getDiff(a, b) {"
 W !,"    var diff = dmp.diff_main(a, b);"
 W !,"    dmp.diff_cleanupSemantic(diff);"
 W !,"    // The library sometimes leaves in empty parts, which confuse the algorithm"
 W !,"    for (var i = 0; i < diff.length; ++i) {"
 W !,"      var part = diff[i];"
 W !,"      if (!part[1]) {"
 W !,"        diff.splice(i--, 1);"
 W !,"      } else if (i && diff[i - 1][0] == part[0]) {"
 W !,"        diff.splice(i--, 1);"
 W !,"        diff[i][1] += part[1];"
 W !,"      }"
 W !,"    }"
 W !,"    return diff;"
 W !,"  }"
 W !,""
 W !,"  function getChunks(diff) {"
 W !,"    var chunks = [];"
 W !,"    var startEdit = 0, startOrig = 0;"
 W !,"    var edit = Pos(0, 0), orig = Pos(0, 0);"
 W !,"    for (var i = 0; i < diff.length; ++i) {"
 W !,"      var part = diff[i], tp = part[0];"
 W !,"      if (tp == DIFF_EQUAL) {"
 W !,"        var startOff = startOfLineClean(diff, i) ? 0 : 1;"
 W !,"        var cleanFromEdit = edit.line + startOff, cleanFromOrig = orig.line + startOff;"
 W !,"        moveOver(edit, part[1], null, orig);"
 W !,"        var endOff = endOfLineClean(diff, i) ? 1 : 0;"
 W !,"        var cleanToEdit = edit.line + endOff, cleanToOrig = orig.line + endOff;"
 W !,"        if (cleanToEdit > cleanFromEdit) {"
 W !,"          if (i) chunks.push({origFrom: startOrig, origTo: cleanFromOrig,"
 W !,"                              editFrom: startEdit, editTo: cleanFromEdit});"
 W !,"          startEdit = cleanToEdit; startOrig = cleanToOrig;"
 W !,"        }"
 W !,"      } else {"
 W !,"        moveOver(tp == DIFF_INSERT ? edit : orig, part[1]);"
 W !,"      }"
 W !,"    }"
 W !,"    if (startEdit <= edit.line || startOrig <= orig.line)"
 W !,"      chunks.push({origFrom: startOrig, origTo: orig.line + 1,"
 W !,"                   editFrom: startEdit, editTo: edit.line + 1});"
 W !,"    return chunks;"
 W !,"  }"
 W !,""
 W !,"  function endOfLineClean(diff, i) {"
 W !,"    if (i == diff.length - 1) return true;"
 W !,"    var next = diff[i + 1][1];"
 W !,"    if (next.length == 1 || next.charCodeAt(0) != 10) return false;"
 W !,"    if (i == diff.length - 2) return true;"
 W !,"    next = diff[i + 2][1];"
 W !,"    return next.length > 1 && next.charCodeAt(0) == 10;"
 W !,"  }"
 W !,""
 W !,"  function startOfLineClean(diff, i) {"
 W !,"    if (i == 0) return true;"
 W !,"    var last = diff[i - 1][1];"
 W !,"    if (last.charCodeAt(last.length - 1) != 10) return false;"
 W !,"    if (i == 1) return true;"
 W !,"    last = diff[i - 2][1];"
 W !,"    return last.charCodeAt(last.length - 1) == 10;"
 W !,"  }"
 W !,""
 W !,"  function chunkBoundariesAround(chunks, n, nInEdit) {"
 W !,"    var beforeE, afterE, beforeO, afterO;"
 W !,"    for (var i = 0; i < chunks.length; i++) {"
 W !,"      var chunk = chunks[i];"
 W !,"      var fromLocal = nInEdit ? chunk.editFrom : chunk.origFrom;"
 W !,"      var toLocal = nInEdit ? chunk.editTo : chunk.origTo;"
 W !,"      if (afterE == null) {"
 W !,"        if (fromLocal > n) { afterE = chunk.editFrom; afterO = chunk.origFrom; }"
 W !,"        else if (toLocal > n) { afterE = chunk.editTo; afterO = chunk.origTo; }"
 W !,"      }"
 W !,"      if (toLocal <= n) { beforeE = chunk.editTo; beforeO = chunk.origTo; }"
 W !,"      else if (fromLocal <= n) { beforeE = chunk.editFrom; beforeO = chunk.origFrom; }"
 W !,"    }"
 W !,"    return {edit: {before: beforeE, after: afterE}, orig: {before: beforeO, after: afterO}};"
 W !,"  }"
 W !,""
 W !,"  function collapseSingle(cm, from, to) {"
 W !,"    cm.addLineClass(from, ""wrap"", ""CodeMirror-merge-collapsed-line"");"
 W !,"    var widget = document.createElement(""span"");"
 W !,"    widget.className = ""CodeMirror-merge-collapsed-widget"";"
 W !,"    widget.title = ""Identical text collapsed. Click to expand."";"
 W !,"    var mark = cm.markText(Pos(from, 0), Pos(to - 1), {"
 W !,"      inclusiveLeft: true,"
 W !,"      inclusiveRight: true,"
 W !,"      replacedWith: widget,"
 W !,"      clearOnEnter: true"
 W !,"    });"
 W !,"    function clear() {"
 W !,"      mark.clear();"
 W !,"      cm.removeLineClass(from, ""wrap"", ""CodeMirror-merge-collapsed-line"");"
 W !,"    }"
 W !,"    CodeMirror.on(widget, ""click"", clear);"
 W !,"    return {mark: mark, clear: clear};"
 W !,"  }"
 W !,""
 W !,"  function collapseStretch(size, editors) {"
 W !,"    var marks = [];"
 W !,"    function clear() {"
 W !,"      for (var i = 0; i < marks.length; i++) marks[i].clear();"
 W !,"    }"
 W !,"    for (var i = 0; i < editors.length; i++) {"
 W !,"      var editor = editors[i];"
 W !,"      var mark = collapseSingle(editor.cm, editor.line, editor.line + size);"
 W !,"      marks.push(mark);"
 W !,"      mark.mark.on(""clear"", clear);"
 W !,"    }"
 W !,"    return marks[0].mark;"
 W !,"  }"
 W !,""
 W !,"  function unclearNearChunks(dv, margin, off, clear) {"
 W !,"    for (var i = 0; i < dv.chunks.length; i++) {"
 W !,"      var chunk = dv.chunks[i];"
 W !,"      for (var l = chunk.editFrom - margin; l < chunk.editTo + margin; l++) {"
 W !,"        var pos = l + off;"
 W !,"        if (pos >= 0 && pos < clear.length) clear[pos] = false;"
 W !,"      }"
 W !,"    }"
 W !,"  }"
 W !,""
 W !,"  function collapseIdenticalStretches(mv, margin) {"
 W !,"    if (typeof margin != ""number"") margin = 2;"
 W !,"    var clear = [], edit = mv.editor(), off = edit.firstLine();"
 W !,"    for (var l = off, e = edit.lastLine(); l <= e; l++) clear.push(true);"
 W !,"    if (mv.left) unclearNearChunks(mv.left, margin, off, clear);"
 W !,"    if (mv.right) unclearNearChunks(mv.right, margin, off, clear);"
 W !,""
 W !,"    for (var i = 0; i < clear.length; i++) {"
 W !,"      if (clear[i]) {"
 W !,"        var line = i + off;"
 W !,"        for (var size = 1; i < clear.length - 1 && clear[i + 1]; i++, size++) {}"
 W !,"        if (size > margin) {"
 W !,"          var editors = [{line: line, cm: edit}];"
 W !,"          if (mv.left) editors.push({line: getMatchingOrigLine(line, mv.left.chunks), cm: mv.left.orig});"
 W !,"          if (mv.right) editors.push({line: getMatchingOrigLine(line, mv.right.chunks), cm: mv.right.orig});"
 W !,"          var mark = collapseStretch(size, editors);"
 W !,"          if (mv.options.onCollapse) mv.options.onCollapse(mv, line, size, mark);"
 W !,"        }"
 W !,"      }"
 W !,"    }"
 W !,"  }"
 W !,""
}

ClassMethod ScriptAddonMerge2()
{
 W !,"  // General utilities"
 W !,""
 W !,"  function elt(tag, content, className, style) {"
 W !,"    var e = document.createElement(tag);"
 W !,"    if (className) e.className = className;"
 W !,"    if (style) e.style.cssText = style;"
 W !,"    if (typeof content == ""string"") e.appendChild(document.createTextNode(content));"
 W !,"    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);"
 W !,"    return e;"
 W !,"  }"
 W !,""
 W !,"  function clear(node) {"
 W !,"    for (var count = node.childNodes.length; count > 0; --count)"
 W !,"      node.removeChild(node.firstChild);"
 W !,"  }"
 W !,""
 W !,"  function attrs(elt) {"
 W !,"    for (var i = 1; i < arguments.length; i += 2)"
 W !,"      elt.setAttribute(arguments[i], arguments[i+1]);"
 W !,"  }"
 W !,""
 W !,"  function copyObj(obj, target) {"
 W !,"    if (!target) target = {};"
 W !,"    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];"
 W !,"    return target;"
 W !,"  }"
 W !,""
 W !,"  function moveOver(pos, str, copy, other) {"
 W !,"    var out = copy ? Pos(pos.line, pos.ch) : pos, at = 0;"
 W !,"    for (;;) {"
 W !,"      var nl = str.indexOf(""\n"", at);"
 W !,"      if (nl == -1) break;"
 W !,"      ++out.line;"
 W !,"      if (other) ++other.line;"
 W !,"      at = nl + 1;"
 W !,"    }"
 W !,"    out.ch = (at ? 0 : out.ch) + (str.length - at);"
 W !,"    if (other) other.ch = (at ? 0 : other.ch) + (str.length - at);"
 W !,"    return out;"
 W !,"  }"
 W !,""
 W !,"  function posMin(a, b) { return (a.line - b.line || a.ch - b.ch) < 0 ? a : b; }"
 W !,"  function posMax(a, b) { return (a.line - b.line || a.ch - b.ch) > 0 ? a : b; }"
 W !,"  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }"
 W !,""
 W !,"  function findPrevDiff(chunks, start, isOrig) {"
 W !,"    for (var i = chunks.length - 1; i >= 0; i--) {"
 W !,"      var chunk = chunks[i];"
 W !,"      var to = (isOrig ? chunk.origTo : chunk.editTo) - 1;"
 W !,"      if (to < start) return to;"
 W !,"    }"
 W !,"  }"
 W !,""
 W !,"  function findNextDiff(chunks, start, isOrig) {"
 W !,"    for (var i = 0; i < chunks.length; i++) {"
 W !,"      var chunk = chunks[i];"
 W !,"      var from = (isOrig ? chunk.origFrom : chunk.editFrom);"
 W !,"      if (from > start) return from;"
 W !,"    }"
 W !,"  }"
 W !,""
 W !,"  function goNearbyDiff(cm, dir) {"
 W !,"    var found = null, views = cm.state.diffViews, line = cm.getCursor().line;"
 W !,"    if (views) for (var i = 0; i < views.length; i++) {"
 W !,"      var dv = views[i], isOrig = cm == dv.orig;"
 W !,"      ensureDiff(dv);"
 W !,"      var pos = dir < 0 ? findPrevDiff(dv.chunks, line, isOrig) : findNextDiff(dv.chunks, line, isOrig);"
 W !,"      if (pos != null && (found == null || (dir < 0 ? pos > found : pos < found)))"
 W !,"        found = pos;"
 W !,"    }"
 W !,"    if (found != null)"
 W !,"      cm.setCursor(found, 0);"
 W !,"    else"
 W !,"      return CodeMirror.Pass;"
 W !,"  }"
 W !,""
 W !,"  CodeMirror.commands.goNextDiff = function(cm) {"
 W !,"    return goNearbyDiff(cm, 1);"
 W !,"  };"
 W !,"  CodeMirror.commands.goPrevDiff = function(cm) {"
 W !,"    return goNearbyDiff(cm, -1);"
 W !,"  };"
 W !,"});"
 W !,""
}

}

